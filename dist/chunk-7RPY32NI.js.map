{"version":3,"sources":["../src/services/job.service.ts","../src/types/result.ts","../src/services/config.service.ts","../src/types/config.ts","../src/services/project-root.service.ts","../src/services/store.service.ts","../src/types/brands.ts","../src/plugin/git-clone.ts","../src/services/code-unit.service.ts","../src/services/search.service.ts","../src/services/index.service.ts","../src/services/chunking.service.ts","../src/services/code-graph.service.ts","../src/analysis/code-graph.ts","../src/analysis/ast-parser.ts","../src/analysis/tree-sitter-parser.ts","../src/analysis/rust-ast-parser.ts","../src/analysis/go-ast-parser.ts","../src/analysis/parser-factory.ts","../src/analysis/python-ast-parser.ts","../src/db/lance.ts","../src/db/embeddings.ts","../src/crawl/bridge.ts","../src/crawl/schemas.ts","../src/services/index.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport { randomUUID } from 'crypto';\nimport type {\n  Job,\n  CreateJobParams,\n  UpdateJobParams,\n  JobStatus\n} from '../types/job.js';\nimport { Result, ok, err } from '../types/result.js';\n\nexport class JobService {\n  private readonly jobsDir: string;\n\n  constructor(dataDir?: string) {\n    // Default to ~/.local/share/bluera-knowledge/jobs\n    const baseDir = dataDir ?? path.join(\n      process.env['HOME'] ?? process.env['USERPROFILE'] ?? '.',\n      '.local/share/bluera-knowledge'\n    );\n    this.jobsDir = path.join(baseDir, 'jobs');\n\n    // Ensure jobs directory exists\n    if (!fs.existsSync(this.jobsDir)) {\n      fs.mkdirSync(this.jobsDir, { recursive: true });\n    }\n  }\n\n  /**\n   * Create a new job\n   */\n  createJob(params: CreateJobParams): Job {\n    const job: Job = {\n      id: `job_${randomUUID().replace(/-/g, '').substring(0, 12)}`,\n      type: params.type,\n      status: 'pending',\n      progress: 0,\n      message: params.message ?? `${params.type} job created`,\n      details: params.details,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n\n    // Write job to file\n    this.writeJob(job);\n\n    return job;\n  }\n\n  /**\n   * Update an existing job\n   */\n  updateJob(jobId: string, updates: UpdateJobParams): void {\n    const job = this.getJob(jobId);\n\n    if (!job) {\n      throw new Error(`Job ${jobId} not found`);\n    }\n\n    // Merge updates\n    if (updates.status !== undefined) {\n      job.status = updates.status;\n    }\n    if (updates.progress !== undefined) {\n      job.progress = updates.progress;\n    }\n    if (updates.message !== undefined) {\n      job.message = updates.message;\n    }\n    if (updates.details !== undefined) {\n      job.details = { ...job.details, ...updates.details };\n    }\n\n    job.updatedAt = new Date().toISOString();\n\n    // Write updated job\n    this.writeJob(job);\n  }\n\n  /**\n   * Get a job by ID\n   */\n  getJob(jobId: string): Job | null {\n    const jobFile = path.join(this.jobsDir, `${jobId}.json`);\n\n    if (!fs.existsSync(jobFile)) {\n      return null;\n    }\n\n    try {\n      const content = fs.readFileSync(jobFile, 'utf-8');\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      return JSON.parse(content) as Job;\n    } catch (error) {\n      console.error(`Error reading job ${jobId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * List all jobs with optional status filter\n   */\n  listJobs(statusFilter?: JobStatus | JobStatus[]): Job[] {\n    if (!fs.existsSync(this.jobsDir)) {\n      return [];\n    }\n\n    const files = fs.readdirSync(this.jobsDir);\n    const jobs: Job[] = [];\n\n    for (const file of files) {\n      if (!file.endsWith('.json') || file.endsWith('.pid')) {\n        continue;\n      }\n\n      try {\n        const content = fs.readFileSync(path.join(this.jobsDir, file), 'utf-8');\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        const job = JSON.parse(content) as Job;\n\n        if (statusFilter !== undefined) {\n          const filters = Array.isArray(statusFilter) ? statusFilter : [statusFilter];\n          if (filters.includes(job.status)) {\n            jobs.push(job);\n          }\n        } else {\n          jobs.push(job);\n        }\n      } catch (error) {\n        console.error(`Error reading job file ${file}:`, error);\n      }\n    }\n\n    // Sort by updated time (most recent first)\n    jobs.sort((a, b) =>\n      new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()\n    );\n\n    return jobs;\n  }\n\n  /**\n   * List active jobs (pending or running)\n   */\n  listActiveJobs(): Job[] {\n    return this.listJobs(['pending', 'running']);\n  }\n\n  /**\n   * Cancel a job\n   */\n  cancelJob(jobId: string): Result<void> {\n    const job = this.getJob(jobId);\n\n    if (!job) {\n      return err(new Error(`Job ${jobId} not found`));\n    }\n\n    if (job.status === 'completed' || job.status === 'failed') {\n      return err(new Error(`Cannot cancel ${job.status} job`));\n    }\n\n    if (job.status === 'cancelled') {\n      return ok(undefined);\n    }\n\n    // Update job status\n    this.updateJob(jobId, {\n      status: 'cancelled',\n      message: 'Job cancelled by user',\n      details: { cancelledAt: new Date().toISOString() }\n    });\n\n    // Kill worker process if it exists\n    const pidFile = path.join(this.jobsDir, `${jobId}.pid`);\n    if (fs.existsSync(pidFile)) {\n      try {\n        const pid = parseInt(fs.readFileSync(pidFile, 'utf-8'), 10);\n        process.kill(pid, 'SIGTERM');\n      } catch {\n        // Process may have already exited, ignore\n      }\n      // Always delete the PID file, even if kill failed\n      try {\n        fs.unlinkSync(pidFile);\n      } catch {\n        // Ignore if file already deleted\n      }\n    }\n\n    return ok(undefined);\n  }\n\n  /**\n   * Clean up old completed/failed/cancelled jobs\n   */\n  cleanupOldJobs(olderThanHours: number = 24): number {\n    const jobs = this.listJobs();\n    const cutoffTime = Date.now() - (olderThanHours * 60 * 60 * 1000);\n    let cleaned = 0;\n\n    for (const job of jobs) {\n      if (\n        (job.status === 'completed' || job.status === 'failed' || job.status === 'cancelled') &&\n        new Date(job.updatedAt).getTime() < cutoffTime\n      ) {\n        const jobFile = path.join(this.jobsDir, `${job.id}.json`);\n        try {\n          fs.unlinkSync(jobFile);\n          cleaned++;\n        } catch (error) {\n          console.error(`Error deleting job file ${job.id}:`, error);\n        }\n      }\n    }\n\n    return cleaned;\n  }\n\n  /**\n   * Delete a specific job\n   */\n  deleteJob(jobId: string): boolean {\n    const jobFile = path.join(this.jobsDir, `${jobId}.json`);\n\n    if (!fs.existsSync(jobFile)) {\n      return false;\n    }\n\n    try {\n      fs.unlinkSync(jobFile);\n      return true;\n    } catch (error) {\n      console.error(`Error deleting job ${jobId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Write job to file\n   */\n  private writeJob(job: Job): void {\n    const jobFile = path.join(this.jobsDir, `${job.id}.json`);\n    fs.writeFileSync(jobFile, JSON.stringify(job, null, 2), 'utf-8');\n  }\n}\n","export type Result<T, E = Error> =\n  | { readonly success: true; readonly data: T }\n  | { readonly success: false; readonly error: E };\n\nexport function ok<T>(data: T): Result<T, never> {\n  return { success: true, data };\n}\n\nexport function err<E>(error: E): Result<never, E> {\n  return { success: false, error };\n}\n\nexport function isOk<T, E>(result: Result<T, E>): result is { success: true; data: T } {\n  return result.success;\n}\n\nexport function isErr<T, E>(result: Result<T, E>): result is { success: false; error: E } {\n  return !result.success;\n}\n\nexport function unwrap<T, E>(result: Result<T, E>): T {\n  if (isOk(result)) {\n    return result.data;\n  }\n  // Type guard ensures result has 'error' property\n  if (isErr(result)) {\n    if (result.error instanceof Error) {\n      throw result.error;\n    }\n    throw new Error(String(result.error));\n  }\n  // This should never happen due to discriminated union\n  throw new Error('Invalid result type');\n}\n\nexport function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {\n  if (isOk(result)) {\n    return result.data;\n  }\n  return defaultValue;\n}\n","import { readFile, writeFile, mkdir } from 'node:fs/promises';\nimport { dirname, resolve } from 'node:path';\nimport { homedir } from 'node:os';\nimport type { AppConfig } from '../types/config.js';\nimport { DEFAULT_CONFIG } from '../types/config.js';\nimport { ProjectRootService } from './project-root.service.js';\n\nexport class ConfigService {\n  private readonly configPath: string;\n  private readonly dataDir: string;\n  private config: AppConfig | null = null;\n\n  constructor(\n    configPath = `${homedir()}/.bluera/bluera-knowledge/config.json`,\n    dataDir?: string,\n    projectRoot?: string\n  ) {\n    this.configPath = configPath;\n\n    if (dataDir !== undefined && dataDir !== '') {\n      // Explicit dataDir provided, use it as-is\n      this.dataDir = dataDir;\n    } else {\n      // Resolve project root using hierarchical detection\n      const root = projectRoot ?? ProjectRootService.resolve();\n      // Expand relative default path against project root\n      this.dataDir = this.expandPath(DEFAULT_CONFIG.dataDir, root);\n    }\n  }\n\n  async load(): Promise<AppConfig> {\n    if (this.config !== null) {\n      return this.config;\n    }\n\n    try {\n      const content = await readFile(this.configPath, 'utf-8');\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      this.config = { ...DEFAULT_CONFIG, ...JSON.parse(content) } as AppConfig;\n    } catch {\n      this.config = { ...DEFAULT_CONFIG };\n    }\n\n    return this.config;\n  }\n\n  async save(config: AppConfig): Promise<void> {\n    await mkdir(dirname(this.configPath), { recursive: true });\n    await writeFile(this.configPath, JSON.stringify(config, null, 2));\n    this.config = config;\n  }\n\n  resolveDataDir(): string {\n    return this.dataDir;\n  }\n\n  private expandPath(path: string, baseDir: string): string {\n    // Expand ~ to home directory\n    if (path.startsWith('~')) {\n      return path.replace('~', homedir());\n    }\n    // Resolve relative paths against base directory (not process.cwd())\n    if (!path.startsWith('/')) {\n      return resolve(baseDir, path);\n    }\n    // Return absolute paths as-is\n    return path;\n  }\n}\n","export interface EmbeddingConfig {\n  readonly model: string;\n  readonly batchSize: number;\n  readonly dimensions: number;\n}\n\nexport interface IndexingConfig {\n  readonly concurrency: number;\n  readonly chunkSize: number;\n  readonly chunkOverlap: number;\n  readonly ignorePatterns: readonly string[];\n}\n\nexport interface SearchConfig {\n  readonly defaultMode: 'vector' | 'fts' | 'hybrid';\n  readonly defaultLimit: number;\n  readonly minScore: number;\n  readonly rrf: {\n    readonly k: number;\n    readonly vectorWeight: number;\n    readonly ftsWeight: number;\n  };\n}\n\nexport interface CrawlConfig {\n  readonly userAgent: string;\n  readonly timeout: number;\n  readonly maxConcurrency: number;\n}\n\nexport interface ServerConfig {\n  readonly port: number;\n  readonly host: string;\n}\n\nexport interface AppConfig {\n  readonly version: number;\n  readonly dataDir: string;\n  readonly embedding: EmbeddingConfig;\n  readonly indexing: IndexingConfig;\n  readonly search: SearchConfig;\n  readonly crawl: CrawlConfig;\n  readonly server: ServerConfig;\n}\n\nexport const DEFAULT_CONFIG: AppConfig = {\n  version: 1,\n  dataDir: '.bluera/bluera-knowledge/data',\n  embedding: {\n    model: 'Xenova/all-MiniLM-L6-v2',\n    batchSize: 32,\n    dimensions: 384,\n  },\n  indexing: {\n    concurrency: 4,\n    chunkSize: 1000,\n    chunkOverlap: 150,\n    ignorePatterns: ['node_modules/**', '.git/**', '*.min.js', '*.map'],\n  },\n  search: {\n    defaultMode: 'hybrid',\n    defaultLimit: 10,\n    minScore: 0.5,\n    rrf: {\n      k: 40,\n      vectorWeight: 0.7,\n      ftsWeight: 0.3,\n    },\n  },\n  crawl: {\n    userAgent: 'BlueraKnowledge/1.0',\n    timeout: 30000,\n    maxConcurrency: 3,\n  },\n  server: {\n    port: 3847,\n    host: '127.0.0.1',\n  },\n};\n","import { existsSync, statSync, realpathSync } from 'node:fs';\nimport { dirname, join, normalize, sep } from 'node:path';\n\nexport interface ProjectRootOptions {\n  readonly projectRoot?: string | undefined;\n}\n\n/**\n * Service for resolving the project root directory using a hierarchical detection strategy.\n *\n * Resolution hierarchy:\n * 1. Explicit projectRoot option (highest priority)\n * 2. PROJECT_ROOT environment variable (set by plugin commands)\n * 3. PWD environment variable (set by MCP server and shells)\n * 4. Git root detection (walk up to find .git directory)\n * 5. process.cwd() (fallback)\n */\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class ProjectRootService {\n  /**\n   * Resolve project root directory using hierarchical detection.\n   */\n  static resolve(options?: ProjectRootOptions): string {\n    // 1. Check explicit option first\n    if (options?.projectRoot !== undefined && options.projectRoot !== '') {\n      return this.normalize(options.projectRoot);\n    }\n\n    // 2. Check PROJECT_ROOT environment variable (plugin commands)\n    const projectRootEnv = process.env['PROJECT_ROOT'];\n    if (projectRootEnv !== undefined && projectRootEnv !== '') {\n      return this.normalize(projectRootEnv);\n    }\n\n    // 3. Check PWD environment variable (MCP server, shells)\n    const pwdEnv = process.env['PWD'];\n    if (pwdEnv !== undefined && pwdEnv !== '') {\n      return this.normalize(pwdEnv);\n    }\n\n    // 4. Try git root detection\n    const gitRoot = this.findGitRoot(process.cwd());\n    if (gitRoot !== null) {\n      return gitRoot;\n    }\n\n    // 5. Fallback to process.cwd()\n    return process.cwd();\n  }\n\n  /**\n   * Find git repository root by walking up the directory tree looking for .git\n   */\n  static findGitRoot(startPath: string): string | null {\n    let currentPath = normalize(startPath);\n    const root = normalize(sep); // Root filesystem (/ on Unix, C:\\ on Windows)\n\n    // Walk up directory tree\n    while (currentPath !== root) {\n      const gitPath = join(currentPath, '.git');\n\n      if (existsSync(gitPath)) {\n        try {\n          const stats = statSync(gitPath);\n          // .git can be a directory (normal repo) or file (submodule/worktree)\n          if (stats.isDirectory() || stats.isFile()) {\n            return currentPath;\n          }\n        } catch {\n          // Ignore stat errors, continue searching\n        }\n      }\n\n      // Move up one directory\n      const parentPath = dirname(currentPath);\n      if (parentPath === currentPath) {\n        // Reached root without finding .git\n        break;\n      }\n      currentPath = parentPath;\n    }\n\n    return null;\n  }\n\n  /**\n   * Normalize path by resolving symlinks and normalizing separators\n   */\n  static normalize(path: string): string {\n    try {\n      // Resolve symlinks to real path\n      const realPath = realpathSync(path);\n      // Normalize separators\n      return normalize(realPath);\n    } catch {\n      // If realpath fails (path doesn't exist), just normalize\n      return normalize(path);\n    }\n  }\n\n  /**\n   * Validate that a path exists and is a directory\n   */\n  static validate(path: string): boolean {\n    try {\n      const stats = statSync(path);\n      return stats.isDirectory();\n    } catch {\n      return false;\n    }\n  }\n}\n","import { readFile, writeFile, mkdir } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport { randomUUID } from 'node:crypto';\nimport type { Store, FileStore, RepoStore, WebStore, StoreType } from '../types/store.js';\nimport type { StoreId } from '../types/brands.js';\nimport { createStoreId } from '../types/brands.js';\nimport type { Result } from '../types/result.js';\nimport { ok, err } from '../types/result.js';\nimport { cloneRepository } from '../plugin/git-clone.js';\n\nexport interface CreateStoreInput {\n  name: string;\n  type: StoreType;\n  path?: string | undefined;\n  url?: string | undefined;\n  description?: string | undefined;\n  tags?: string[] | undefined;\n  branch?: string | undefined;\n  depth?: number | undefined;\n}\n\ninterface StoreRegistry {\n  stores: Store[];\n}\n\nexport class StoreService {\n  private readonly dataDir: string;\n  private registry: StoreRegistry = { stores: [] };\n\n  constructor(dataDir: string) {\n    this.dataDir = dataDir;\n  }\n\n  async initialize(): Promise<void> {\n    await mkdir(this.dataDir, { recursive: true });\n    await this.loadRegistry();\n  }\n\n  async create(input: CreateStoreInput): Promise<Result<Store>> {\n    const existing = await this.getByName(input.name);\n    if (existing !== undefined) {\n      return err(new Error(`Store with name \"${input.name}\" already exists`));\n    }\n\n    const id = createStoreId(randomUUID());\n    const now = new Date();\n\n    let store: Store;\n\n    switch (input.type) {\n      case 'file':\n        if (input.path === undefined) {\n          return err(new Error('Path is required for file stores'));\n        }\n        store = {\n          type: 'file',\n          id,\n          name: input.name,\n          path: input.path,\n          description: input.description,\n          tags: input.tags,\n          status: 'ready',\n          createdAt: now,\n          updatedAt: now,\n        } satisfies FileStore;\n        break;\n\n      case 'repo': {\n        let repoPath = input.path;\n\n        // If URL provided, clone it\n        if (input.url !== undefined) {\n          const cloneDir = join(this.dataDir, 'repos', id);\n          const result = await cloneRepository({\n            url: input.url,\n            targetDir: cloneDir,\n            ...(input.branch !== undefined ? { branch: input.branch } : {}),\n            depth: input.depth ?? 1\n          });\n\n          if (!result.success) {\n            return err(result.error);\n          }\n          repoPath = result.data;\n        }\n\n        if (repoPath === undefined) {\n          return err(new Error('Path or URL required for repo stores'));\n        }\n\n        store = {\n          type: 'repo',\n          id,\n          name: input.name,\n          path: repoPath,\n          url: input.url,\n          branch: input.branch,\n          description: input.description,\n          tags: input.tags,\n          status: 'ready',\n          createdAt: now,\n          updatedAt: now,\n        } satisfies RepoStore;\n        break;\n      }\n\n      case 'web':\n        if (input.url === undefined) {\n          return err(new Error('URL is required for web stores'));\n        }\n        store = {\n          type: 'web',\n          id,\n          name: input.name,\n          url: input.url,\n          depth: input.depth ?? 1,\n          description: input.description,\n          tags: input.tags,\n          status: 'ready',\n          createdAt: now,\n          updatedAt: now,\n        } satisfies WebStore;\n        break;\n    }\n\n    this.registry.stores.push(store);\n    await this.saveRegistry();\n\n    return ok(store);\n  }\n\n  async list(type?: StoreType): Promise<Store[]> {\n    if (type !== undefined) {\n      return Promise.resolve(this.registry.stores.filter((s) => s.type === type));\n    }\n    return Promise.resolve([...this.registry.stores]);\n  }\n\n  async get(id: StoreId): Promise<Store | undefined> {\n    return Promise.resolve(this.registry.stores.find((s) => s.id === id));\n  }\n\n  async getByName(name: string): Promise<Store | undefined> {\n    return Promise.resolve(this.registry.stores.find((s) => s.name === name));\n  }\n\n  async getByIdOrName(idOrName: string): Promise<Store | undefined> {\n    return Promise.resolve(this.registry.stores.find((s) => s.id === idOrName || s.name === idOrName));\n  }\n\n  async update(id: StoreId, updates: Partial<Pick<Store, 'name' | 'description' | 'tags'>>): Promise<Result<Store>> {\n    const index = this.registry.stores.findIndex((s) => s.id === id);\n    if (index === -1) {\n      return err(new Error(`Store not found: ${id}`));\n    }\n\n    const store = this.registry.stores[index];\n    if (store === undefined) {\n      return err(new Error(`Store not found: ${id}`));\n    }\n\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    const updated = {\n      ...store,\n      ...updates,\n      updatedAt: new Date(),\n    } as Store;\n\n    this.registry.stores[index] = updated;\n    await this.saveRegistry();\n\n    return ok(updated);\n  }\n\n  async delete(id: StoreId): Promise<Result<void>> {\n    const index = this.registry.stores.findIndex((s) => s.id === id);\n    if (index === -1) {\n      return err(new Error(`Store not found: ${id}`));\n    }\n\n    this.registry.stores.splice(index, 1);\n    await this.saveRegistry();\n\n    return ok(undefined);\n  }\n\n  private async loadRegistry(): Promise<void> {\n    const registryPath = join(this.dataDir, 'stores.json');\n    try {\n      const content = await readFile(registryPath, 'utf-8');\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      const data = JSON.parse(content) as { stores: Store[] };\n      this.registry = {\n        stores: data.stores.map((s) => ({\n          ...s,\n          id: createStoreId(s.id),\n          createdAt: new Date(s.createdAt),\n          updatedAt: new Date(s.updatedAt),\n        })),\n      };\n    } catch {\n      this.registry = { stores: [] };\n    }\n  }\n\n  private async saveRegistry(): Promise<void> {\n    const registryPath = join(this.dataDir, 'stores.json');\n    await writeFile(registryPath, JSON.stringify(this.registry, null, 2));\n  }\n}\n","// Branded type symbols\ndeclare const StoreIdBrand: unique symbol;\ndeclare const DocumentIdBrand: unique symbol;\n\n// Branded types\nexport type StoreId = string & { readonly [StoreIdBrand]: typeof StoreIdBrand };\nexport type DocumentId = string & { readonly [DocumentIdBrand]: typeof DocumentIdBrand };\n\n// Valid ID pattern: alphanumeric, hyphens, underscores\nconst ID_PATTERN = /^[a-zA-Z0-9_-]+$/;\n\nexport function isStoreId(value: string): value is StoreId {\n  return value.length > 0 && ID_PATTERN.test(value);\n}\n\nexport function isDocumentId(value: string): value is DocumentId {\n  return value.length > 0 && ID_PATTERN.test(value);\n}\n\nexport function createStoreId(value: string): StoreId {\n  if (!isStoreId(value)) {\n    throw new Error(`Invalid store ID: ${value}`);\n  }\n  return value;\n}\n\nexport function createDocumentId(value: string): DocumentId {\n  if (!isDocumentId(value)) {\n    throw new Error(`Invalid document ID: ${value}`);\n  }\n  return value;\n}\n","import { spawn } from 'node:child_process';\nimport { mkdir } from 'node:fs/promises';\nimport type { Result } from '../types/result.js';\nimport { ok, err } from '../types/result.js';\n\nexport interface CloneOptions {\n  url: string;\n  targetDir: string;\n  branch?: string;\n  depth?: number;\n}\n\nexport async function cloneRepository(\n  options: CloneOptions\n): Promise<Result<string>> {\n  const { url, targetDir, branch, depth = 1 } = options;\n\n  await mkdir(targetDir, { recursive: true });\n\n  const args = ['clone', '--depth', String(depth)];\n  if (branch !== undefined) {\n    args.push('--branch', branch);\n  }\n  args.push(url, targetDir);\n\n  return new Promise((resolve) => {\n    const git = spawn('git', args, { stdio: ['ignore', 'pipe', 'pipe'] });\n\n    let stderr = '';\n    git.stderr.on('data', (data: Buffer) => {\n      stderr += data.toString();\n    });\n\n    git.on('close', (code: number | null) => {\n      if (code === 0) {\n        resolve(ok(targetDir));\n      } else {\n        resolve(err(new Error(`Git clone failed: ${stderr}`)));\n      }\n    });\n  });\n}\n\nexport function isGitUrl(source: string): boolean {\n  return source.startsWith('http://') ||\n         source.startsWith('https://') ||\n         source.startsWith('git@');\n}\n\nexport function extractRepoName(url: string): string {\n  const match = /\\/([^/]+?)(\\.git)?$/.exec(url);\n  const name = match?.[1];\n  if (name === undefined) {\n    return 'repository';\n  }\n  return name;\n}\n","export interface CodeUnit {\n  type: 'function' | 'class' | 'interface' | 'type' | 'const' | 'documentation' | 'example';\n  name: string;\n  signature: string;\n  fullContent: string;\n  startLine: number;\n  endLine: number;\n  language: string;\n}\n\nexport class CodeUnitService {\n  extractCodeUnit(code: string, symbolName: string, language: string): CodeUnit | undefined {\n    const lines = code.split('\\n');\n\n    // Find the line containing the symbol\n    let startLine = -1;\n    let type: CodeUnit['type'] = 'function';\n\n    // NOTE: Now supports function declarations, class declarations, and arrow functions (const/let/var).\n    // Does not handle interfaces or type definitions yet.\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i] ?? '';\n\n      if (line.includes(`function ${symbolName}`)) {\n        startLine = i + 1; // 1-indexed\n        type = 'function';\n        break;\n      }\n\n      if (line.includes(`class ${symbolName}`)) {\n        startLine = i + 1;\n        type = 'class';\n        break;\n      }\n\n      // Check for arrow functions: const/let/var name = ...\n      if (line.match(new RegExp(`(?:const|let|var)\\\\s+${symbolName}\\\\s*=`))) {\n        startLine = i + 1;\n        type = 'const';\n        break;\n      }\n    }\n\n    if (startLine === -1) return undefined;\n\n    // Find end line (naive: next empty line or next top-level declaration)\n    let endLine = startLine;\n    let braceCount = 0;\n    let foundFirstBrace = false;\n\n    // NOTE: This brace counting does not handle braces inside strings or comments.\n    // It may incorrectly determine boundaries if code contains braces in string literals.\n    for (let i = startLine - 1; i < lines.length; i++) {\n      const line = lines[i] ?? '';\n\n      for (const char of line) {\n        if (char === '{') {\n          braceCount++;\n          foundFirstBrace = true;\n        }\n        if (char === '}') braceCount--;\n      }\n\n      if (foundFirstBrace && braceCount === 0) {\n        endLine = i + 1;\n        break;\n      }\n    }\n\n    const fullContent = lines.slice(startLine - 1, endLine).join('\\n');\n\n    // Extract signature (first line, cleaned)\n    const firstLine = lines[startLine - 1] ?? '';\n    const signature = this.extractSignature(firstLine, symbolName, type);\n\n    return {\n      type,\n      name: symbolName,\n      signature,\n      fullContent,\n      startLine,\n      endLine,\n      language\n    };\n  }\n\n  private extractSignature(line: string, name: string, type: string): string {\n    // Remove 'export', 'async', trim whitespace\n    const sig = line.replace(/^\\s*export\\s+/, '').replace(/^\\s*async\\s+/, '').trim();\n\n    if (type === 'function') {\n      // Extract just \"functionName(params): returnType\"\n      // TODO: This regex is limited and may not handle complex return types, generics, or multiline signatures\n      const match = sig.match(/function\\s+(\\w+\\([^)]*\\):\\s*\\w+)/);\n      if (match?.[1] !== undefined && match[1].length > 0) return match[1];\n    }\n\n    if (type === 'class') {\n      return `class ${name}`;\n    }\n\n    if (type === 'const') {\n      // For arrow functions, extract the variable declaration part\n      // Example: const myFunc = (param: string): void => ...\n      // Returns: const myFunc = (param: string): void\n      const arrowMatch = sig.match(new RegExp(`((?:const|let|var)\\\\s+${name}\\\\s*=\\\\s*(?:async\\\\s+)?\\\\([^)]*\\\\)(?::\\\\s*[^=]+)?)`));\n      if (arrowMatch?.[1] != null && arrowMatch[1] !== '') return arrowMatch[1].trim();\n\n      // Fallback for simple arrow functions without params\n      return `const ${name}`;\n    }\n\n    return sig;\n  }\n}\n","import type { LanceStore } from '../db/lance.js';\nimport type { EmbeddingEngine } from '../db/embeddings.js';\nimport type { SearchQuery, SearchResponse, SearchResult, DetailLevel } from '../types/search.js';\nimport type { StoreId } from '../types/brands.js';\nimport { CodeUnitService } from './code-unit.service.js';\nimport type { CodeUnit } from '../types/search.js';\nimport type { CodeGraphService } from './code-graph.service.js';\nimport type { CodeGraph } from '../analysis/code-graph.js';\n\n/**\n * Query intent classification for context-aware ranking.\n * Phase 1: Different intents prioritize different content types.\n */\nexport type QueryIntent = 'how-to' | 'implementation' | 'conceptual' | 'comparison' | 'debugging';\n\n/**\n * Intent-based file type multipliers - CONSERVATIVE version.\n * Applied on top of base file-type boosts.\n * Lessons learned: Too-aggressive penalties hurt when corpus lacks ideal content.\n * These values provide gentle guidance rather than dramatic reranking.\n */\nconst INTENT_FILE_BOOSTS: Record<QueryIntent, Record<string, number>> = {\n  'how-to': {\n    'documentation-primary': 1.3,   // Strong boost for docs\n    'documentation': 1.2,\n    'example': 1.5,                  // Examples are ideal for \"how to\"\n    'source': 0.85,                 // Moderate penalty - source might still have good content\n    'source-internal': 0.7,         // Stronger penalty - internal code less useful\n    'test': 0.8,\n    'config': 0.7,\n    'other': 0.9,\n  },\n  'implementation': {\n    'documentation-primary': 0.95,\n    'documentation': 1.0,\n    'example': 1.0,\n    'source': 1.1,                  // Slight boost for source code\n    'source-internal': 1.05,        // Internal code can be relevant\n    'test': 1.0,\n    'config': 0.95,\n    'other': 1.0,\n  },\n  'conceptual': {\n    'documentation-primary': 1.1,\n    'documentation': 1.05,\n    'example': 1.0,\n    'source': 0.95,\n    'source-internal': 0.9,\n    'test': 0.9,\n    'config': 0.85,\n    'other': 0.95,\n  },\n  'comparison': {\n    'documentation-primary': 1.15,\n    'documentation': 1.1,\n    'example': 1.05,\n    'source': 0.9,\n    'source-internal': 0.85,\n    'test': 0.9,\n    'config': 0.85,\n    'other': 0.95,\n  },\n  'debugging': {\n    'documentation-primary': 1.0,\n    'documentation': 1.0,\n    'example': 1.05,\n    'source': 1.0,                  // Source code helps with debugging\n    'source-internal': 0.95,\n    'test': 1.05,                   // Tests can show expected behavior\n    'config': 0.9,\n    'other': 1.0,\n  },\n};\n\n// Known frameworks/technologies for context-aware boosting\nconst FRAMEWORK_PATTERNS: Array<{ pattern: RegExp; terms: string[] }> = [\n  { pattern: /\\bexpress\\b/i, terms: ['express', 'expressjs', 'express.js'] },\n  { pattern: /\\bhono\\b/i, terms: ['hono'] },\n  { pattern: /\\bzod\\b/i, terms: ['zod'] },\n  { pattern: /\\breact\\b/i, terms: ['react', 'reactjs', 'react.js'] },\n  { pattern: /\\bvue\\b/i, terms: ['vue', 'vuejs', 'vue.js', 'vue3'] },\n  { pattern: /\\bnode\\b/i, terms: ['node', 'nodejs', 'node.js'] },\n  { pattern: /\\btypescript\\b/i, terms: ['typescript', 'ts'] },\n  { pattern: /\\bjwt\\b/i, terms: ['jwt', 'jsonwebtoken', 'json-web-token'] },\n];\n\n/**\n * Classify the intent of a search query.\n * This helps adjust ranking based on what kind of answer the user wants.\n */\nfunction classifyQueryIntent(query: string): QueryIntent {\n  const q = query.toLowerCase();\n\n  // How-to patterns: user wants to learn how to use/do something\n  const howToPatterns = [\n    /how (do|can|should|would) (i|you|we)/i,\n    /how to\\b/i,\n    /what('s| is) the (best |right |correct )?(way|approach) to/i,\n    /i (need|want|have) to/i,\n    /show me how/i,\n    /\\bwhat's the syntax\\b/i,\n    /\\bhow do i (use|create|make|set up|configure|implement|add|get)\\b/i,\n    /\\bi'm (trying|building|creating|making)\\b/i,\n  ];\n\n  // Implementation patterns: user wants to understand internals\n  const implementationPatterns = [\n    /how (does|is) .* (implemented|work internally)/i,\n    /\\binternal(ly)?\\b/i,\n    /\\bsource code\\b/i,\n    /\\bunder the hood\\b/i,\n    /\\bimplementation (of|details?)\\b/i,\n  ];\n\n  // Comparison patterns: user is deciding between options\n  const comparisonPatterns = [\n    /\\b(vs\\.?|versus)\\b/i,\n    /\\bdifference(s)? between\\b/i,\n    /\\bcompare\\b/i,\n    /\\bshould (i|we) use .* or\\b/i,\n    /\\bwhat's the difference\\b/i,\n    /\\bwhich (one|is better)\\b/i,\n    /\\bwhen (should|to) use\\b/i,\n  ];\n\n  // Debugging patterns: user is troubleshooting a problem\n  const debuggingPatterns = [\n    /\\b(error|bug|issue|problem|crash|fail|broken|wrong)\\b/i,\n    /\\bdoesn't (work|compile|run)\\b/i,\n    /\\bisn't (working|updating|rendering)\\b/i,\n    /\\bwhy (is|does|doesn't|isn't)\\b/i,\n    /\\bwhat('s| is) (wrong|happening|going on)\\b/i,\n    /\\bwhat am i doing wrong\\b/i,\n    /\\bnot (working|updating|showing)\\b/i,\n    /\\bhow do i (fix|debug|solve|resolve)\\b/i,\n  ];\n\n  // Conceptual patterns: user wants to understand a concept\n  const conceptualPatterns = [\n    /\\bwhat (is|are)\\b/i,\n    /\\bexplain\\b/i,\n    /\\bwhat does .* (mean|do)\\b/i,\n    /\\bhow does .* work\\b/i,\n    /\\bwhat('s| is) the (purpose|point|idea)\\b/i,\n  ];\n\n  // Check patterns in order of specificity\n  if (implementationPatterns.some(p => p.test(q))) {\n    return 'implementation';\n  }\n\n  if (debuggingPatterns.some(p => p.test(q))) {\n    return 'debugging';\n  }\n\n  if (comparisonPatterns.some(p => p.test(q))) {\n    return 'comparison';\n  }\n\n  if (howToPatterns.some(p => p.test(q))) {\n    return 'how-to';\n  }\n\n  if (conceptualPatterns.some(p => p.test(q))) {\n    return 'conceptual';\n  }\n\n  // Default to how-to as most queries are seeking practical usage\n  return 'how-to';\n}\n\ninterface RRFConfig {\n  k: number;\n  vectorWeight: number;\n  ftsWeight: number;\n}\n\nexport class SearchService {\n  private readonly lanceStore: LanceStore;\n  private readonly embeddingEngine: EmbeddingEngine;\n  private readonly rrfConfig: RRFConfig;\n  private readonly codeUnitService: CodeUnitService;\n  private readonly codeGraphService: CodeGraphService | undefined;\n  private readonly graphCache: Map<string, CodeGraph | null>;\n\n  constructor(\n    lanceStore: LanceStore,\n    embeddingEngine: EmbeddingEngine,\n    // Lower k value (20 vs 60) produces more differentiated scores for top results\n    rrfConfig: RRFConfig = { k: 20, vectorWeight: 0.6, ftsWeight: 0.4 },\n    codeGraphService?: CodeGraphService\n  ) {\n    this.lanceStore = lanceStore;\n    this.embeddingEngine = embeddingEngine;\n    this.rrfConfig = rrfConfig;\n    this.codeUnitService = new CodeUnitService();\n    this.codeGraphService = codeGraphService;\n    this.graphCache = new Map();\n  }\n\n  /**\n   * Load code graph for a store, with caching.\n   * Returns null if no graph is available.\n   */\n  private async loadGraphForStore(storeId: StoreId): Promise<CodeGraph | null> {\n    if (!this.codeGraphService) return null;\n\n    const cached = this.graphCache.get(storeId);\n    if (cached !== undefined) return cached;\n\n    const graph = await this.codeGraphService.loadGraph(storeId);\n    const result = graph ?? null;\n    this.graphCache.set(storeId, result);\n    return result;\n  }\n\n  async search(query: SearchQuery): Promise<SearchResponse> {\n    const startTime = Date.now();\n    const mode = query.mode ?? 'hybrid';\n    const limit = query.limit ?? 10;\n    const stores = query.stores ?? [];\n    const detail = query.detail ?? 'minimal';\n\n    let allResults: SearchResult[] = [];\n\n    // Fetch more results than needed to allow for deduplication\n    const fetchLimit = limit * 3;\n\n    if (mode === 'vector') {\n      allResults = await this.vectorSearch(query.query, stores, fetchLimit, query.threshold);\n    } else if (mode === 'fts') {\n      allResults = await this.ftsSearch(query.query, stores, fetchLimit);\n    } else {\n      // Hybrid: combine vector and FTS with RRF\n      allResults = await this.hybridSearch(query.query, stores, fetchLimit, query.threshold);\n    }\n\n    // Deduplicate by source file - keep best chunk per source (considers query relevance)\n    const dedupedResults = this.deduplicateBySource(allResults, query.query);\n    const resultsToEnhance = dedupedResults.slice(0, limit);\n\n    // Load code graphs for stores in results (for contextual/full detail levels)\n    const graphs = new Map<string, CodeGraph | null>();\n    if (detail === 'contextual' || detail === 'full') {\n      const storeIds = new Set(resultsToEnhance.map(r => r.metadata.storeId));\n      for (const storeId of storeIds) {\n        graphs.set(storeId, await this.loadGraphForStore(storeId));\n      }\n    }\n\n    // Enhance results with progressive context\n    const enhancedResults = resultsToEnhance.map(r => {\n      const graph = graphs.get(r.metadata.storeId) ?? null;\n      return this.addProgressiveContext(r, query.query, detail, graph);\n    });\n\n    return {\n      query: query.query,\n      mode,\n      stores,\n      results: enhancedResults,\n      totalResults: enhancedResults.length,\n      timeMs: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Deduplicate results by source file path.\n   * Keeps the best chunk for each unique source, considering both score and query relevance.\n   */\n  private deduplicateBySource(results: SearchResult[], query: string): SearchResult[] {\n    const bySource = new Map<string, SearchResult>();\n    const queryTerms = query.toLowerCase().split(/\\s+/).filter(t => t.length > 2);\n\n    for (const result of results) {\n      // Use file path as the source key, fallback to document ID\n      const sourceKey = result.metadata.path ?? result.metadata.url ?? result.id;\n\n      const existing = bySource.get(sourceKey);\n      if (!existing) {\n        bySource.set(sourceKey, result);\n      } else {\n        // Compare: prefer chunk with more query terms in content\n        const existingTermCount = this.countQueryTerms(existing.content, queryTerms);\n        const newTermCount = this.countQueryTerms(result.content, queryTerms);\n\n        // Prefer chunk with more query terms, or higher score if same\n        if (newTermCount > existingTermCount ||\n            (newTermCount === existingTermCount && result.score > existing.score)) {\n          bySource.set(sourceKey, result);\n        }\n      }\n    }\n\n    // Return results sorted by score\n    return Array.from(bySource.values()).sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Count how many query terms appear in the content.\n   */\n  private countQueryTerms(content: string, queryTerms: string[]): number {\n    const lowerContent = content.toLowerCase();\n    return queryTerms.filter(term => lowerContent.includes(term)).length;\n  }\n\n  private async vectorSearch(\n    query: string,\n    stores: readonly StoreId[],\n    limit: number,\n    threshold?: number\n  ): Promise<SearchResult[]> {\n    const queryVector = await this.embeddingEngine.embed(query);\n    const results: SearchResult[] = [];\n\n    for (const storeId of stores) {\n      const hits = await this.lanceStore.search(storeId, queryVector, limit, threshold);\n      results.push(...hits.map(r => ({\n        id: r.id,\n        score: r.score,\n        content: r.content,\n        metadata: r.metadata,\n      })));\n    }\n\n    return results.sort((a, b) => b.score - a.score).slice(0, limit);\n  }\n\n  private async ftsSearch(\n    query: string,\n    stores: readonly StoreId[],\n    limit: number\n  ): Promise<SearchResult[]> {\n    const results: SearchResult[] = [];\n\n    for (const storeId of stores) {\n      const hits = await this.lanceStore.fullTextSearch(storeId, query, limit);\n      results.push(...hits.map(r => ({\n        id: r.id,\n        score: r.score,\n        content: r.content,\n        metadata: r.metadata,\n      })));\n    }\n\n    return results.sort((a, b) => b.score - a.score).slice(0, limit);\n  }\n\n  private async hybridSearch(\n    query: string,\n    stores: readonly StoreId[],\n    limit: number,\n    threshold?: number\n  ): Promise<SearchResult[]> {\n    // Phase 1: Classify query intent for context-aware ranking\n    const intent = classifyQueryIntent(query);\n\n    // Get both result sets\n    const [vectorResults, ftsResults] = await Promise.all([\n      this.vectorSearch(query, stores, limit * 2, threshold),\n      this.ftsSearch(query, stores, limit * 2),\n    ]);\n\n    // Build rank maps\n    const vectorRanks = new Map<string, number>();\n    const ftsRanks = new Map<string, number>();\n    const allDocs = new Map<string, SearchResult>();\n\n    vectorResults.forEach((r, i) => {\n      vectorRanks.set(r.id, i + 1);\n      allDocs.set(r.id, r);\n    });\n\n    ftsResults.forEach((r, i) => {\n      ftsRanks.set(r.id, i + 1);\n      if (!allDocs.has(r.id)) {\n        allDocs.set(r.id, r);\n      }\n    });\n\n    // Calculate RRF scores with file-type boosting and preserve ranking metadata\n    const rrfScores: Array<{\n      id: string;\n      score: number;\n      result: SearchResult;\n      metadata: {\n        vectorRank?: number;\n        ftsRank?: number;\n        vectorRRF: number;\n        ftsRRF: number;\n        fileTypeBoost: number;\n        frameworkBoost: number;\n      };\n    }> = [];\n    const { k, vectorWeight, ftsWeight } = this.rrfConfig;\n\n    for (const [id, result] of allDocs) {\n      const vectorRank = vectorRanks.get(id) ?? Infinity;\n      const ftsRank = ftsRanks.get(id) ?? Infinity;\n\n      const vectorRRF = vectorRank !== Infinity ? vectorWeight / (k + vectorRank) : 0;\n      const ftsRRF = ftsRank !== Infinity ? ftsWeight / (k + ftsRank) : 0;\n\n      // Apply file-type boost (base + intent-adjusted)\n      const fileTypeBoost = this.getFileTypeBoost(\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        result.metadata['fileType'] as string | undefined,\n        intent\n      );\n\n      // Apply framework context boost\n      const frameworkBoost = this.getFrameworkContextBoost(query, result);\n\n      const metadata: {\n        vectorRank?: number;\n        ftsRank?: number;\n        vectorRRF: number;\n        ftsRRF: number;\n        fileTypeBoost: number;\n        frameworkBoost: number;\n      } = {\n        vectorRRF,\n        ftsRRF,\n        fileTypeBoost,\n        frameworkBoost,\n      };\n\n      if (vectorRank !== Infinity) {\n        metadata.vectorRank = vectorRank;\n      }\n      if (ftsRank !== Infinity) {\n        metadata.ftsRank = ftsRank;\n      }\n\n      rrfScores.push({\n        id,\n        score: (vectorRRF + ftsRRF) * fileTypeBoost * frameworkBoost,\n        result,\n        metadata,\n      });\n    }\n\n    // Sort by RRF score\n    const sorted = rrfScores.sort((a, b) => b.score - a.score).slice(0, limit);\n\n    // Normalize scores to 0-1 range for better interpretability\n    if (sorted.length > 0) {\n      const first = sorted[0];\n      const last = sorted[sorted.length - 1];\n      if (first === undefined || last === undefined) {\n        return sorted.map(r => ({\n          ...r.result,\n          score: r.score,\n          rankingMetadata: r.metadata,\n        }));\n      }\n      const maxScore = first.score;\n      const minScore = last.score;\n      const range = maxScore - minScore;\n\n      if (range > 0) {\n        return sorted.map(r => ({\n          ...r.result,\n          score: (r.score - minScore) / range,\n          rankingMetadata: r.metadata,\n        }));\n      }\n    }\n\n    return sorted.map(r => ({\n      ...r.result,\n      score: r.score,\n      rankingMetadata: r.metadata,\n    }));\n  }\n\n  async searchAllStores(\n    query: SearchQuery,\n    storeIds: StoreId[]\n  ): Promise<SearchResponse> {\n    return this.search({\n      ...query,\n      stores: storeIds,\n    });\n  }\n\n  /**\n   * Get a score multiplier based on file type and query intent.\n   * Documentation files get a strong boost to surface them higher.\n   * Phase 4: Strengthened boosts for better documentation ranking.\n   * Phase 1: Intent-based adjustments for context-aware ranking.\n   */\n  private getFileTypeBoost(fileType: string | undefined, intent: QueryIntent): number {\n    // Base file-type boosts\n    let baseBoost: number;\n    switch (fileType) {\n      case 'documentation-primary':\n        baseBoost = 1.8;  // README, guides get very strong boost\n        break;\n      case 'documentation':\n        baseBoost = 1.5;  // docs/, tutorials/ get strong boost\n        break;\n      case 'example':\n        baseBoost = 1.4;  // examples/, demos/ are highly valuable\n        break;\n      case 'source':\n        baseBoost = 1.0;  // Source code baseline\n        break;\n      case 'source-internal':\n        baseBoost = 0.75;  // Internal implementation files (not too harsh)\n        break;\n      case 'test':\n        baseBoost = 0.7;  // Tests significantly lower\n        break;\n      case 'config':\n        baseBoost = 0.5;  // Config files rarely answer questions\n        break;\n      default:\n        baseBoost = 1.0;\n    }\n\n    // Apply intent-based multiplier\n    const intentBoosts = INTENT_FILE_BOOSTS[intent];\n    const intentMultiplier = intentBoosts[fileType ?? 'other'] ?? 1.0;\n\n    return baseBoost * intentMultiplier;\n  }\n\n  /**\n   * Get a score multiplier based on framework context.\n   * If query mentions a framework, boost results from that framework's files.\n   */\n  private getFrameworkContextBoost(query: string, result: SearchResult): number {\n    const path = result.metadata.path ?? result.metadata.url ?? '';\n    const content = result.content.toLowerCase();\n    const pathLower = path.toLowerCase();\n\n    // Check if query mentions any known frameworks\n    for (const { pattern, terms } of FRAMEWORK_PATTERNS) {\n      if (pattern.test(query)) {\n        // Query mentions this framework - check if result is from that framework\n        const resultMatchesFramework = terms.some(term =>\n          pathLower.includes(term) || content.includes(term)\n        );\n\n        if (resultMatchesFramework) {\n          return 1.5; // Strong boost for matching framework\n        } else {\n          return 0.8; // Moderate penalty for non-matching when framework is specified\n        }\n      }\n    }\n\n    return 1.0; // No framework context in query\n  }\n\n  private addProgressiveContext(\n    result: SearchResult,\n    query: string,\n    detail: DetailLevel,\n    graph: CodeGraph | null\n  ): SearchResult {\n    const enhanced = { ...result };\n\n    // Layer 1: Always add summary\n    const path = result.metadata.path ?? result.metadata.url ?? 'unknown';\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    const fileType = result.metadata['fileType'] as string | undefined;\n\n    // Try to extract code unit\n    const codeUnit = this.extractCodeUnitFromResult(result);\n    const symbolName = codeUnit?.name ?? this.extractSymbolName(result.content);\n\n    enhanced.summary = {\n      type: this.inferType(fileType, codeUnit),\n      name: symbolName,\n      signature: codeUnit?.signature ?? '',\n      purpose: this.generatePurpose(result.content, query),\n      location: `${path}${codeUnit ? ':' + String(codeUnit.startLine) : ''}`,\n      relevanceReason: this.generateRelevanceReason(result, query)\n    };\n\n    // Layer 2: Add context if requested\n    if (detail === 'contextual' || detail === 'full') {\n      // Get usage stats from code graph if available\n      const usage = this.getUsageFromGraph(graph, path, symbolName);\n\n      enhanced.context = {\n        interfaces: this.extractInterfaces(result.content),\n        keyImports: this.extractImports(result.content),\n        relatedConcepts: this.extractConcepts(result.content, query),\n        usage\n      };\n    }\n\n    // Layer 3: Add full context if requested\n    if (detail === 'full') {\n      // Get related code from graph if available\n      const relatedCode = this.getRelatedCodeFromGraph(graph, path, symbolName);\n\n      enhanced.full = {\n        completeCode: codeUnit?.fullContent ?? result.content,\n        relatedCode,\n        documentation: this.extractDocumentation(result.content),\n        tests: undefined\n      };\n    }\n\n    return enhanced;\n  }\n\n  private extractCodeUnitFromResult(result: SearchResult): CodeUnit | undefined {\n    const path = result.metadata.path;\n    if (path === undefined || path === '') return undefined;\n\n    const ext = path.split('.').pop() ?? '';\n    const language = ext === 'ts' || ext === 'tsx' ? 'typescript' :\n                     ext === 'js' || ext === 'jsx' ? 'javascript' : ext;\n\n    // Try to find a symbol name in the content\n    const symbolName = this.extractSymbolName(result.content);\n    if (symbolName === '') return undefined;\n\n    return this.codeUnitService.extractCodeUnit(result.content, symbolName, language);\n  }\n\n  private extractSymbolName(content: string): string {\n    // Extract function or class name\n    const funcMatch = content.match(/(?:export\\s+)?(?:async\\s+)?function\\s+(\\w+)/);\n    if (funcMatch !== null && funcMatch[1] !== undefined && funcMatch[1] !== '') return funcMatch[1];\n\n    const classMatch = content.match(/(?:export\\s+)?class\\s+(\\w+)/);\n    if (classMatch !== null && classMatch[1] !== undefined && classMatch[1] !== '') return classMatch[1];\n\n    const constMatch = content.match(/(?:export\\s+)?const\\s+(\\w+)/);\n    if (constMatch !== null && constMatch[1] !== undefined && constMatch[1] !== '') return constMatch[1];\n\n    // Fallback: return \"(anonymous)\" for unnamed symbols\n    return '(anonymous)';\n  }\n\n  private inferType(fileType: string | undefined, codeUnit: CodeUnit | undefined): import('../types/search.js').ResultSummary['type'] {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    if (codeUnit) return codeUnit.type as import('../types/search.js').ResultSummary['type'];\n    if (fileType === 'documentation' || fileType === 'documentation-primary') return 'documentation';\n    return 'function';\n  }\n\n  private generatePurpose(content: string, query: string): string {\n    // Extract first line of JSDoc comment if present\n    const docMatch = content.match(/\\/\\*\\*\\s*\\n\\s*\\*\\s*([^\\n]+)/);\n    if (docMatch !== null && docMatch[1] !== undefined && docMatch[1] !== '') return docMatch[1].trim();\n\n    const lines = content.split('\\n');\n    const queryTerms = query.toLowerCase().split(/\\s+/).filter(t => t.length > 2);\n\n    // Helper to check if line is skippable (imports, declarations)\n    const shouldSkip = (cleaned: string): boolean => {\n      return cleaned.startsWith('import ') ||\n             cleaned.startsWith('export ') ||\n             cleaned.startsWith('interface ') ||\n             cleaned.startsWith('type ');\n    };\n\n    // Helper to score a line based on query term matches\n    const scoreLine = (cleaned: string): number => {\n      const lowerLine = cleaned.toLowerCase();\n      return queryTerms.filter(term => lowerLine.includes(term)).length;\n    };\n\n    // Helper to check if line is meaningful (length, not a comment)\n    const isMeaningful = (cleaned: string): boolean => {\n      if (cleaned.length === 0) return false;\n      if (cleaned.startsWith('//') || cleaned.startsWith('/*')) return false;\n      // Accept Markdown headings\n      if (cleaned.startsWith('#') && cleaned.length > 3) return true;\n      // Accept lines 15+ chars\n      return cleaned.length >= 15;\n    };\n\n    // First pass: find lines with query terms, preferring complete sentences\n    let bestLine: string | null = null;\n    let bestScore = 0;\n\n    for (const line of lines) {\n      const cleaned = line.trim();\n      if (shouldSkip(cleaned) || !isMeaningful(cleaned)) continue;\n\n      let score = scoreLine(cleaned);\n      \n      // Boost score for complete sentences (end with period, !, ?)\n      if (/[.!?]$/.test(cleaned)) {\n        score += 0.5;\n      }\n      \n      // Boost score for code examples (contains function calls or assignments)\n      // Favor complete patterns: function calls WITH arguments, assignments with values\n      if (/\\w+\\([^)]*\\)|=\\s*\\w+\\(|=>/.test(cleaned)) {\n        score += 0.6;  // Enhanced boost to preserve code examples in snippets\n      }\n      \n      if (score > bestScore) {\n        bestScore = score;\n        bestLine = cleaned;\n      }\n    }\n\n    // If we found a line with query terms, use it\n    if (bestLine !== null && bestLine !== '' && bestScore > 0) {\n      if (bestLine.length > 150) {\n        const firstSentence = bestLine.match(/^[^.!?]+[.!?]/);\n        if (firstSentence && firstSentence[0].length >= 20 && firstSentence[0].length <= 150) {\n          return firstSentence[0].trim();\n        }\n        return bestLine.substring(0, 147) + '...';\n      }\n      return bestLine;\n    }\n\n    // Fallback: first meaningful line (original logic)\n    for (const line of lines) {\n      const cleaned = line.trim();\n      if (shouldSkip(cleaned) || !isMeaningful(cleaned)) continue;\n\n      if (cleaned.length > 150) {\n        const firstSentence = cleaned.match(/^[^.!?]+[.!?]/);\n        if (firstSentence && firstSentence[0].length >= 20 && firstSentence[0].length <= 150) {\n          return firstSentence[0].trim();\n        }\n        return cleaned.substring(0, 147) + '...';\n      }\n\n      return cleaned;\n    }\n\n    return 'Code related to query';\n  }\n\n  private generateRelevanceReason(result: SearchResult, query: string): string {\n    const queryTerms = query.toLowerCase().split(/\\s+/).filter(t => t.length > 2);\n    const contentLower = result.content.toLowerCase();\n\n    const matchedTerms = queryTerms.filter(term => contentLower.includes(term));\n\n    if (matchedTerms.length > 0) {\n      return `Matches: ${matchedTerms.join(', ')}`;\n    }\n\n    return 'Semantically similar to query';\n  }\n\n  private extractInterfaces(content: string): string[] {\n    const interfaces: string[] = [];\n    const matches = content.matchAll(/interface\\s+(\\w+)/g);\n    for (const match of matches) {\n      if (match[1] !== undefined && match[1] !== '') interfaces.push(match[1]);\n    }\n    return interfaces;\n  }\n\n  private extractImports(content: string): string[] {\n    const imports: string[] = [];\n    const matches = content.matchAll(/import\\s+.*?from\\s+['\"]([^'\"]+)['\"]/g);\n    for (const match of matches) {\n      if (match[1] !== undefined && match[1] !== '') imports.push(match[1]);\n    }\n    return imports.slice(0, 5); // Top 5\n  }\n\n  private extractConcepts(content: string, _query: string): string[] {\n    // TODO: Use _query parameter to prioritize query-related concepts in future enhancement\n\n    // Common stopwords to filter out\n    const stopwords = new Set([\n      'this', 'that', 'these', 'those', 'from', 'with', 'have', 'will',\n      'would', 'should', 'could', 'about', 'been', 'were', 'being',\n      'function', 'return', 'const', 'import', 'export', 'default',\n      'type', 'interface', 'class', 'extends', 'implements', 'async',\n      'await', 'then', 'catch', 'throw', 'error', 'undefined', 'null',\n      'true', 'false', 'void', 'number', 'string', 'boolean', 'object',\n      'array', 'promise', 'callback', 'resolve', 'reject', 'value',\n      'param', 'params', 'args', 'props', 'options', 'config', 'data'\n    ]);\n\n    // Simple keyword extraction\n    const words = content.toLowerCase().match(/\\b[a-z]{4,}\\b/g) ?? [];\n    const frequency = new Map<string, number>();\n\n    for (const word of words) {\n      // Skip stopwords\n      if (stopwords.has(word)) continue;\n\n      frequency.set(word, (frequency.get(word) ?? 0) + 1);\n    }\n\n    return Array.from(frequency.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(([word]) => word);\n  }\n\n  private extractDocumentation(content: string): string {\n    const docMatch = content.match(/\\/\\*\\*([\\s\\S]*?)\\*\\//);\n    if (docMatch !== null && docMatch[1] !== undefined && docMatch[1] !== '') {\n      return docMatch[1]\n        .split('\\n')\n        .map(line => line.replace(/^\\s*\\*\\s?/, '').trim())\n        .filter(line => line.length > 0)\n        .join('\\n');\n    }\n    return '';\n  }\n\n  /**\n   * Get usage stats from code graph.\n   * Returns default values if no graph is available.\n   */\n  private getUsageFromGraph(\n    graph: CodeGraph | null,\n    filePath: string,\n    symbolName: string\n  ): { calledBy: number; calls: number } {\n    if (!graph || symbolName === '' || symbolName === '(anonymous)') {\n      return { calledBy: 0, calls: 0 };\n    }\n\n    const nodeId = `${filePath}:${symbolName}`;\n    return {\n      calledBy: graph.getCalledByCount(nodeId),\n      calls: graph.getCallsCount(nodeId)\n    };\n  }\n\n  /**\n   * Get related code from graph.\n   * Returns callers and callees for the symbol.\n   */\n  private getRelatedCodeFromGraph(\n    graph: CodeGraph | null,\n    filePath: string,\n    symbolName: string\n  ): Array<{ file: string; summary: string; relationship: string }> {\n    if (!graph || symbolName === '' || symbolName === '(anonymous)') {\n      return [];\n    }\n\n    const nodeId = `${filePath}:${symbolName}`;\n    const related: Array<{ file: string; summary: string; relationship: string }> = [];\n\n    // Get callers (incoming edges)\n    const incoming = graph.getIncomingEdges(nodeId);\n    for (const edge of incoming) {\n      if (edge.type === 'calls') {\n        // Parse file:symbol from edge.from\n        const [file, symbol] = this.parseNodeId(edge.from);\n        related.push({\n          file,\n          summary: symbol ? `${symbol}()` : 'unknown',\n          relationship: 'calls this'\n        });\n      }\n    }\n\n    // Get callees (outgoing edges)\n    const outgoing = graph.getEdges(nodeId);\n    for (const edge of outgoing) {\n      if (edge.type === 'calls') {\n        // Parse file:symbol from edge.to\n        const [file, symbol] = this.parseNodeId(edge.to);\n        related.push({\n          file,\n          summary: symbol ? `${symbol}()` : 'unknown',\n          relationship: 'called by this'\n        });\n      }\n    }\n\n    // Limit to top 10 related items\n    return related.slice(0, 10);\n  }\n\n  /**\n   * Parse a node ID into file path and symbol name.\n   */\n  private parseNodeId(nodeId: string): [string, string] {\n    const lastColon = nodeId.lastIndexOf(':');\n    if (lastColon === -1) {\n      return [nodeId, ''];\n    }\n    return [nodeId.substring(0, lastColon), nodeId.substring(lastColon + 1)];\n  }\n}\n","import { readFile, readdir } from 'node:fs/promises';\nimport { join, extname, basename } from 'node:path';\nimport { createHash } from 'node:crypto';\nimport type { LanceStore } from '../db/lance.js';\nimport type { EmbeddingEngine } from '../db/embeddings.js';\nimport type { Store, FileStore, RepoStore } from '../types/store.js';\nimport type { Document } from '../types/document.js';\nimport { createDocumentId } from '../types/brands.js';\nimport type { Result } from '../types/result.js';\nimport { ok, err } from '../types/result.js';\nimport { ChunkingService } from './chunking.service.js';\nimport type { ProgressCallback } from '../types/progress.js';\nimport type { CodeGraphService } from './code-graph.service.js';\n\ninterface IndexResult {\n  documentsIndexed: number;\n  chunksCreated: number;\n  timeMs: number;\n}\n\ninterface IndexOptions {\n  chunkSize?: number;\n  chunkOverlap?: number;\n  codeGraphService?: CodeGraphService;\n}\n\nconst TEXT_EXTENSIONS = new Set([\n  '.txt', '.md', '.js', '.ts', '.jsx', '.tsx', '.json', '.yaml', '.yml',\n  '.html', '.css', '.scss', '.less', '.py', '.rb', '.go', '.rs', '.java',\n  '.c', '.cpp', '.h', '.hpp', '.sh', '.bash', '.zsh', '.sql', '.xml',\n]);\n\nexport class IndexService {\n  private readonly lanceStore: LanceStore;\n  private readonly embeddingEngine: EmbeddingEngine;\n  private readonly chunker: ChunkingService;\n  private readonly codeGraphService: CodeGraphService | undefined;\n\n  constructor(\n    lanceStore: LanceStore,\n    embeddingEngine: EmbeddingEngine,\n    options: IndexOptions = {}\n  ) {\n    this.lanceStore = lanceStore;\n    this.embeddingEngine = embeddingEngine;\n    this.chunker = new ChunkingService({\n      chunkSize: options.chunkSize ?? 768,\n      chunkOverlap: options.chunkOverlap ?? 100,\n    });\n    this.codeGraphService = options.codeGraphService;\n  }\n\n  async indexStore(store: Store, onProgress?: ProgressCallback): Promise<Result<IndexResult>> {\n    try {\n      if (store.type === 'file' || store.type === 'repo') {\n        return await this.indexFileStore(store, onProgress);\n      }\n\n      return err(new Error(`Indexing not supported for store type: ${store.type}`));\n    } catch (error) {\n      return err(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  private async indexFileStore(store: FileStore | RepoStore, onProgress?: ProgressCallback): Promise<Result<IndexResult>> {\n    const startTime = Date.now();\n    const files = await this.scanDirectory(store.path);\n    const documents: Document[] = [];\n    let filesProcessed = 0;\n\n    // Collect source files for code graph building\n    const sourceFiles: Array<{ path: string; content: string }> = [];\n\n    // Emit start event\n    onProgress?.({\n      type: 'start',\n      current: 0,\n      total: files.length,\n      message: 'Starting index'\n    });\n\n    for (const filePath of files) {\n      const content = await readFile(filePath, 'utf-8');\n      const fileHash = createHash('md5').update(content).digest('hex');\n      // Pass file path for semantic Markdown chunking\n      const chunks = this.chunker.chunk(content, filePath);\n\n      // Determine file type for ranking\n      const ext = extname(filePath).toLowerCase();\n      const fileName = basename(filePath).toLowerCase();\n      const fileType = this.classifyFileType(ext, fileName, filePath);\n\n      // Collect source files for code graph\n      if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {\n        sourceFiles.push({ path: filePath, content });\n      }\n\n      for (const chunk of chunks) {\n        const vector = await this.embeddingEngine.embed(chunk.content);\n        const chunkId = chunks.length > 1\n          ? `${store.id}-${fileHash}-${String(chunk.chunkIndex)}`\n          : `${store.id}-${fileHash}`;\n\n        const doc: Document = {\n          id: createDocumentId(chunkId),\n          content: chunk.content,\n          vector,\n          metadata: {\n            type: chunks.length > 1 ? 'chunk' : 'file',\n            storeId: store.id,\n            path: filePath,\n            indexedAt: new Date(),\n            fileHash,\n            chunkIndex: chunk.chunkIndex,\n            totalChunks: chunk.totalChunks,\n            // New metadata for ranking\n            fileType,\n            sectionHeader: chunk.sectionHeader,\n            functionName: chunk.functionName,\n            hasDocComments: /\\/\\*\\*[\\s\\S]*?\\*\\//.test(chunk.content),\n            docSummary: chunk.docSummary,\n          },\n        };\n        documents.push(doc);\n      }\n      filesProcessed++;\n\n      // Emit progress event\n      onProgress?.({\n        type: 'progress',\n        current: filesProcessed,\n        total: files.length,\n        message: `Indexing ${filePath}`\n      });\n    }\n\n    if (documents.length > 0) {\n      await this.lanceStore.addDocuments(store.id, documents);\n    }\n\n    // Build and save code graph if service is available and we have source files\n    if (this.codeGraphService && sourceFiles.length > 0) {\n      const graph = await this.codeGraphService.buildGraph(sourceFiles);\n      await this.codeGraphService.saveGraph(store.id, graph);\n    }\n\n    // Emit complete event\n    onProgress?.({\n      type: 'complete',\n      current: files.length,\n      total: files.length,\n      message: 'Indexing complete'\n    });\n\n    return ok({\n      documentsIndexed: filesProcessed,\n      chunksCreated: documents.length,\n      timeMs: Date.now() - startTime,\n    });\n  }\n\n  private async scanDirectory(dir: string): Promise<string[]> {\n    const files: string[] = [];\n    const entries = await readdir(dir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name);\n\n      if (entry.isDirectory()) {\n        // Skip common ignored directories\n        if (!['node_modules', '.git', 'dist', 'build'].includes(entry.name)) {\n          files.push(...(await this.scanDirectory(fullPath)));\n        }\n      } else if (entry.isFile()) {\n        const ext = extname(entry.name).toLowerCase();\n        if (TEXT_EXTENSIONS.has(ext)) {\n          files.push(fullPath);\n        }\n      }\n    }\n\n    return files;\n  }\n\n  /**\n   * Classify file type for ranking purposes.\n   * Documentation files rank higher than source code for documentation queries.\n   * Phase 4: Enhanced to detect internal implementation files.\n   */\n  private classifyFileType(ext: string, fileName: string, filePath: string): string {\n    // Documentation files\n    if (ext === '.md') {\n      // CHANGELOG files get their own category for intent-based penalties\n      if (fileName === 'changelog.md' || fileName === 'changes.md' || /changelog/i.test(fileName)) {\n        return 'changelog';\n      }\n      // Special doc files get highest priority\n      if (['readme.md', 'migration.md', 'contributing.md'].includes(fileName)) {\n        return 'documentation-primary';\n      }\n      // Check path for documentation indicators\n      if (/\\/(docs?|documentation|guides?|tutorials?|articles?)\\//i.test(filePath)) {\n        return 'documentation';\n      }\n      return 'documentation';\n    }\n\n    // Test files\n    if (/\\.(test|spec)\\.[jt]sx?$/.test(fileName) || /\\/__tests__\\//.test(filePath)) {\n      return 'test';\n    }\n\n    // Example files\n    if (/\\/examples?\\//.test(filePath) || fileName.includes('example')) {\n      return 'example';\n    }\n\n    // Config files\n    if (/^(tsconfig|package|\\.eslint|\\.prettier|vite\\.config|next\\.config)/i.test(fileName)) {\n      return 'config';\n    }\n\n    // Source code - distinguish between internal and public-facing\n    if (['.ts', '.tsx', '.js', '.jsx', '.py', '.go', '.rs', '.java'].includes(ext)) {\n      // Internal implementation files (monorepo packages, lib internals)\n      // These patterns indicate internal/core implementation code\n      if (this.isInternalImplementation(filePath, fileName)) {\n        return 'source-internal';\n      }\n      return 'source';\n    }\n\n    return 'other';\n  }\n\n  /**\n   * Detect if a source file is internal implementation code.\n   * Internal code should rank lower than public-facing APIs and docs.\n   */\n  private isInternalImplementation(filePath: string, fileName: string): boolean {\n    const pathLower = filePath.toLowerCase();\n    const fileNameLower = fileName.toLowerCase();\n\n    // Monorepo internal packages (like Vue's packages/*/src/)\n    if (/\\/packages\\/[^/]+\\/src\\//.test(pathLower)) {\n      // Exception: index files often export public APIs\n      if (fileNameLower === 'index.ts' || fileNameLower === 'index.js') {\n        return false;\n      }\n      return true;\n    }\n\n    // Internal/core directories\n    if (/\\/(internal|lib\\/core|core\\/src|_internal|private)\\//.test(pathLower)) {\n      return true;\n    }\n\n    // Compiler/transform internals (often not what users want)\n    if (/\\/(compiler|transforms?|parse|codegen)\\//.test(pathLower) &&\n        !fileNameLower.includes('readme') && !fileNameLower.includes('index')) {\n      return true;\n    }\n\n    return false;\n  }\n}\n","export interface ChunkConfig {\n  chunkSize: number;\n  chunkOverlap: number;\n}\n\nexport interface Chunk {\n  content: string;\n  chunkIndex: number;\n  totalChunks: number;\n  startOffset: number;\n  endOffset: number;\n  /** Section header if this chunk starts a markdown section */\n  sectionHeader?: string | undefined;\n  /** Function or class name if this chunk contains a code declaration */\n  functionName?: string | undefined;\n  /** JSDoc/comment summary extracted from this chunk */\n  docSummary?: string | undefined;\n}\n\nexport class ChunkingService {\n  private readonly chunkSize: number;\n  private readonly chunkOverlap: number;\n\n  constructor(config: ChunkConfig) {\n    this.chunkSize = config.chunkSize;\n    this.chunkOverlap = config.chunkOverlap;\n  }\n\n  /**\n   * Chunk text content. Uses semantic chunking for Markdown and code files,\n   * falling back to sliding window for other content.\n   */\n  chunk(text: string, filePath?: string): Chunk[] {\n    // Use semantic chunking for Markdown files\n    if (filePath !== undefined && filePath !== '' && /\\.md$/i.test(filePath)) {\n      return this.chunkMarkdown(text);\n    }\n\n    // Use semantic chunking for TypeScript/JavaScript files\n    if (filePath !== undefined && filePath !== '' && /\\.(ts|tsx|js|jsx)$/i.test(filePath)) {\n      return this.chunkCode(text);\n    }\n\n    return this.chunkSlidingWindow(text);\n  }\n\n  /**\n   * Semantic chunking for Markdown files.\n   * Splits on section headers to keep related content together.\n   */\n  private chunkMarkdown(text: string): Chunk[] {\n    // Match markdown headers (# through ####)\n    const headerRegex = /^(#{1,4})\\s+(.+)$/gm;\n    const sections: Array<{ header: string; content: string; startOffset: number }> = [];\n\n    let lastIndex = 0;\n    let lastHeader = '';\n    let match: RegExpExecArray | null;\n\n    while ((match = headerRegex.exec(text)) !== null) {\n      // Save previous section\n      if (match.index > lastIndex) {\n        const content = text.slice(lastIndex, match.index).trim();\n        if (content) {\n          sections.push({\n            header: lastHeader,\n            content: content,\n            startOffset: lastIndex,\n          });\n        }\n      }\n      lastHeader = match[2] ?? '';\n      lastIndex = match.index;\n    }\n\n    // Add final section\n    const finalContent = text.slice(lastIndex).trim();\n    if (finalContent) {\n      sections.push({\n        header: lastHeader,\n        content: finalContent,\n        startOffset: lastIndex,\n      });\n    }\n\n    // If no sections found, fall back to sliding window\n    if (sections.length === 0) {\n      return this.chunkSlidingWindow(text);\n    }\n\n    // Convert sections to chunks, splitting large sections if needed\n    const chunks: Chunk[] = [];\n\n    for (const section of sections) {\n      if (section.content.length <= this.chunkSize) {\n        // Section fits in one chunk\n        chunks.push({\n          content: section.content,\n          chunkIndex: chunks.length,\n          totalChunks: 0,\n          startOffset: section.startOffset,\n          endOffset: section.startOffset + section.content.length,\n          sectionHeader: section.header || undefined,\n        });\n      } else {\n        // Split large section using sliding window\n        const sectionChunks = this.chunkSlidingWindow(section.content);\n        for (const subChunk of sectionChunks) {\n          chunks.push({\n            ...subChunk,\n            chunkIndex: chunks.length,\n            startOffset: section.startOffset + subChunk.startOffset,\n            endOffset: section.startOffset + subChunk.endOffset,\n            sectionHeader: section.header || undefined,\n          });\n        }\n      }\n    }\n\n    // Set totalChunks\n    for (const chunk of chunks) {\n      chunk.totalChunks = chunks.length;\n    }\n\n    return chunks;\n  }\n\n  /**\n   * Semantic chunking for TypeScript/JavaScript code files.\n   * Splits on top-level declarations to keep functions/classes together.\n   */\n  private chunkCode(text: string): Chunk[] {\n    // Match top-level declarations with optional JSDoc/comments before them\n    const declarationRegex = /^(?:\\/\\*\\*[\\s\\S]*?\\*\\/\\s*)?(?:export\\s+)?(?:async\\s+)?(?:function|class|interface|type|const|let|var|enum)\\s+(\\w+)/gm;\n    const declarations: Array<{ startOffset: number; endOffset: number; name?: string }> = [];\n\n    let match: RegExpExecArray | null;\n    while ((match = declarationRegex.exec(text)) !== null) {\n      const name = match[1];\n      const decl: { startOffset: number; endOffset: number; name?: string } = {\n        startOffset: match.index,\n        endOffset: match.index,\n      };\n      if (name !== undefined) {\n        decl.name = name;\n      }\n      declarations.push(decl);\n    }\n\n    // If no declarations found, use sliding window\n    if (declarations.length === 0) {\n      return this.chunkSlidingWindow(text);\n    }\n\n    // Find end of each declaration using brace-aware boundary detection\n    for (let i = 0; i < declarations.length; i++) {\n      const currentDecl = declarations[i];\n      const nextDecl = declarations[i + 1];\n      if (currentDecl === undefined) continue;\n\n      // For declarations that likely have braces (functions, classes, enums)\n      // use smart boundary detection\n      const declText = text.slice(currentDecl.startOffset);\n      if (/^(?:\\/\\*\\*[\\s\\S]*?\\*\\/\\s*)?(?:export\\s+)?(?:async\\s+)?(?:function|class|enum)\\s+/m.test(declText)) {\n        const boundary = this.findDeclarationEnd(declText);\n        if (boundary > 0) {\n          currentDecl.endOffset = currentDecl.startOffset + boundary;\n        } else {\n          // Fall back to next declaration or EOF\n          currentDecl.endOffset = nextDecl !== undefined ? nextDecl.startOffset : text.length;\n        }\n      } else {\n        // For other declarations (interface, type, const, let, var), use next declaration or EOF\n        currentDecl.endOffset = nextDecl !== undefined ? nextDecl.startOffset : text.length;\n      }\n    }\n\n    const chunks: Chunk[] = [];\n\n    for (const decl of declarations) {\n      const content = text.slice(decl.startOffset, decl.endOffset).trim();\n\n      if (content.length <= this.chunkSize) {\n        // Declaration fits in one chunk\n        chunks.push({\n          content,\n          chunkIndex: chunks.length,\n          totalChunks: 0,\n          startOffset: decl.startOffset,\n          endOffset: decl.endOffset,\n          functionName: decl.name,\n        });\n      } else {\n        // Split large declaration with sliding window\n        const declChunks = this.chunkSlidingWindow(content);\n        for (const subChunk of declChunks) {\n          chunks.push({\n            ...subChunk,\n            chunkIndex: chunks.length,\n            startOffset: decl.startOffset + subChunk.startOffset,\n            endOffset: decl.startOffset + subChunk.endOffset,\n            functionName: decl.name,\n          });\n        }\n      }\n    }\n\n    // Set totalChunks\n    for (const chunk of chunks) {\n      chunk.totalChunks = chunks.length;\n    }\n\n    return chunks.length > 0 ? chunks : this.chunkSlidingWindow(text);\n  }\n\n  /**\n   * Find the end of a code declaration by counting braces while ignoring\n   * braces inside strings and comments.\n   * Returns the offset where the declaration ends, or -1 if not found.\n   */\n  private findDeclarationEnd(text: string): number {\n    let braceCount = 0;\n    let inString = false;\n    let inSingleLineComment = false;\n    let inMultiLineComment = false;\n    let stringChar = '';\n    let i = 0;\n    let foundFirstBrace = false;\n\n    // Find the first opening brace\n    while (i < text.length) {\n      const char = text[i];\n      const nextChar = i + 1 < text.length ? text[i + 1] : '';\n\n      // Handle comments\n      if (!inString && !inMultiLineComment && char === '/' && nextChar === '/') {\n        inSingleLineComment = true;\n        i += 2;\n        continue;\n      }\n\n      if (!inString && !inSingleLineComment && char === '/' && nextChar === '*') {\n        inMultiLineComment = true;\n        i += 2;\n        continue;\n      }\n\n      if (inMultiLineComment && char === '*' && nextChar === '/') {\n        inMultiLineComment = false;\n        i += 2;\n        continue;\n      }\n\n      if (inSingleLineComment && char === '\\n') {\n        inSingleLineComment = false;\n        i++;\n        continue;\n      }\n\n      // Skip if in comment\n      if (inSingleLineComment || inMultiLineComment) {\n        i++;\n        continue;\n      }\n\n      // Handle strings\n      if (!inString && (char === '\"' || char === \"'\" || char === '`')) {\n        inString = true;\n        stringChar = char;\n        i++;\n        continue;\n      }\n\n      if (inString && char === '\\\\') {\n        // Skip escaped character\n        i += 2;\n        continue;\n      }\n\n      if (inString && char === stringChar) {\n        inString = false;\n        stringChar = '';\n        i++;\n        continue;\n      }\n\n      // Skip if in string\n      if (inString) {\n        i++;\n        continue;\n      }\n\n      // Count braces\n      if (char === '{') {\n        braceCount++;\n        foundFirstBrace = true;\n      } else if (char === '}') {\n        braceCount--;\n        if (foundFirstBrace && braceCount === 0) {\n          // Found the closing brace\n          return i + 1;\n        }\n      }\n\n      i++;\n    }\n\n    // If we didn't find a complete declaration, return -1\n    return -1;\n  }\n\n  /**\n   * Traditional sliding window chunking for non-Markdown content.\n   */\n  private chunkSlidingWindow(text: string): Chunk[] {\n    if (text.length <= this.chunkSize) {\n      return [{\n        content: text,\n        chunkIndex: 0,\n        totalChunks: 1,\n        startOffset: 0,\n        endOffset: text.length,\n      }];\n    }\n\n    const chunks: Chunk[] = [];\n    const step = this.chunkSize - this.chunkOverlap;\n    let start = 0;\n\n    while (start < text.length) {\n      const end = Math.min(start + this.chunkSize, text.length);\n      chunks.push({\n        content: text.slice(start, end),\n        chunkIndex: chunks.length,\n        totalChunks: 0,\n        startOffset: start,\n        endOffset: end,\n      });\n      start += step;\n      if (end === text.length) break;\n    }\n\n    // Set totalChunks\n    for (const chunk of chunks) {\n      chunk.totalChunks = chunks.length;\n    }\n\n    return chunks;\n  }\n}\n","import { readFile, writeFile, mkdir } from 'node:fs/promises';\nimport { join, dirname } from 'node:path';\nimport { CodeGraph, type GraphNode } from '../analysis/code-graph.js';\nimport { ASTParser } from '../analysis/ast-parser.js';\nimport { RustASTParser } from '../analysis/rust-ast-parser.js';\nimport { GoASTParser } from '../analysis/go-ast-parser.js';\nimport { ParserFactory } from '../analysis/parser-factory.js';\nimport type { PythonBridge } from '../crawl/bridge.js';\nimport type { StoreId } from '../types/brands.js';\n\ninterface SerializedGraph {\n  nodes: Array<{\n    id: string;\n    file: string;\n    type: string;\n    name: string;\n    exported: boolean;\n    startLine: number;\n    endLine: number;\n    signature?: string;\n  }>;\n  edges: Array<{\n    from: string;\n    to: string;\n    type: string;\n    confidence: number;\n  }>;\n}\n\n/**\n * Service for building, persisting, and querying code graphs.\n * Code graphs track relationships between code elements (functions, classes, etc.)\n * for enhanced search context.\n */\nexport class CodeGraphService {\n  private readonly dataDir: string;\n  private readonly parser: ASTParser;\n  private readonly parserFactory: ParserFactory;\n  private readonly graphCache: Map<string, CodeGraph>;\n\n  constructor(dataDir: string, pythonBridge?: PythonBridge) {\n    this.dataDir = dataDir;\n    this.parser = new ASTParser();\n    this.parserFactory = new ParserFactory(pythonBridge);\n    this.graphCache = new Map();\n  }\n\n  /**\n   * Build a code graph from source files.\n   */\n  async buildGraph(files: Array<{ path: string; content: string }>): Promise<CodeGraph> {\n    const graph = new CodeGraph();\n\n    for (const file of files) {\n      const ext = file.path.split('.').pop() ?? '';\n      if (!['ts', 'tsx', 'js', 'jsx', 'py', 'rs', 'go'].includes(ext)) continue;\n\n      // Parse nodes (functions, classes, etc.) using the factory\n      const nodes = await this.parserFactory.parseFile(file.path, file.content);\n      graph.addNodes(nodes, file.path);\n\n      // Parse imports and add edges\n      if (ext === 'rs') {\n        // Use RustASTParser for Rust imports\n        const rustParser = new RustASTParser();\n        const imports = rustParser.extractImports(file.content);\n        for (const imp of imports) {\n          if (!imp.isType) {\n            graph.addImport(file.path, imp.source, imp.specifiers);\n          }\n        }\n      } else if (ext === 'go') {\n        // Use GoASTParser for Go imports\n        const goParser = new GoASTParser();\n        const imports = goParser.extractImports(file.content);\n        for (const imp of imports) {\n          if (!imp.isType) {\n            graph.addImport(file.path, imp.source, imp.specifiers);\n          }\n        }\n      } else if (ext !== 'py') {\n        // Use ASTParser for JS/TS imports (Python imports handled by Python parser)\n        const imports = this.parser.extractImports(file.content);\n        for (const imp of imports) {\n          if (!imp.isType) {\n            graph.addImport(file.path, imp.source, imp.specifiers);\n          }\n        }\n      }\n\n      // Analyze call relationships for each function/method\n      for (const node of nodes) {\n        const lines = file.content.split('\\n');\n\n        if (node.type === 'function') {\n          // Extract the function body for call analysis\n          const functionCode = lines.slice(node.startLine - 1, node.endLine).join('\\n');\n          graph.analyzeCallRelationships(functionCode, file.path, node.name);\n        } else if (node.type === 'class' && node.methods !== undefined) {\n          // For classes, analyze each method separately\n          for (const method of node.methods) {\n            const methodCode = lines.slice(method.startLine - 1, method.endLine).join('\\n');\n            graph.analyzeCallRelationships(methodCode, file.path, `${node.name}.${method.name}`);\n          }\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  /**\n   * Save a code graph for a store.\n   */\n  async saveGraph(storeId: StoreId, graph: CodeGraph): Promise<void> {\n    const graphPath = this.getGraphPath(storeId);\n    await mkdir(dirname(graphPath), { recursive: true });\n\n    const serialized = graph.toJSON();\n    await writeFile(graphPath, JSON.stringify(serialized, null, 2));\n  }\n\n  /**\n   * Load a code graph for a store.\n   * Returns undefined if no graph exists.\n   */\n  async loadGraph(storeId: StoreId): Promise<CodeGraph | undefined> {\n    // Check cache first\n    const cached = this.graphCache.get(storeId);\n    if (cached) return cached;\n\n    const graphPath = this.getGraphPath(storeId);\n\n    try {\n      const content = await readFile(graphPath, 'utf-8');\n      const parsed: unknown = JSON.parse(content);\n\n      // Validate structure\n      if (!this.isSerializedGraph(parsed)) {\n        return undefined;\n      }\n\n      const serialized = parsed;\n      const graph = new CodeGraph();\n\n      // Restore nodes\n      for (const node of serialized.nodes) {\n        const nodeType = this.validateNodeType(node.type);\n        if (!nodeType) continue;\n\n        // Method nodes are added directly to the graph since they're already separate nodes\n        if (nodeType === 'method') {\n          const graphNode: GraphNode = {\n            id: node.id,\n            file: node.file,\n            type: 'method',\n            name: node.name,\n            exported: node.exported,\n            startLine: node.startLine,\n            endLine: node.endLine\n          };\n          if (node.signature !== undefined) {\n            graphNode.signature = node.signature;\n          }\n          graph.addGraphNode(graphNode);\n          continue;\n        }\n\n        const codeNode: {\n          type: 'function' | 'class' | 'interface' | 'type' | 'const';\n          name: string;\n          exported: boolean;\n          startLine: number;\n          endLine: number;\n          signature?: string;\n        } = {\n          type: nodeType,\n          name: node.name,\n          exported: node.exported,\n          startLine: node.startLine,\n          endLine: node.endLine,\n        };\n        if (node.signature !== undefined) {\n          codeNode.signature = node.signature;\n        }\n        graph.addNodes([codeNode], node.file);\n      }\n\n      // Restore edges\n      for (const edge of serialized.edges) {\n        const edgeType = this.validateEdgeType(edge.type);\n        if (!edgeType) continue;\n\n        graph.addEdge({\n          from: edge.from,\n          to: edge.to,\n          type: edgeType,\n          confidence: edge.confidence\n        });\n      }\n\n      this.graphCache.set(storeId, graph);\n      return graph;\n    } catch {\n      return undefined;\n    }\n  }\n\n  /**\n   * Get usage stats for a code element.\n   */\n  getUsageStats(graph: CodeGraph, filePath: string, symbolName: string): { calledBy: number; calls: number } {\n    const nodeId = `${filePath}:${symbolName}`;\n    return {\n      calledBy: graph.getCalledByCount(nodeId),\n      calls: graph.getCallsCount(nodeId)\n    };\n  }\n\n  /**\n   * Get related code (callers and callees) for a code element.\n   */\n  getRelatedCode(graph: CodeGraph, filePath: string, symbolName: string): Array<{ id: string; relationship: string }> {\n    const nodeId = `${filePath}:${symbolName}`;\n    const related: Array<{ id: string; relationship: string }> = [];\n\n    // Get callers (incoming call edges)\n    const incoming = graph.getIncomingEdges(nodeId);\n    for (const edge of incoming) {\n      if (edge.type === 'calls') {\n        related.push({ id: edge.from, relationship: 'calls this' });\n      }\n    }\n\n    // Get callees (outgoing call edges)\n    const outgoing = graph.getEdges(nodeId);\n    for (const edge of outgoing) {\n      if (edge.type === 'calls') {\n        related.push({ id: edge.to, relationship: 'called by this' });\n      }\n    }\n\n    return related;\n  }\n\n  /**\n   * Clear cached graphs.\n   */\n  clearCache(): void {\n    this.graphCache.clear();\n  }\n\n  private getGraphPath(storeId: StoreId): string {\n    return join(this.dataDir, 'graphs', `${storeId}.json`);\n  }\n\n  /**\n   * Type guard for SerializedGraph structure.\n   */\n  private isSerializedGraph(value: unknown): value is SerializedGraph {\n    if (typeof value !== 'object' || value === null) return false;\n    // Use 'in' operator for property checking\n    if (!('nodes' in value) || !('edges' in value)) return false;\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- narrowed via 'in' checks above\n    const obj = value as { nodes: unknown; edges: unknown };\n    return Array.isArray(obj.nodes) && Array.isArray(obj.edges);\n  }\n\n  /**\n   * Type guard for valid node types.\n   */\n  private isValidNodeType(type: string): type is 'function' | 'class' | 'interface' | 'type' | 'const' | 'method' {\n    return ['function', 'class', 'interface', 'type', 'const', 'method'].includes(type);\n  }\n\n  /**\n   * Validate and return a node type, or undefined if invalid.\n   */\n  private validateNodeType(type: string): 'function' | 'class' | 'interface' | 'type' | 'const' | 'method' | undefined {\n    if (this.isValidNodeType(type)) {\n      return type;\n    }\n    return undefined;\n  }\n\n  /**\n   * Type guard for valid edge types.\n   */\n  private isValidEdgeType(type: string): type is 'calls' | 'imports' | 'extends' | 'implements' {\n    return ['calls', 'imports', 'extends', 'implements'].includes(type);\n  }\n\n  /**\n   * Validate and return an edge type, or undefined if invalid.\n   */\n  private validateEdgeType(type: string): 'calls' | 'imports' | 'extends' | 'implements' | undefined {\n    if (this.isValidEdgeType(type)) {\n      return type;\n    }\n    return undefined;\n  }\n}\n","import type { CodeNode } from './ast-parser.js';\n\nexport interface GraphNode {\n  id: string;\n  file: string;\n  type: 'function' | 'class' | 'interface' | 'type' | 'const' | 'method';\n  name: string;\n  exported: boolean;\n  startLine: number;\n  endLine: number;\n  signature?: string;\n}\n\nexport interface GraphEdge {\n  from: string;\n  to: string;\n  type: 'calls' | 'imports' | 'extends' | 'implements';\n  confidence: number;\n}\n\nexport class CodeGraph {\n  private readonly nodes: Map<string, GraphNode> = new Map<string, GraphNode>();\n  private readonly edges: Map<string, GraphEdge[]> = new Map<string, GraphEdge[]>();\n\n  addNodes(nodes: CodeNode[], file: string): void {\n    for (const node of nodes) {\n      const id = `${file}:${node.name}`;\n\n      const graphNode: GraphNode = {\n        id,\n        file,\n        type: node.type,\n        name: node.name,\n        exported: node.exported,\n        startLine: node.startLine,\n        endLine: node.endLine\n      };\n\n      if (node.signature !== undefined) {\n        graphNode.signature = node.signature;\n      }\n\n      this.nodes.set(id, graphNode);\n\n      // Initialize edges array for this node\n      if (!this.edges.has(id)) {\n        this.edges.set(id, []);\n      }\n\n      // If this is a class with methods, create separate nodes for each method\n      if (node.type === 'class' && node.methods !== undefined) {\n        for (const method of node.methods) {\n          const methodId = `${file}:${node.name}.${method.name}`;\n\n          const methodNode: GraphNode = {\n            id: methodId,\n            file,\n            type: 'method',\n            name: method.name,\n            exported: node.exported, // Methods inherit export status from class\n            startLine: method.startLine,\n            endLine: method.endLine,\n            signature: method.signature\n          };\n\n          this.nodes.set(methodId, methodNode);\n\n          // Initialize edges array for this method\n          if (!this.edges.has(methodId)) {\n            this.edges.set(methodId, []);\n          }\n        }\n      }\n    }\n  }\n\n  addImport(fromFile: string, toFile: string, specifiers: string[]): void {\n    // Normalize the toFile path (resolve relative imports)\n    const resolvedTo = this.resolveImportPath(fromFile, toFile);\n\n    for (const spec of specifiers) {\n      const edge: GraphEdge = {\n        from: fromFile,\n        to: `${resolvedTo}:${spec}`,\n        type: 'imports',\n        confidence: 1.0\n      };\n\n      const edges = this.edges.get(fromFile) ?? [];\n      edges.push(edge);\n      this.edges.set(fromFile, edges);\n    }\n  }\n\n  analyzeCallRelationships(code: string, file: string, functionName: string): void {\n    const nodeId = `${file}:${functionName}`;\n\n    // Simple regex-based call detection (can be enhanced with AST later)\n    const callPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/g;\n    const calls = new Set<string>();\n\n    let match;\n    while ((match = callPattern.exec(code)) !== null) {\n      if (match[1] !== undefined && match[1] !== '') {\n        calls.add(match[1]);\n      }\n    }\n\n    const edges = this.edges.get(nodeId) ?? [];\n\n    for (const calledFunction of calls) {\n      // Try to find the called function in the graph\n      const targetNode = this.findNodeByName(calledFunction);\n\n      if (targetNode) {\n        edges.push({\n          from: nodeId,\n          to: targetNode.id,\n          type: 'calls',\n          confidence: 0.8 // Lower confidence for regex-based detection\n        });\n      } else {\n        // Unknown function, possibly from import\n        edges.push({\n          from: nodeId,\n          to: `unknown:${calledFunction}`,\n          type: 'calls',\n          confidence: 0.5\n        });\n      }\n    }\n\n    this.edges.set(nodeId, edges);\n  }\n\n  getNode(id: string): GraphNode | undefined {\n    return this.nodes.get(id);\n  }\n\n  getEdges(nodeId: string): GraphEdge[] {\n    return this.edges.get(nodeId) ?? [];\n  }\n\n  /**\n   * Add an edge to the graph (used when restoring from serialized data)\n   */\n  addEdge(edge: GraphEdge): void {\n    const edges = this.edges.get(edge.from) ?? [];\n    edges.push(edge);\n    this.edges.set(edge.from, edges);\n  }\n\n  /**\n   * Add a graph node directly (used when restoring from serialized data)\n   */\n  addGraphNode(node: GraphNode): void {\n    this.nodes.set(node.id, node);\n\n    // Initialize edges array for this node if it doesn't exist\n    if (!this.edges.has(node.id)) {\n      this.edges.set(node.id, []);\n    }\n  }\n\n  /**\n   * Get edges where this node is the target (callers of this function)\n   */\n  getIncomingEdges(nodeId: string): GraphEdge[] {\n    const incoming: GraphEdge[] = [];\n    for (const edges of this.edges.values()) {\n      for (const edge of edges) {\n        if (edge.to === nodeId) {\n          incoming.push(edge);\n        }\n      }\n    }\n    return incoming;\n  }\n\n  /**\n   * Count how many nodes call this node\n   */\n  getCalledByCount(nodeId: string): number {\n    return this.getIncomingEdges(nodeId)\n      .filter(e => e.type === 'calls')\n      .length;\n  }\n\n  /**\n   * Count how many nodes this node calls\n   */\n  getCallsCount(nodeId: string): number {\n    return this.getEdges(nodeId)\n      .filter(e => e.type === 'calls')\n      .length;\n  }\n\n  getAllNodes(): GraphNode[] {\n    return Array.from(this.nodes.values());\n  }\n\n  private findNodeByName(name: string): GraphNode | undefined {\n    for (const node of this.nodes.values()) {\n      if (node.name === name) {\n        return node;\n      }\n    }\n    return undefined;\n  }\n\n  private resolveImportPath(fromFile: string, importPath: string): string {\n    // Simple resolution - can be enhanced\n    if (importPath.startsWith('.')) {\n      // Relative import\n      const fromDir = fromFile.split('/').slice(0, -1).join('/');\n      const parts = importPath.split('/');\n\n      let resolved = fromDir;\n      for (const part of parts) {\n        if (part === '..') {\n          resolved = resolved.split('/').slice(0, -1).join('/');\n        } else if (part !== '.') {\n          resolved += '/' + part;\n        }\n      }\n\n      return resolved.replace(/\\.js$/, '');\n    }\n\n    // Package import\n    return importPath;\n  }\n\n  toJSON(): { nodes: GraphNode[]; edges: Array<{ from: string; to: string; type: string }> } {\n    const allEdges: GraphEdge[] = [];\n    for (const edges of this.edges.values()) {\n      allEdges.push(...edges);\n    }\n\n    return {\n      nodes: Array.from(this.nodes.values()),\n      edges: allEdges.map(e => ({ from: e.from, to: e.to, type: e.type }))\n    };\n  }\n}\n","import { parse, type ParserPlugin } from '@babel/parser';\nimport type { NodePath } from '@babel/traverse';\nimport traverseModule from '@babel/traverse';\nimport * as t from '@babel/types';\n\n// Handle both ESM and CJS module formats\ntype TraverseFunction = (ast: t.File, visitor: Record<string, unknown>) => void;\nfunction getTraverse(mod: unknown): TraverseFunction {\n  if (typeof mod === 'function') {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    return mod as TraverseFunction;\n  }\n  if (mod !== null && typeof mod === 'object' && 'default' in mod) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    const withDefault = mod as { default: unknown };\n    if (typeof withDefault.default === 'function') {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      return withDefault.default as TraverseFunction;\n    }\n  }\n  throw new Error('Invalid traverse module export');\n}\nconst traverse = getTraverse(traverseModule);\n\nexport interface CodeNode {\n  type: 'function' | 'class' | 'interface' | 'type' | 'const';\n  name: string;\n  exported: boolean;\n  async?: boolean;\n  startLine: number;\n  endLine: number;\n  signature?: string;\n  methods?: Array<{\n    name: string;\n    async: boolean;\n    signature: string;\n    startLine: number;\n    endLine: number;\n  }>;\n}\n\nexport interface ImportInfo {\n  source: string;\n  specifiers: string[];\n  isType: boolean;\n}\n\nexport class ASTParser {\n  parse(code: string, language: 'typescript' | 'javascript'): CodeNode[] {\n    try {\n      const plugins: ParserPlugin[] = ['jsx'];\n      if (language === 'typescript') {\n        plugins.push('typescript');\n      }\n\n      const ast = parse(code, {\n        sourceType: 'module',\n        plugins\n      });\n\n      const nodes: CodeNode[] = [];\n\n      traverse(ast, {\n        FunctionDeclaration: (path: NodePath<t.FunctionDeclaration>) => {\n          const node = path.node;\n          if (!node.id) return;\n\n          const exported = path.parent.type === 'ExportNamedDeclaration' ||\n                          path.parent.type === 'ExportDefaultDeclaration';\n\n          nodes.push({\n            type: 'function',\n            name: node.id.name,\n            exported,\n            async: node.async,\n            startLine: node.loc?.start.line ?? 0,\n            endLine: node.loc?.end.line ?? 0,\n            signature: this.extractFunctionSignature(node)\n          });\n        },\n\n        ClassDeclaration: (path: NodePath<t.ClassDeclaration>) => {\n          const node = path.node;\n          if (!node.id) return;\n\n          const exported = path.parent.type === 'ExportNamedDeclaration' ||\n                          path.parent.type === 'ExportDefaultDeclaration';\n\n          const methods: CodeNode['methods'] = [];\n\n          for (const member of node.body.body) {\n            if (t.isClassMethod(member) && t.isIdentifier(member.key)) {\n              methods.push({\n                name: member.key.name,\n                async: member.async,\n                signature: this.extractMethodSignature(member),\n                startLine: member.loc?.start.line ?? 0,\n                endLine: member.loc?.end.line ?? 0\n              });\n            }\n          }\n\n          nodes.push({\n            type: 'class',\n            name: node.id.name,\n            exported,\n            startLine: node.loc?.start.line ?? 0,\n            endLine: node.loc?.end.line ?? 0,\n            methods\n          });\n        },\n\n        TSInterfaceDeclaration: (path: NodePath<t.TSInterfaceDeclaration>) => {\n          const node = path.node;\n\n          const exported = path.parent.type === 'ExportNamedDeclaration';\n\n          nodes.push({\n            type: 'interface',\n            name: node.id.name,\n            exported,\n            startLine: node.loc?.start.line ?? 0,\n            endLine: node.loc?.end.line ?? 0\n          });\n        }\n      });\n\n      return nodes;\n    } catch {\n      // Return empty array for malformed code\n      return [];\n    }\n  }\n\n  extractImports(code: string): ImportInfo[] {\n    try {\n      const ast = parse(code, {\n        sourceType: 'module',\n        plugins: ['typescript', 'jsx']\n      });\n\n      const imports: ImportInfo[] = [];\n\n      traverse(ast, {\n        ImportDeclaration: (path: NodePath<t.ImportDeclaration>) => {\n          const node = path.node;\n          const specifiers: string[] = [];\n\n          for (const spec of node.specifiers) {\n            if (t.isImportDefaultSpecifier(spec)) {\n              specifiers.push(spec.local.name);\n            } else if (t.isImportSpecifier(spec)) {\n              specifiers.push(spec.local.name);\n            } else if (t.isImportNamespaceSpecifier(spec)) {\n              specifiers.push(spec.local.name);\n            }\n          }\n\n          imports.push({\n            source: node.source.value,\n            specifiers,\n            isType: node.importKind === 'type'\n          });\n        }\n      });\n\n      return imports;\n    } catch {\n      // Return empty array for malformed code\n      return [];\n    }\n  }\n\n  private extractFunctionSignature(node: t.FunctionDeclaration): string {\n    const params = node.params.map(p => {\n      if (t.isIdentifier(p)) return p.name;\n      return 'param';\n    }).join(', ');\n\n    return `${node.id?.name ?? 'anonymous'}(${params})`;\n  }\n\n  private extractMethodSignature(node: t.ClassMethod): string {\n    const params = node.params.map(p => {\n      if (t.isIdentifier(p)) return p.name;\n      return 'param';\n    }).join(', ');\n\n    const name = t.isIdentifier(node.key) ? node.key.name : 'method';\n    return `${name}(${params})`;\n  }\n}\n","import Parser from 'tree-sitter';\nimport Rust from 'tree-sitter-rust';\nimport Go from 'tree-sitter-go';\n\n/**\n * Tree-sitter infrastructure for parsing Rust and Go code.\n * Provides utilities for AST traversal, querying, and position conversion.\n */\n\nexport interface TreeSitterPosition {\n  row: number;\n  column: number;\n}\n\nexport interface TreeSitterNode {\n  type: string;\n  text: string;\n  startPosition: TreeSitterPosition;\n  endPosition: TreeSitterPosition;\n  startIndex: number;\n  endIndex: number;\n  childCount: number;\n  namedChildCount: number;\n  children: TreeSitterNode[];\n  namedChildren: TreeSitterNode[];\n  parent: TreeSitterNode | null;\n  nextSibling: TreeSitterNode | null;\n  previousSibling: TreeSitterNode | null;\n  firstChild: TreeSitterNode | null;\n  lastChild: TreeSitterNode | null;\n  firstNamedChild: TreeSitterNode | null;\n  lastNamedChild: TreeSitterNode | null;\n  child(index: number): TreeSitterNode | null;\n  namedChild(index: number): TreeSitterNode | null;\n  childForFieldName(fieldName: string): TreeSitterNode | null;\n  descendantsOfType(type: string | string[]): TreeSitterNode[];\n}\n\nexport interface TreeSitterTree {\n  rootNode: TreeSitterNode;\n  edit(delta: unknown): void;\n  walk(): unknown;\n}\n\n/**\n * Initialize a tree-sitter parser for Rust\n */\nexport function createRustParser(): Parser {\n  const parser = new Parser();\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- tree-sitter-rust lacks TypeScript definitions\n  parser.setLanguage(Rust as Parser.Language);\n  return parser;\n}\n\n/**\n * Parse Rust source code into an AST\n */\nexport function parseRustCode(code: string): TreeSitterTree | null {\n  try {\n    const parser = createRustParser();\n    return parser.parse(code);\n  } catch {\n    // Return null for malformed code\n    return null;\n  }\n}\n\n/**\n * Initialize a tree-sitter parser for Go\n */\nexport function createGoParser(): Parser {\n  const parser = new Parser();\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- tree-sitter-go lacks TypeScript definitions\n  parser.setLanguage(Go as Parser.Language);\n  return parser;\n}\n\n/**\n * Parse Go source code into an AST\n */\nexport function parseGoCode(code: string): TreeSitterTree | null {\n  try {\n    const parser = createGoParser();\n    return parser.parse(code);\n  } catch {\n    // Return null for malformed code\n    return null;\n  }\n}\n\n/**\n * Convert tree-sitter position (0-indexed) to line number (1-indexed)\n */\nexport function positionToLineNumber(position: TreeSitterPosition): number {\n  return position.row + 1;\n}\n\n/**\n * Get the text content of a node\n */\nexport function getNodeText(node: TreeSitterNode): string {\n  return node.text;\n}\n\n/**\n * Get all children of a specific type\n */\nexport function getChildrenOfType(\n  node: TreeSitterNode,\n  type: string\n): TreeSitterNode[] {\n  return node.children.filter(child => child.type === type);\n}\n\n/**\n * Get the first child of a specific type\n */\nexport function getFirstChildOfType(\n  node: TreeSitterNode,\n  type: string\n): TreeSitterNode | null {\n  return node.children.find(child => child.type === type) ?? null;\n}\n\n/**\n * Get child by field name (e.g., \"name\", \"body\", \"parameters\")\n */\nexport function getChildByFieldName(\n  node: TreeSitterNode,\n  fieldName: string\n): TreeSitterNode | null {\n  return node.childForFieldName(fieldName);\n}\n\n/**\n * Check if node has a visibility modifier (pub)\n */\nexport function hasVisibilityModifier(node: TreeSitterNode): boolean {\n  return node.children.some(child => child.type === 'visibility_modifier');\n}\n\n/**\n * Get visibility modifier text (e.g., \"pub\", \"pub(crate)\")\n */\nexport function getVisibilityModifier(node: TreeSitterNode): string | null {\n  const visNode = node.children.find(child => child.type === 'visibility_modifier');\n  return visNode !== undefined ? visNode.text : null;\n}\n\n/**\n * Check if a function is async\n */\nexport function isAsyncFunction(node: TreeSitterNode): boolean {\n  // Check for 'async' keyword in function_item or function_signature_item\n  return node.children.some(child => child.type === 'async' || child.text === 'async');\n}\n\n/**\n * Check if a function is unsafe\n */\nexport function isUnsafeFunction(node: TreeSitterNode): boolean {\n  return node.children.some(child => child.type === 'unsafe' || child.text === 'unsafe');\n}\n\n/**\n * Extract function signature including generics and parameters\n */\nexport function getFunctionSignature(node: TreeSitterNode): string {\n  // Extract the full signature by getting text from name to return type\n  const nameNode = getChildByFieldName(node, 'name');\n  const parametersNode = getChildByFieldName(node, 'parameters');\n  const returnTypeNode = getChildByFieldName(node, 'return_type');\n  const typeParametersNode = getChildByFieldName(node, 'type_parameters');\n\n  if (nameNode === null) {\n    return '';\n  }\n\n  let signature = nameNode.text;\n\n  // Add type parameters (generics)\n  if (typeParametersNode !== null) {\n    signature += typeParametersNode.text;\n  }\n\n  // Add parameters\n  if (parametersNode !== null) {\n    signature += parametersNode.text;\n  }\n\n  // Add return type\n  if (returnTypeNode !== null) {\n    signature += ' ' + returnTypeNode.text;\n  }\n\n  return signature;\n}\n\n/**\n * Query nodes of specific type from the tree\n * @param tree The tree-sitter tree\n * @param nodeType The type of nodes to find (e.g., 'function_item', 'struct_item')\n * @returns Array of matching nodes\n */\nexport function queryNodesByType(\n  tree: TreeSitterTree,\n  nodeType: string | string[]\n): TreeSitterNode[] {\n  const types = Array.isArray(nodeType) ? nodeType : [nodeType];\n  return tree.rootNode.descendantsOfType(types);\n}\n\n/**\n * Extract use statement import path\n */\nexport function extractImportPath(useNode: TreeSitterNode): string {\n  // Get the use_declaration argument\n  const argumentNode = getChildByFieldName(useNode, 'argument');\n  if (argumentNode === null) {\n    return '';\n  }\n  return argumentNode.text;\n}\n","import type { CodeNode, ImportInfo } from './ast-parser.js';\nimport {\n  parseRustCode,\n  queryNodesByType,\n  positionToLineNumber,\n  getChildByFieldName,\n  hasVisibilityModifier,\n  isAsyncFunction,\n  getFunctionSignature,\n  extractImportPath,\n  type TreeSitterNode,\n  type TreeSitterTree\n} from './tree-sitter-parser.js';\n\n/**\n * Parser for Rust code using tree-sitter\n * Extracts functions, structs, traits, types, constants, and imports\n */\nexport class RustASTParser {\n  /**\n   * Parse Rust code into CodeNode array\n   * @param code Rust source code\n   * @param filePath File path for error context\n   * @returns Array of CodeNode objects representing Rust constructs\n   */\n  parse(code: string, _filePath: string): CodeNode[] {\n    try {\n      const tree = parseRustCode(code);\n      if (tree === null) {\n        // Malformed code - return empty array\n        return [];\n      }\n\n      const nodes: CodeNode[] = [];\n\n      // Parse functions\n      const functions = this.parseFunctions(tree);\n      nodes.push(...functions);\n\n      // Parse structs\n      const structs = this.parseStructs(tree);\n      nodes.push(...structs);\n\n      // Parse traits\n      const traits = this.parseTraits(tree);\n      nodes.push(...traits);\n\n      // Parse type aliases\n      const types = this.parseTypeAliases(tree);\n      nodes.push(...types);\n\n      // Parse constants and statics\n      const constants = this.parseConstants(tree);\n      nodes.push(...constants);\n\n      // Parse impl blocks and attach methods to structs\n      this.parseImplBlocks(tree, nodes);\n\n      return nodes;\n    } catch {\n      // Return empty array for any parsing errors\n      return [];\n    }\n  }\n\n  /**\n   * Extract imports from Rust code\n   * @param code Rust source code\n   * @returns Array of ImportInfo objects\n   */\n  extractImports(code: string): ImportInfo[] {\n    try {\n      const tree = parseRustCode(code);\n      if (tree === null) {\n        return [];\n      }\n\n      const useDeclarations = queryNodesByType(tree, 'use_declaration');\n      const imports: ImportInfo[] = [];\n\n      for (const useNode of useDeclarations) {\n        const importPath = extractImportPath(useNode);\n        if (importPath === '') {\n          continue;\n        }\n\n        // Parse the import path to extract module and specifiers\n        const { source, specifiers } = this.parseImportPath(importPath);\n\n        imports.push({\n          source,\n          specifiers,\n          isType: false // Rust doesn't distinguish type-only imports at syntax level\n        });\n      }\n\n      return imports;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Parse function declarations (excluding impl block methods)\n   */\n  private parseFunctions(tree: TreeSitterTree): CodeNode[] {\n    const functionNodes = queryNodesByType(tree, 'function_item');\n    const nodes: CodeNode[] = [];\n\n    for (const fnNode of functionNodes) {\n      // Skip functions inside impl blocks - they'll be handled as methods\n      if (this.isInsideImplBlock(fnNode)) {\n        continue;\n      }\n\n      const nameNode = getChildByFieldName(fnNode, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const exported = hasVisibilityModifier(fnNode);\n      const async = isAsyncFunction(fnNode);\n      const startLine = positionToLineNumber(fnNode.startPosition);\n      const endLine = positionToLineNumber(fnNode.endPosition);\n      const signature = getFunctionSignature(fnNode);\n\n      nodes.push({\n        type: 'function',\n        name,\n        exported,\n        async,\n        startLine,\n        endLine,\n        signature\n      });\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Check if a node is inside an impl block\n   */\n  private isInsideImplBlock(node: TreeSitterNode): boolean {\n    let current = node.parent;\n    while (current !== null) {\n      if (current.type === 'impl_item') {\n        return true;\n      }\n      current = current.parent;\n    }\n    return false;\n  }\n\n  /**\n   * Parse struct definitions\n   */\n  private parseStructs(tree: TreeSitterTree): CodeNode[] {\n    const structNodes = queryNodesByType(tree, 'struct_item');\n    const nodes: CodeNode[] = [];\n\n    for (const structNode of structNodes) {\n      const nameNode = getChildByFieldName(structNode, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const exported = hasVisibilityModifier(structNode);\n      const startLine = positionToLineNumber(structNode.startPosition);\n      const endLine = positionToLineNumber(structNode.endPosition);\n\n      // Get type parameters (generics) if present\n      const typeParamsNode = getChildByFieldName(structNode, 'type_parameters');\n      const signature = typeParamsNode !== null\n        ? `${name}${typeParamsNode.text}`\n        : name;\n\n      nodes.push({\n        type: 'class',\n        name,\n        exported,\n        startLine,\n        endLine,\n        signature,\n        methods: [] // Will be populated by parseImplBlocks\n      });\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Parse trait definitions\n   */\n  private parseTraits(tree: TreeSitterTree): CodeNode[] {\n    const traitNodes = queryNodesByType(tree, 'trait_item');\n    const nodes: CodeNode[] = [];\n\n    for (const traitNode of traitNodes) {\n      const nameNode = getChildByFieldName(traitNode, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const exported = hasVisibilityModifier(traitNode);\n      const startLine = positionToLineNumber(traitNode.startPosition);\n      const endLine = positionToLineNumber(traitNode.endPosition);\n\n      // Get type parameters (generics) if present\n      const typeParamsNode = getChildByFieldName(traitNode, 'type_parameters');\n      const signature = typeParamsNode !== null\n        ? `${name}${typeParamsNode.text}`\n        : name;\n\n      // Extract trait methods\n      const methods = this.extractTraitMethods(traitNode);\n\n      nodes.push({\n        type: 'interface',\n        name,\n        exported,\n        startLine,\n        endLine,\n        signature,\n        methods\n      });\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Parse type aliases\n   */\n  private parseTypeAliases(tree: TreeSitterTree): CodeNode[] {\n    const typeNodes = queryNodesByType(tree, 'type_item');\n    const nodes: CodeNode[] = [];\n\n    for (const typeNode of typeNodes) {\n      const nameNode = getChildByFieldName(typeNode, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const exported = hasVisibilityModifier(typeNode);\n      const startLine = positionToLineNumber(typeNode.startPosition);\n      const endLine = positionToLineNumber(typeNode.endPosition);\n\n      // Get the full type alias definition\n      const valueNode = getChildByFieldName(typeNode, 'type');\n      const signature = valueNode !== null\n        ? `${name} = ${valueNode.text}`\n        : name;\n\n      nodes.push({\n        type: 'type',\n        name,\n        exported,\n        startLine,\n        endLine,\n        signature\n      });\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Parse constants and statics\n   */\n  private parseConstants(tree: TreeSitterTree): CodeNode[] {\n    const constNodes = queryNodesByType(tree, ['const_item', 'static_item']);\n    const nodes: CodeNode[] = [];\n\n    for (const constNode of constNodes) {\n      const nameNode = getChildByFieldName(constNode, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const exported = hasVisibilityModifier(constNode);\n      const startLine = positionToLineNumber(constNode.startPosition);\n      const endLine = positionToLineNumber(constNode.endPosition);\n\n      // Get type annotation\n      const typeNode = getChildByFieldName(constNode, 'type');\n      const signature = typeNode !== null\n        ? `${name}: ${typeNode.text}`\n        : name;\n\n      nodes.push({\n        type: 'const',\n        name,\n        exported,\n        startLine,\n        endLine,\n        signature\n      });\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Parse impl blocks and attach methods to corresponding structs\n   */\n  private parseImplBlocks(tree: TreeSitterTree, nodes: CodeNode[]): void {\n    const implNodes = queryNodesByType(tree, 'impl_item');\n\n    for (const implNode of implNodes) {\n      // Get the type being implemented\n      const typeNode = getChildByFieldName(implNode, 'type');\n      if (typeNode === null) {\n        continue;\n      }\n\n      const typeName = typeNode.text;\n\n      // Extract methods from impl block\n      const methods = this.extractImplMethods(implNode);\n\n      // Find the corresponding struct and attach methods\n      const structNode = nodes.find(\n        node => node.type === 'class' && node.name === typeName\n      );\n\n      if (structNode !== undefined && structNode.methods !== undefined) {\n        structNode.methods.push(...methods);\n      }\n    }\n  }\n\n  /**\n   * Extract methods from trait definition\n   */\n  private extractTraitMethods(traitNode: TreeSitterNode): Array<{\n    name: string;\n    async: boolean;\n    signature: string;\n    startLine: number;\n    endLine: number;\n  }> {\n    const methods: Array<{\n      name: string;\n      async: boolean;\n      signature: string;\n      startLine: number;\n      endLine: number;\n    }> = [];\n\n    // Get declaration_list (trait body)\n    const bodyNode = getChildByFieldName(traitNode, 'body');\n    if (bodyNode === null) {\n      return methods;\n    }\n\n    // Find all function_signature_item nodes (trait method declarations)\n    const functionSignatures = bodyNode.descendantsOfType('function_signature_item');\n\n    for (const fnSigNode of functionSignatures) {\n      const nameNode = getChildByFieldName(fnSigNode, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const async = isAsyncFunction(fnSigNode);\n      const signature = getFunctionSignature(fnSigNode);\n      const startLine = positionToLineNumber(fnSigNode.startPosition);\n      const endLine = positionToLineNumber(fnSigNode.endPosition);\n\n      methods.push({\n        name,\n        async,\n        signature,\n        startLine,\n        endLine\n      });\n    }\n\n    return methods;\n  }\n\n  /**\n   * Extract methods from impl block\n   */\n  private extractImplMethods(implNode: TreeSitterNode): Array<{\n    name: string;\n    async: boolean;\n    signature: string;\n    startLine: number;\n    endLine: number;\n  }> {\n    const methods: Array<{\n      name: string;\n      async: boolean;\n      signature: string;\n      startLine: number;\n      endLine: number;\n    }> = [];\n\n    // Get declaration_list (impl body)\n    const bodyNode = getChildByFieldName(implNode, 'body');\n    if (bodyNode === null) {\n      return methods;\n    }\n\n    // Find all function_item nodes (impl methods)\n    const functionItems = bodyNode.descendantsOfType('function_item');\n\n    for (const fnNode of functionItems) {\n      const nameNode = getChildByFieldName(fnNode, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const async = isAsyncFunction(fnNode);\n      const signature = getFunctionSignature(fnNode);\n      const startLine = positionToLineNumber(fnNode.startPosition);\n      const endLine = positionToLineNumber(fnNode.endPosition);\n\n      methods.push({\n        name,\n        async,\n        signature,\n        startLine,\n        endLine\n      });\n    }\n\n    return methods;\n  }\n\n  /**\n   * Parse import path into source and specifiers\n   * Examples:\n   * - \"std::collections::HashMap\" -> { source: \"std::collections\", specifiers: [\"HashMap\"] }\n   * - \"crate::utils::*\" -> { source: \"crate::utils\", specifiers: [\"*\"] }\n   * - \"super::Type\" -> { source: \"super\", specifiers: [\"Type\"] }\n   */\n  private parseImportPath(importPath: string): { source: string; specifiers: string[] } {\n    // Remove whitespace\n    const path = importPath.trim();\n\n    // Handle glob imports (use std::io::*)\n    if (path.includes('::*')) {\n      const source = path.replace('::*', '');\n      return { source, specifiers: ['*'] };\n    }\n\n    // Handle scoped imports: use std::io::{Read, Write}\n    const scopedMatch = path.match(/^(.+)::\\{(.+)\\}$/);\n    if (scopedMatch !== null) {\n      const source = scopedMatch[1] ?? '';\n      const specifiersStr = scopedMatch[2] ?? '';\n      const specifiers = specifiersStr.split(',').map(s => s.trim());\n      return { source, specifiers };\n    }\n\n    // Handle simple imports: use std::collections::HashMap\n    const parts = path.split('::');\n    if (parts.length > 1) {\n      const specifiers = [parts[parts.length - 1] ?? ''];\n      const source = parts.slice(0, -1).join('::');\n      return { source, specifiers };\n    }\n\n    // Single item import\n    return { source: '', specifiers: [path] };\n  }\n}\n","import type { CodeNode, ImportInfo } from './ast-parser.js';\nimport {\n  parseGoCode,\n  queryNodesByType,\n  positionToLineNumber,\n  getChildByFieldName,\n  getFunctionSignature,\n  getFirstChildOfType,\n  type TreeSitterNode,\n  type TreeSitterTree\n} from './tree-sitter-parser.js';\n\n/**\n * Parser for Go code using tree-sitter\n * Extracts functions, methods, structs, interfaces, types, constants, and imports\n */\nexport class GoASTParser {\n  /**\n   * Parse Go code into CodeNode array\n   * @param code Go source code\n   * @param filePath File path for error context\n   * @returns Array of CodeNode objects representing Go constructs\n   */\n  parse(code: string, _filePath: string): CodeNode[] {\n    try {\n      const tree = parseGoCode(code);\n      if (tree === null) {\n        // Malformed code - return empty array\n        return [];\n      }\n\n      const nodes: CodeNode[] = [];\n\n      // Parse functions\n      const functions = this.parseFunctions(tree);\n      nodes.push(...functions);\n\n      // Parse structs\n      const structs = this.parseStructs(tree);\n      nodes.push(...structs);\n\n      // Parse interfaces\n      const interfaces = this.parseInterfaces(tree);\n      nodes.push(...interfaces);\n\n      // Parse type aliases\n      const types = this.parseTypeAliases(tree);\n      nodes.push(...types);\n\n      // Parse constants and variables\n      const constants = this.parseConstants(tree);\n      nodes.push(...constants);\n\n      // Parse methods and attach to structs\n      this.parseMethods(tree, nodes);\n\n      return nodes;\n    } catch {\n      // Return empty array for any parsing errors\n      return [];\n    }\n  }\n\n  /**\n   * Extract imports from Go code\n   * @param code Go source code\n   * @returns Array of ImportInfo objects\n   */\n  extractImports(code: string): ImportInfo[] {\n    try {\n      const tree = parseGoCode(code);\n      if (tree === null) {\n        return [];\n      }\n\n      const imports: ImportInfo[] = [];\n      const importDecls = queryNodesByType(tree, 'import_declaration');\n\n      for (const importDecl of importDecls) {\n        const importSpecs = importDecl.descendantsOfType('import_spec');\n\n        for (const spec of importSpecs) {\n          const pathNode = getChildByFieldName(spec, 'path');\n          if (pathNode === null) {\n            continue;\n          }\n\n          // Extract string content from interpreted_string_literal\n          const stringContent = pathNode.descendantsOfType('interpreted_string_literal_content')[0];\n          const path = stringContent !== undefined ? stringContent.text : pathNode.text.replace(/\"/g, '');\n\n          if (path !== '') {\n            imports.push({\n              source: path,\n              specifiers: [],\n              isType: false\n            });\n          }\n        }\n      }\n\n      return imports;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Parse function declarations\n   */\n  private parseFunctions(tree: TreeSitterTree): CodeNode[] {\n    const functionNodes = queryNodesByType(tree, 'function_declaration');\n    const nodes: CodeNode[] = [];\n\n    for (const fnNode of functionNodes) {\n      const nameNode = getChildByFieldName(fnNode, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const exported = this.isExported(name);\n      const startLine = positionToLineNumber(fnNode.startPosition);\n      const endLine = positionToLineNumber(fnNode.endPosition);\n      const signature = getFunctionSignature(fnNode);\n\n      nodes.push({\n        type: 'function',\n        name,\n        exported,\n        async: false,\n        startLine,\n        endLine,\n        signature\n      });\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Parse struct definitions\n   */\n  private parseStructs(tree: TreeSitterTree): CodeNode[] {\n    const typeDecls = queryNodesByType(tree, 'type_declaration');\n    const nodes: CodeNode[] = [];\n\n    for (const typeDecl of typeDecls) {\n      // Get type_spec child node\n      const typeSpec = getFirstChildOfType(typeDecl, 'type_spec');\n      if (typeSpec === null) {\n        continue;\n      }\n\n      const nameNode = getChildByFieldName(typeSpec, 'name');\n      const typeNode = getChildByFieldName(typeSpec, 'type');\n\n      if (nameNode === null || typeNode === null) {\n        continue;\n      }\n\n      // Check if it's a struct type\n      if (typeNode.type !== 'struct_type') {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const exported = this.isExported(name);\n      const startLine = positionToLineNumber(typeDecl.startPosition);\n      const endLine = positionToLineNumber(typeDecl.endPosition);\n\n      nodes.push({\n        type: 'class',\n        name,\n        exported,\n        startLine,\n        endLine,\n        signature: name,\n        methods: []\n      });\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Parse interface definitions\n   */\n  private parseInterfaces(tree: TreeSitterTree): CodeNode[] {\n    const typeDecls = queryNodesByType(tree, 'type_declaration');\n    const nodes: CodeNode[] = [];\n\n    for (const typeDecl of typeDecls) {\n      const typeSpec = getFirstChildOfType(typeDecl, 'type_spec');\n      if (typeSpec === null) {\n        continue;\n      }\n\n      const nameNode = getChildByFieldName(typeSpec, 'name');\n      const typeNode = getChildByFieldName(typeSpec, 'type');\n\n      if (nameNode === null || typeNode === null) {\n        continue;\n      }\n\n      // Check if it's an interface type\n      if (typeNode.type !== 'interface_type') {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const exported = this.isExported(name);\n      const startLine = positionToLineNumber(typeDecl.startPosition);\n      const endLine = positionToLineNumber(typeDecl.endPosition);\n\n      // Extract interface methods\n      const methods = this.extractInterfaceMethods(typeNode);\n\n      nodes.push({\n        type: 'interface',\n        name,\n        exported,\n        startLine,\n        endLine,\n        signature: name,\n        methods\n      });\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Parse type aliases\n   */\n  private parseTypeAliases(tree: TreeSitterTree): CodeNode[] {\n    const typeDecls = queryNodesByType(tree, 'type_declaration');\n    const nodes: CodeNode[] = [];\n\n    for (const typeDecl of typeDecls) {\n      const typeSpec = getFirstChildOfType(typeDecl, 'type_spec');\n      if (typeSpec === null) {\n        continue;\n      }\n\n      const nameNode = getChildByFieldName(typeSpec, 'name');\n      const typeNode = getChildByFieldName(typeSpec, 'type');\n\n      if (nameNode === null || typeNode === null) {\n        continue;\n      }\n\n      // Skip struct and interface types (handled by other methods)\n      if (typeNode.type === 'struct_type' || typeNode.type === 'interface_type') {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const exported = this.isExported(name);\n      const startLine = positionToLineNumber(typeDecl.startPosition);\n      const endLine = positionToLineNumber(typeDecl.endPosition);\n      const signature = `${name} = ${typeNode.text}`;\n\n      nodes.push({\n        type: 'type',\n        name,\n        exported,\n        startLine,\n        endLine,\n        signature\n      });\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Parse constants and variables\n   */\n  private parseConstants(tree: TreeSitterTree): CodeNode[] {\n    const nodes: CodeNode[] = [];\n\n    // Parse const declarations\n    const constDecls = queryNodesByType(tree, 'const_declaration');\n    for (const constDecl of constDecls) {\n      const specs = constDecl.descendantsOfType('const_spec');\n      for (const spec of specs) {\n        const nameNode = getChildByFieldName(spec, 'name');\n        if (nameNode === null) {\n          continue;\n        }\n\n        const name = nameNode.text;\n        const exported = this.isExported(name);\n        const startLine = positionToLineNumber(spec.startPosition);\n        const endLine = positionToLineNumber(spec.endPosition);\n\n        const typeNode = getChildByFieldName(spec, 'type');\n        const signature = typeNode !== null\n          ? `${name}: ${typeNode.text}`\n          : name;\n\n        nodes.push({\n          type: 'const',\n          name,\n          exported,\n          startLine,\n          endLine,\n          signature\n        });\n      }\n    }\n\n    // Parse var declarations\n    const varDecls = queryNodesByType(tree, 'var_declaration');\n    for (const varDecl of varDecls) {\n      const specs = varDecl.descendantsOfType('var_spec');\n      for (const spec of specs) {\n        const nameNode = getChildByFieldName(spec, 'name');\n        if (nameNode === null) {\n          continue;\n        }\n\n        const name = nameNode.text;\n        const exported = this.isExported(name);\n        const startLine = positionToLineNumber(spec.startPosition);\n        const endLine = positionToLineNumber(spec.endPosition);\n\n        const typeNode = getChildByFieldName(spec, 'type');\n        const signature = typeNode !== null\n          ? `${name}: ${typeNode.text}`\n          : name;\n\n        nodes.push({\n          type: 'const',\n          name,\n          exported,\n          startLine,\n          endLine,\n          signature\n        });\n      }\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Parse methods and attach to corresponding structs\n   */\n  private parseMethods(tree: TreeSitterTree, nodes: CodeNode[]): void {\n    const methodNodes = queryNodesByType(tree, 'method_declaration');\n\n    for (const methodNode of methodNodes) {\n      const receiverType = this.getReceiverType(methodNode);\n      if (receiverType === null) {\n        continue;\n      }\n\n      const nameNode = getChildByFieldName(methodNode, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const signature = getFunctionSignature(methodNode);\n      const startLine = positionToLineNumber(methodNode.startPosition);\n      const endLine = positionToLineNumber(methodNode.endPosition);\n\n      // Find the corresponding struct and attach method\n      const structNode = nodes.find(\n        node => node.type === 'class' && node.name === receiverType\n      );\n\n      if (structNode !== undefined && structNode.methods !== undefined) {\n        structNode.methods.push({\n          name,\n          async: false,\n          signature,\n          startLine,\n          endLine\n        });\n      }\n    }\n  }\n\n  /**\n   * Extract methods from interface definition\n   */\n  private extractInterfaceMethods(interfaceNode: TreeSitterNode): Array<{\n    name: string;\n    async: boolean;\n    signature: string;\n    startLine: number;\n    endLine: number;\n  }> {\n    const methods: Array<{\n      name: string;\n      async: boolean;\n      signature: string;\n      startLine: number;\n      endLine: number;\n    }> = [];\n\n    const methodElems = interfaceNode.descendantsOfType('method_elem');\n\n    for (const methodElem of methodElems) {\n      const nameNode = getChildByFieldName(methodElem, 'name');\n      if (nameNode === null) {\n        continue;\n      }\n\n      const name = nameNode.text;\n      const signature = getFunctionSignature(methodElem);\n      const startLine = positionToLineNumber(methodElem.startPosition);\n      const endLine = positionToLineNumber(methodElem.endPosition);\n\n      methods.push({\n        name,\n        async: false,\n        signature,\n        startLine,\n        endLine\n      });\n    }\n\n    return methods;\n  }\n\n  /**\n   * Get the receiver type name for a method\n   */\n  private getReceiverType(methodNode: TreeSitterNode): string | null {\n    const receiverNode = getChildByFieldName(methodNode, 'receiver');\n    if (receiverNode === null) {\n      return null;\n    }\n\n    const paramDecl = getFirstChildOfType(receiverNode, 'parameter_declaration');\n    if (paramDecl === null) {\n      return null;\n    }\n\n    const typeNode = getChildByFieldName(paramDecl, 'type');\n    if (typeNode === null) {\n      return null;\n    }\n\n    // Handle pointer receivers (*Type)\n    if (typeNode.type === 'pointer_type') {\n      const innerType = typeNode.children.find(\n        child => child.type === 'type_identifier'\n      );\n      return innerType !== undefined ? innerType.text : null;\n    }\n\n    // Handle value receivers (Type)\n    if (typeNode.type === 'type_identifier') {\n      return typeNode.text;\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if a name is exported (starts with uppercase letter)\n   */\n  private isExported(name: string): boolean {\n    if (name.length === 0) {\n      return false;\n    }\n    const firstChar = name[0];\n    if (firstChar === undefined) {\n      return false;\n    }\n    return firstChar === firstChar.toUpperCase();\n  }\n}\n","import path from 'node:path';\nimport type { PythonBridge } from '../crawl/bridge.js';\nimport { ASTParser, type CodeNode } from './ast-parser.js';\nimport { PythonASTParser } from './python-ast-parser.js';\nimport { RustASTParser } from './rust-ast-parser.js';\nimport { GoASTParser } from './go-ast-parser.js';\n\nexport class ParserFactory {\n  constructor(private readonly pythonBridge?: PythonBridge) {}\n\n  async parseFile(filePath: string, code: string): Promise<CodeNode[]> {\n    const ext = path.extname(filePath);\n\n    if (['.ts', '.tsx'].includes(ext)) {\n      const parser = new ASTParser();\n      return parser.parse(code, 'typescript');\n    }\n\n    if (['.js', '.jsx'].includes(ext)) {\n      const parser = new ASTParser();\n      return parser.parse(code, 'javascript');\n    }\n\n    if (ext === '.py') {\n      if (!this.pythonBridge) {\n        throw new Error('Python bridge not available for parsing Python files');\n      }\n      const parser = new PythonASTParser(this.pythonBridge);\n      return await parser.parse(code, filePath);\n    }\n\n    if (ext === '.rs') {\n      const parser = new RustASTParser();\n      return parser.parse(code, filePath);\n    }\n\n    if (ext === '.go') {\n      const parser = new GoASTParser();\n      return parser.parse(code, filePath);\n    }\n\n    return [];\n  }\n}\n","import type { PythonBridge, ParsePythonResult } from '../crawl/bridge.js';\nimport type { CodeNode } from './ast-parser.js';\n\nexport class PythonASTParser {\n  constructor(private readonly bridge: PythonBridge) {}\n\n  async parse(code: string, filePath: string): Promise<CodeNode[]> {\n    const result: ParsePythonResult = await this.bridge.parsePython(code, filePath);\n\n    return result.nodes.map(node => {\n      const codeNode: CodeNode = {\n        type: node.type,\n        name: node.name,\n        exported: node.exported,\n        startLine: node.startLine,\n        endLine: node.endLine,\n      };\n\n      if (node.async !== undefined) {\n        codeNode.async = node.async;\n      }\n\n      if (node.signature !== undefined) {\n        codeNode.signature = node.signature;\n      }\n\n      if (node.methods !== undefined) {\n        codeNode.methods = node.methods;\n      }\n\n      return codeNode;\n    });\n  }\n}\n","import * as lancedb from '@lancedb/lancedb';\nimport type { Table, Connection } from '@lancedb/lancedb';\nimport type { Document, DocumentMetadata } from '../types/document.js';\nimport type { StoreId, DocumentId } from '../types/brands.js';\nimport { createDocumentId } from '../types/brands.js';\n\ninterface LanceDocument {\n  id: string;\n  content: string;\n  vector: number[];\n  metadata: string; // JSON serialized\n  [key: string]: unknown;\n}\n\ninterface SearchHit {\n  id: string;\n  content: string;\n  metadata: string;\n  _distance: number;\n}\n\nexport class LanceStore {\n  private connection: Connection | null = null;\n  private readonly tables: Map<string, Table> = new Map();\n  private readonly dataDir: string;\n\n  constructor(dataDir: string) {\n    this.dataDir = dataDir;\n  }\n\n  async initialize(storeId: StoreId): Promise<void> {\n    if (this.connection === null) {\n      this.connection = await lancedb.connect(this.dataDir);\n    }\n\n    const tableName = this.getTableName(storeId);\n    const tableNames = await this.connection.tableNames();\n\n    if (!tableNames.includes(tableName)) {\n      // Create table with initial schema\n      const table = await this.connection.createTable(tableName, [\n        {\n          id: '__init__',\n          content: '',\n          vector: new Array(384).fill(0),\n          metadata: '{}',\n        },\n      ]);\n      // Delete the init row\n      await table.delete('id = \"__init__\"');\n      this.tables.set(tableName, table);\n    } else {\n      const table = await this.connection.openTable(tableName);\n      this.tables.set(tableName, table);\n    }\n  }\n\n  async addDocuments(storeId: StoreId, documents: Document[]): Promise<void> {\n    const table = await this.getTable(storeId);\n    const lanceDocuments: LanceDocument[] = documents.map((doc) => ({\n      id: doc.id,\n      content: doc.content,\n      vector: [...doc.vector],\n      metadata: JSON.stringify(doc.metadata),\n    }));\n    await table.add(lanceDocuments);\n  }\n\n  async deleteDocuments(storeId: StoreId, documentIds: DocumentId[]): Promise<void> {\n    const table = await this.getTable(storeId);\n    const idList = documentIds.map((id) => `\"${id}\"`).join(', ');\n    await table.delete(`id IN (${idList})`);\n  }\n\n  async search(\n    storeId: StoreId,\n    vector: number[],\n    limit: number,\n    threshold?: number\n  ): Promise<Array<{ id: DocumentId; content: string; score: number; metadata: DocumentMetadata }>> {\n    const table = await this.getTable(storeId);\n    let query = table.vectorSearch(vector).limit(limit);\n\n    if (threshold !== undefined) {\n      query = query.distanceType('cosine');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    const results = (await query.toArray()) as SearchHit[];\n\n    return results\n      .filter((r) => {\n        if (threshold === undefined) return true;\n        const score = 1 - r._distance;\n        return score >= threshold;\n      })\n      .map((r) => ({\n        id: createDocumentId(r.id),\n        content: r.content,\n        score: 1 - r._distance,\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        metadata: JSON.parse(r.metadata) as DocumentMetadata,\n      }));\n  }\n\n  async createFtsIndex(storeId: StoreId): Promise<void> {\n    const table = await this.getTable(storeId);\n    await table.createIndex('content', {\n      config: lancedb.Index.fts(),\n    });\n  }\n\n  async fullTextSearch(\n    storeId: StoreId,\n    query: string,\n    limit: number\n  ): Promise<Array<{ id: DocumentId; content: string; score: number; metadata: DocumentMetadata }>> {\n    const table = await this.getTable(storeId);\n\n    try {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      const results = await table\n        .search(query, 'fts')\n        .limit(limit)\n        .toArray() as Array<{ id: string; content: string; metadata: string; score: number }>;\n\n      return results.map((r) => ({\n        id: createDocumentId(r.id),\n        content: r.content,\n        score: r.score,\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        metadata: JSON.parse(r.metadata) as DocumentMetadata,\n      }));\n    } catch {\n      // FTS index may not exist, return empty\n      return [];\n    }\n  }\n\n  async deleteStore(storeId: StoreId): Promise<void> {\n    const tableName = this.getTableName(storeId);\n    if (this.connection !== null) {\n      await this.connection.dropTable(tableName);\n      this.tables.delete(tableName);\n    }\n  }\n\n  private getTableName(storeId: StoreId): string {\n    return `documents_${storeId}`;\n  }\n\n  private async getTable(storeId: StoreId): Promise<Table> {\n    const tableName = this.getTableName(storeId);\n    let table = this.tables.get(tableName);\n    if (table === undefined) {\n      await this.initialize(storeId);\n      table = this.tables.get(tableName);\n    }\n    if (table === undefined) {\n      throw new Error(`Table not found for store: ${storeId}`);\n    }\n    return table;\n  }\n}\n","import { pipeline, type FeatureExtractionPipeline } from '@huggingface/transformers';\n\nexport class EmbeddingEngine {\n  private extractor: FeatureExtractionPipeline | null = null;\n  private readonly modelName: string;\n  private readonly dimensions: number;\n\n  constructor(modelName = 'Xenova/all-MiniLM-L6-v2', dimensions = 384) {\n    this.modelName = modelName;\n    this.dimensions = dimensions;\n  }\n\n  async initialize(): Promise<void> {\n    if (this.extractor !== null) return;\n    // @ts-expect-error TS2590: TypeScript can't represent the complex union type from pipeline()\n    // This is a known limitation with @huggingface/transformers overloaded signatures\n    this.extractor = await pipeline('feature-extraction', this.modelName, {\n      dtype: 'fp32',\n    });\n  }\n\n  async embed(text: string): Promise<number[]> {\n    if (this.extractor === null) {\n      await this.initialize();\n    }\n    if (this.extractor === null) {\n      throw new Error('Failed to initialize embedding model');\n    }\n    const output = await this.extractor(text, {\n      pooling: 'mean',\n      normalize: true,\n    });\n    const result = Array.from(output.data);\n    return result.map(v => Number(v));\n  }\n\n  async embedBatch(texts: string[]): Promise<number[][]> {\n    const BATCH_SIZE = 32; // Process 32 chunks in parallel\n    const results: number[][] = [];\n\n    for (let i = 0; i < texts.length; i += BATCH_SIZE) {\n      const batch = texts.slice(i, i + BATCH_SIZE);\n\n      // Process batch in parallel using Promise.all\n      const batchResults = await Promise.all(\n        batch.map(text => this.embed(text))\n      );\n\n      results.push(...batchResults);\n\n      // Small delay between batches to prevent memory issues\n      if (i + BATCH_SIZE < texts.length) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n    }\n\n    return results;\n  }\n\n  getDimensions(): number {\n    return this.dimensions;\n  }\n}\n","import { spawn, type ChildProcess } from 'node:child_process';\nimport { createInterface } from 'node:readline';\nimport { randomUUID } from 'node:crypto';\nimport { ZodError } from 'zod';\nimport {\n  type CrawlResult,\n  type HeadlessResult,\n  type ParsePythonResult,\n  type CrawledLink,\n  validateCrawlResult,\n  validateHeadlessResult,\n  validateParsePythonResult,\n} from './schemas.js';\n\n// Re-export for backwards compatibility\nexport type { CrawledLink, ParsePythonResult };\n\ntype PendingResult = CrawlResult | HeadlessResult | ParsePythonResult;\n\ninterface PendingRequest {\n  resolve: (v: PendingResult) => void;\n  reject: (e: Error) => void;\n  timeout: NodeJS.Timeout;\n  method: 'crawl' | 'fetch_headless' | 'parse_python';\n}\n\nexport class PythonBridge {\n  private process: ChildProcess | null = null;\n  private readonly pending: Map<string, PendingRequest> = new Map();\n\n  start(): Promise<void> {\n    if (this.process) return Promise.resolve();\n\n    this.process = spawn('python3', ['python/crawl_worker.py'], {\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n\n    // Add error handler for process spawn errors\n    this.process.on('error', (err) => {\n      console.error('Python bridge process error:', err);\n      this.rejectAllPending(new Error(`Process error: ${err.message}`));\n    });\n\n    // Add exit handler to detect non-zero exits\n    this.process.on('exit', (code, signal) => {\n      if (code !== 0 && code !== null) {\n        console.error(`Python bridge process exited with code ${String(code)}`);\n        this.rejectAllPending(new Error(`Process exited with code ${String(code)}`));\n      } else if (signal) {\n        console.error(`Python bridge process killed with signal ${signal}`);\n        this.rejectAllPending(new Error(`Process killed with signal ${signal}`));\n      }\n      this.process = null;\n    });\n\n    // Add stderr logging\n    if (this.process.stderr) {\n      const stderrRl = createInterface({ input: this.process.stderr });\n      stderrRl.on('line', (line) => {\n        console.error('Python bridge stderr:', line);\n      });\n    }\n\n    if (this.process.stdout === null) {\n      this.process = null;  // Clean up partial state\n      return Promise.reject(new Error('Python bridge process stdout is null'));\n    }\n    const rl = createInterface({ input: this.process.stdout });\n    rl.on('line', (line) => {\n      // Filter out non-JSON lines (crawl4ai verbose output)\n      if (!line.trim().startsWith('{')) {\n        return;\n      }\n\n      try {\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        const response = JSON.parse(line) as {\n          id: string;\n          error?: { message: string };\n          result?: PendingResult;\n        };\n        const pending = this.pending.get(response.id);\n        if (pending !== undefined) {\n          if (response.error !== undefined) {\n            clearTimeout(pending.timeout);\n            this.pending.delete(response.id);\n            pending.reject(new Error(response.error.message));\n          } else if (response.result !== undefined) {\n            clearTimeout(pending.timeout);\n            this.pending.delete(response.id);\n\n            // Validate response structure based on method type\n            try {\n              let validated: PendingResult;\n              if (pending.method === 'crawl') {\n                validated = validateCrawlResult(response.result);\n              } else if (pending.method === 'fetch_headless') {\n                validated = validateHeadlessResult(response.result);\n              } else {\n                validated = validateParsePythonResult(response.result);\n              }\n              pending.resolve(validated);\n            } catch (error: unknown) {\n              // Log validation failure with original response for debugging\n              if (error instanceof ZodError) {\n                console.error('Python bridge response validation failed:', error.issues);\n                console.error('Original response:', JSON.stringify(response.result));\n                pending.reject(new Error(`Invalid response format from Python bridge: ${error.message}`));\n              } else {\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                pending.reject(new Error(`Response validation error: ${errorMessage}`));\n              }\n            }\n          }\n          // If neither result nor error, leave pending (will timeout)\n        }\n      } catch (err) {\n        console.error('Failed to parse JSON response from Python bridge:', err, 'Line:', line);\n      }\n    });\n\n    return Promise.resolve();\n  }\n\n  async crawl(url: string, timeoutMs: number = 30000): Promise<CrawlResult> {\n    if (!this.process) await this.start();\n\n    const id = randomUUID();\n    const request = {\n      jsonrpc: '2.0',\n      id,\n      method: 'crawl',\n      params: { url },\n    };\n\n    return new Promise((resolve, reject) => {\n      // Set up timeout\n      const timeout = setTimeout(() => {\n        const pending = this.pending.get(id);\n        if (pending) {\n          this.pending.delete(id);\n          reject(new Error(`Crawl timeout after ${String(timeoutMs)}ms for URL: ${url}`));\n        }\n      }, timeoutMs);\n\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      this.pending.set(id, { resolve: resolve as (v: PendingResult) => void, reject, timeout, method: 'crawl' });\n      if (this.process === null || this.process.stdin === null) {\n        reject(new Error('Python bridge process not available'));\n        return;\n      }\n      this.process.stdin.write(JSON.stringify(request) + '\\n');\n    });\n  }\n\n  async fetchHeadless(url: string, timeoutMs: number = 60000): Promise<HeadlessResult> {\n    if (!this.process) await this.start();\n\n    const id = randomUUID();\n    const request = {\n      jsonrpc: '2.0',\n      id,\n      method: 'fetch_headless',\n      params: { url },\n    };\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const pending = this.pending.get(id);\n        if (pending) {\n          this.pending.delete(id);\n          reject(new Error(`Headless fetch timeout after ${String(timeoutMs)}ms for URL: ${url}`));\n        }\n      }, timeoutMs);\n\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      this.pending.set(id, { resolve: resolve as (v: PendingResult) => void, reject, timeout, method: 'fetch_headless' });\n      if (this.process === null || this.process.stdin === null) {\n        reject(new Error('Python bridge process not available'));\n        return;\n      }\n      this.process.stdin.write(JSON.stringify(request) + '\\n');\n    });\n  }\n\n  async parsePython(code: string, filePath: string, timeoutMs: number = 10000): Promise<ParsePythonResult> {\n    if (!this.process) await this.start();\n\n    const id = randomUUID();\n    const request = {\n      jsonrpc: '2.0',\n      id,\n      method: 'parse_python',\n      params: { code, filePath },\n    };\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const pending = this.pending.get(id);\n        if (pending) {\n          this.pending.delete(id);\n          reject(new Error(`Python parsing timeout after ${String(timeoutMs)}ms for file: ${filePath}`));\n        }\n      }, timeoutMs);\n\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      this.pending.set(id, { resolve: resolve as (v: PendingResult) => void, reject, timeout, method: 'parse_python' });\n      if (this.process === null || this.process.stdin === null) {\n        reject(new Error('Python bridge process not available'));\n        return;\n      }\n      this.process.stdin.write(JSON.stringify(request) + '\\n');\n    });\n  }\n\n  stop(): Promise<void> {\n    if (this.process) {\n      this.rejectAllPending(new Error('Python bridge stopped'));\n      this.process.kill();\n      this.process = null;\n    }\n    return Promise.resolve();\n  }\n\n  private rejectAllPending(error: Error): void {\n    for (const pending of this.pending.values()) {\n      clearTimeout(pending.timeout);\n      pending.reject(error);\n    }\n    this.pending.clear();\n  }\n}\n","import { z } from 'zod';\n\n// Schema for crawl4ai link objects (matches CrawledLink interface)\n// This validates the actual runtime structure from Python\nexport const CrawledLinkSchema = z.object({\n  href: z.string(),\n  text: z.string(),\n  title: z.string().optional(),\n  base_domain: z.string().optional(),\n  head_data: z.unknown().optional(),\n  head_extraction_status: z.unknown().optional(),\n  head_extraction_error: z.unknown().optional(),\n  intrinsic_score: z.number().optional(),\n  contextual_score: z.unknown().optional(),\n  total_score: z.unknown().optional(),\n});\n\n// Schema for individual crawl page result\nconst CrawlPageSchema = z.object({\n  url: z.string(),\n  title: z.string(),\n  content: z.string(),\n  links: z.array(z.string()),\n  crawledAt: z.string(),\n});\n\n// Schema for full crawl response\nexport const CrawlResultSchema = z.object({\n  pages: z.array(CrawlPageSchema),\n});\n\n// Schema for headless fetch response\n// Supports both link objects and plain strings\nexport const HeadlessResultSchema = z.object({\n  html: z.string(),\n  markdown: z.string(),\n  links: z.array(z.union([CrawledLinkSchema, z.string()])),\n});\n\n// Type exports derived from schemas (single source of truth)\nexport type CrawlResult = z.infer<typeof CrawlResultSchema>;\nexport type HeadlessResult = z.infer<typeof HeadlessResultSchema>;\nexport type CrawledLink = z.infer<typeof CrawledLinkSchema>;\n\n/**\n * Validates a headless fetch response from Python bridge.\n * Throws ZodError if the response doesn't match the expected schema.\n *\n * @param data - Raw data from Python bridge\n * @returns Validated HeadlessResult\n * @throws {z.ZodError} If validation fails\n */\nexport function validateHeadlessResult(data: unknown): HeadlessResult {\n  return HeadlessResultSchema.parse(data);\n}\n\n/**\n * Validates a crawl response from Python bridge.\n * Throws ZodError if the response doesn't match the expected schema.\n *\n * @param data - Raw data from Python bridge\n * @returns Validated CrawlResult\n * @throws {z.ZodError} If validation fails\n */\nexport function validateCrawlResult(data: unknown): CrawlResult {\n  return CrawlResultSchema.parse(data);\n}\n\n// Schema for Python AST parsing response\nconst MethodInfoSchema = z.object({\n  name: z.string(),\n  async: z.boolean(),\n  signature: z.string(),\n  startLine: z.number(),\n  endLine: z.number(),\n  calls: z.array(z.string()),\n});\n\nconst CodeNodeSchema = z.object({\n  type: z.enum(['function', 'class']),\n  name: z.string(),\n  exported: z.boolean(),\n  startLine: z.number(),\n  endLine: z.number(),\n  async: z.boolean().optional(),\n  signature: z.string().optional(),\n  calls: z.array(z.string()).optional(),\n  methods: z.array(MethodInfoSchema).optional(),\n});\n\nconst ImportInfoSchema = z.object({\n  source: z.string(),\n  imported: z.string(),\n  alias: z.string().optional().nullable(),\n});\n\nexport const ParsePythonResultSchema = z.object({\n  nodes: z.array(CodeNodeSchema),\n  imports: z.array(ImportInfoSchema),\n});\n\nexport type ParsePythonResult = z.infer<typeof ParsePythonResultSchema>;\n\n/**\n * Validates a Python AST parsing response from Python bridge.\n * Throws ZodError if the response doesn't match the expected schema.\n *\n * @param data - Raw data from Python bridge\n * @returns Validated ParsePythonResult\n * @throws {z.ZodError} If validation fails\n */\nexport function validateParsePythonResult(data: unknown): ParsePythonResult {\n  return ParsePythonResultSchema.parse(data);\n}\n","import { ConfigService } from './config.service.js';\nimport { StoreService } from './store.service.js';\nimport { SearchService } from './search.service.js';\nimport { IndexService } from './index.service.js';\nimport { CodeGraphService } from './code-graph.service.js';\nimport { LanceStore } from '../db/lance.js';\nimport { EmbeddingEngine } from '../db/embeddings.js';\nimport { PythonBridge } from '../crawl/bridge.js';\n\nexport { ConfigService } from './config.service.js';\nexport { StoreService } from './store.service.js';\nexport { SearchService } from './search.service.js';\nexport { IndexService } from './index.service.js';\nexport { JobService } from './job.service.js';\nexport { WatchService } from './watch.service.js';\nexport { ChunkingService } from './chunking.service.js';\nexport { CodeGraphService } from './code-graph.service.js';\n\nexport interface ServiceContainer {\n  config: ConfigService;\n  store: StoreService;\n  search: SearchService;\n  index: IndexService;\n  lance: LanceStore;\n  embeddings: EmbeddingEngine;\n  codeGraph: CodeGraphService;\n  pythonBridge: PythonBridge;\n}\n\nexport async function createServices(\n  configPath?: string,\n  dataDir?: string,\n  projectRoot?: string\n): Promise<ServiceContainer> {\n  const config = new ConfigService(configPath, dataDir, projectRoot);\n  const appConfig = await config.load();\n  const resolvedDataDir = config.resolveDataDir();\n\n  const lance = new LanceStore(resolvedDataDir);\n  const embeddings = new EmbeddingEngine(\n    appConfig.embedding.model,\n    appConfig.embedding.dimensions\n  );\n\n  await embeddings.initialize();\n\n  const store = new StoreService(resolvedDataDir);\n  await store.initialize();\n\n  const pythonBridge = new PythonBridge();\n  await pythonBridge.start();\n\n  const codeGraph = new CodeGraphService(resolvedDataDir, pythonBridge);\n  const search = new SearchService(lance, embeddings, undefined, codeGraph);\n  const index = new IndexService(lance, embeddings, { codeGraphService: codeGraph });\n\n  return {\n    config,\n    store,\n    search,\n    index,\n    lance,\n    embeddings,\n    codeGraph,\n    pythonBridge,\n  };\n}\n"],"mappings":"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","names":["dirname","path","dirname","path","readFile","writeFile","mkdir","join","randomUUID","mkdir","mkdir","resolve","mkdir","randomUUID","join","readFile","writeFile","t","path","readFile","join","readFile","join","readFile","writeFile","mkdir","join","dirname","path","path","path","path","path","mkdir","dirname","writeFile","readFile","join","resolve","spawn","randomUUID","spawn","err","randomUUID","resolve"]}