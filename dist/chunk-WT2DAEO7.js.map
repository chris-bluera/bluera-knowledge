{"version":3,"sources":["../src/mcp/server.ts","../src/mcp/schemas/index.ts","../src/mcp/cache.ts","../src/services/token.service.ts","../src/mcp/handlers/search.handler.ts","../src/mcp/handlers/index.ts","../src/mcp/commands/registry.ts","../src/mcp/commands/store.commands.ts","../src/mcp/handlers/store.handler.ts","../src/workers/spawn-worker.ts","../src/mcp/commands/job.commands.ts","../src/mcp/handlers/job.handler.ts","../src/mcp/commands/meta.commands.ts","../src/mcp/commands/index.ts","../src/mcp/handlers/execute.handler.ts"],"sourcesContent":["import { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { createServices } from '../services/index.js';\nimport { tools } from './handlers/index.js';\nimport { handleExecute } from './handlers/execute.handler.js';\nimport { ExecuteArgsSchema } from './schemas/index.js';\nimport type { MCPServerOptions } from './types.js';\nimport { createLogger } from '../logging/index.js';\n\nconst logger = createLogger('mcp-server');\n\n// eslint-disable-next-line @typescript-eslint/no-deprecated\nexport function createMCPServer(options: MCPServerOptions): Server {\n  // eslint-disable-next-line @typescript-eslint/no-deprecated\n  const server = new Server(\n    {\n      name: 'bluera-knowledge',\n      version: '1.0.0',\n    },\n    {\n      capabilities: {\n        tools: {},\n      },\n    }\n  );\n\n  // List available tools - consolidated from 10 tools to 3 for reduced context overhead\n  server.setRequestHandler(ListToolsRequestSchema, () => {\n    return Promise.resolve({\n      tools: [\n        // Native search tool with full schema (most used, benefits from detailed params)\n        {\n          name: 'search',\n          description: 'Search all indexed knowledge stores with pattern detection and AI-optimized results. Returns structured code units with progressive context layers.',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              query: {\n                type: 'string',\n                description: 'Search query (can include type signatures, constraints, or natural language)'\n              },\n              intent: {\n                type: 'string',\n                enum: ['find-pattern', 'find-implementation', 'find-usage', 'find-definition', 'find-documentation'],\n                description: 'Search intent for better ranking'\n              },\n              detail: {\n                type: 'string',\n                enum: ['minimal', 'contextual', 'full'],\n                default: 'minimal',\n                description: 'Context detail level: minimal (summary only), contextual (+ imports/types), full (+ complete code)'\n              },\n              limit: {\n                type: 'number',\n                default: 10,\n                description: 'Maximum number of results'\n              },\n              stores: {\n                type: 'array',\n                items: { type: 'string' },\n                description: 'Specific store IDs to search (optional)'\n              }\n            },\n            required: ['query']\n          }\n        },\n        // Native get_full_context tool (frequently used after search)\n        {\n          name: 'get_full_context',\n          description: 'Get complete code and context for a specific search result by ID. Use this after search to get full implementation details.',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              resultId: {\n                type: 'string',\n                description: 'Result ID from previous search'\n              }\n            },\n            required: ['resultId']\n          }\n        },\n        // Meta-tool for store and job management (consolidates 8 tools into 1)\n        {\n          name: 'execute',\n          description: 'Execute store/job management commands. Commands: stores, store:info, store:create, store:index, store:delete, jobs, job:status, job:cancel, help, commands',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              command: {\n                type: 'string',\n                description: 'Command to execute (e.g., \"stores\", \"store:create\", \"jobs\", \"help\")'\n              },\n              args: {\n                type: 'object',\n                description: 'Command arguments (e.g., {store: \"mystore\"} for store:info)'\n              }\n            },\n            required: ['command']\n          }\n        }\n      ]\n    });\n  });\n\n  // Handle tool calls\n  server.setRequestHandler(CallToolRequestSchema, async (request) => {\n    const { name, arguments: args } = request.params;\n    const startTime = Date.now();\n\n    logger.info({ tool: name, args: JSON.stringify(args) }, 'Tool invoked');\n\n    // Create services once (needed by all handlers)\n    const services = await createServices(\n      options.config,\n      options.dataDir,\n      options.projectRoot\n    );\n    const context = { services, options };\n\n    try {\n      let result;\n\n      // Handle execute meta-tool\n      if (name === 'execute') {\n        const validated = ExecuteArgsSchema.parse(args ?? {});\n        result = await handleExecute(validated, context);\n      } else {\n        // Find handler in registry for native tools (search, get_full_context)\n        const tool = tools.find(t => t.name === name);\n        if (tool === undefined) {\n          throw new Error(`Unknown tool: ${name}`);\n        }\n\n        // Validate arguments with Zod\n        const validated = tool.schema.parse(args ?? {});\n\n        // Execute handler with context\n        result = await tool.handler(validated, context);\n      }\n\n      const durationMs = Date.now() - startTime;\n      logger.info({ tool: name, durationMs }, 'Tool completed');\n\n      return result;\n    } catch (error) {\n      const durationMs = Date.now() - startTime;\n      logger.error({\n        tool: name,\n        durationMs,\n        error: error instanceof Error ? error.message : String(error),\n      }, 'Tool execution failed');\n      throw error;\n    }\n  });\n\n  return server;\n}\n\nexport async function runMCPServer(options: MCPServerOptions): Promise<void> {\n  logger.info({\n    dataDir: options.dataDir,\n    projectRoot: options.projectRoot,\n  }, 'MCP server starting');\n\n  const server = createMCPServer(options);\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n\n  logger.info('MCP server connected to stdio transport');\n}\n\n// Run the server only when this file is executed directly (not imported by CLI)\n// Check if we're running as the mcp/server entry point vs being imported by index.js\nconst scriptPath = process.argv[1] ?? '';\nconst isMCPServerEntry = scriptPath.endsWith('mcp/server.js') || scriptPath.endsWith('mcp/server');\n\nif (isMCPServerEntry) {\n  runMCPServer({\n    dataDir: process.env['DATA_DIR'],\n    config: process.env['CONFIG_PATH'],\n    projectRoot: process.env['PROJECT_ROOT'] ?? process.env['PWD']\n  }).catch((error: unknown) => {\n    logger.error({ error: error instanceof Error ? error.message : String(error) }, 'Failed to start MCP server');\n    process.exit(1);\n  });\n}\n","import { z } from 'zod';\n\n/**\n * Validation schemas for all MCP tool inputs\n *\n * These schemas provide runtime type validation and better error messages\n * compared to manual type assertions.\n */\n\n// ============================================================================\n// Search Tool Schemas\n// ============================================================================\n\n/**\n * Schema for search tool arguments\n */\nexport const SearchArgsSchema = z.object({\n  query: z.string().min(1, 'Query must be a non-empty string'),\n  intent: z\n    .enum(['find-pattern', 'find-implementation', 'find-usage', 'find-definition', 'find-documentation'])\n    .optional(),\n  detail: z.enum(['minimal', 'contextual', 'full']).default('minimal'),\n  limit: z.number().int().positive().default(10),\n  stores: z.array(z.string()).optional()\n});\n\nexport type SearchArgs = z.infer<typeof SearchArgsSchema>;\n\n/**\n * Schema for get_full_context tool arguments\n */\nexport const GetFullContextArgsSchema = z.object({\n  resultId: z.string().min(1, 'Result ID must be a non-empty string')\n});\n\nexport type GetFullContextArgs = z.infer<typeof GetFullContextArgsSchema>;\n\n// ============================================================================\n// Store Tool Schemas\n// ============================================================================\n\n/**\n * Schema for list_stores tool arguments\n */\nexport const ListStoresArgsSchema = z.object({\n  type: z.enum(['file', 'repo', 'web']).optional()\n});\n\nexport type ListStoresArgs = z.infer<typeof ListStoresArgsSchema>;\n\n/**\n * Schema for get_store_info tool arguments\n */\nexport const GetStoreInfoArgsSchema = z.object({\n  store: z.string().min(1, 'Store name or ID must be a non-empty string')\n});\n\nexport type GetStoreInfoArgs = z.infer<typeof GetStoreInfoArgsSchema>;\n\n/**\n * Schema for create_store tool arguments\n */\nexport const CreateStoreArgsSchema = z.object({\n  name: z.string().min(1, 'Store name must be a non-empty string'),\n  type: z.enum(['file', 'repo']),\n  source: z.string().min(1, 'Source path or URL must be a non-empty string'),\n  branch: z.string().optional(),\n  description: z.string().optional()\n});\n\nexport type CreateStoreArgs = z.infer<typeof CreateStoreArgsSchema>;\n\n/**\n * Schema for index_store tool arguments\n */\nexport const IndexStoreArgsSchema = z.object({\n  store: z.string().min(1, 'Store name or ID must be a non-empty string')\n});\n\nexport type IndexStoreArgs = z.infer<typeof IndexStoreArgsSchema>;\n\n/**\n * Schema for delete_store tool arguments\n */\nexport const DeleteStoreArgsSchema = z.object({\n  store: z.string().min(1, 'Store name or ID must be a non-empty string')\n});\n\nexport type DeleteStoreArgs = z.infer<typeof DeleteStoreArgsSchema>;\n\n// ============================================================================\n// Job Tool Schemas\n// ============================================================================\n\n/**\n * Schema for check_job_status tool arguments\n */\nexport const CheckJobStatusArgsSchema = z.object({\n  jobId: z.string().min(1, 'Job ID must be a non-empty string')\n});\n\nexport type CheckJobStatusArgs = z.infer<typeof CheckJobStatusArgsSchema>;\n\n/**\n * Schema for list_jobs tool arguments\n */\nexport const ListJobsArgsSchema = z.object({\n  activeOnly: z.boolean().optional(),\n  status: z.enum(['pending', 'running', 'completed', 'failed', 'cancelled']).optional()\n});\n\nexport type ListJobsArgs = z.infer<typeof ListJobsArgsSchema>;\n\n/**\n * Schema for cancel_job tool arguments\n */\nexport const CancelJobArgsSchema = z.object({\n  jobId: z.string().min(1, 'Job ID must be a non-empty string')\n});\n\nexport type CancelJobArgs = z.infer<typeof CancelJobArgsSchema>;\n\n// ============================================================================\n// Execute Meta-Tool Schema\n// ============================================================================\n\n/**\n * Schema for execute meta-tool arguments\n *\n * The execute tool consolidates store and job management commands\n * into a single tool, reducing context overhead.\n */\nexport const ExecuteArgsSchema = z.object({\n  command: z.string().min(1, 'Command name is required'),\n  args: z.record(z.string(), z.unknown()).optional()\n});\n\nexport type ExecuteArgs = z.infer<typeof ExecuteArgsSchema>;\n","/**\n * LRU (Least Recently Used) Cache implementation\n *\n * Maintains a cache with a maximum size, evicting the oldest (least recently used)\n * items when the capacity is exceeded. This prevents unbounded memory growth.\n *\n * Items are automatically moved to the end of the cache when accessed (via get),\n * making them the most recently used.\n */\nexport class LRUCache<K, V> {\n  private readonly cache = new Map<K, V>();\n  private readonly maxSize: number;\n\n  /**\n   * Create a new LRU cache\n   *\n   * @param maxSize - Maximum number of items to store (default: 1000)\n   */\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Store a value in the cache\n   *\n   * If the key already exists, it will be moved to the end (most recent).\n   * If the cache is at capacity, the oldest item will be evicted.\n   *\n   * @param key - The cache key\n   * @param value - The value to store\n   */\n  set(key: K, value: V): void {\n    // If key exists, delete it first to move it to the end\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    // Add the new/updated entry\n    this.cache.set(key, value);\n\n    // Evict oldest entry if over capacity\n    if (this.cache.size > this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey !== undefined) {\n        this.cache.delete(firstKey);\n      }\n    }\n  }\n\n  /**\n   * Retrieve a value from the cache\n   *\n   * If the key exists, it will be moved to the end (most recent).\n   *\n   * @param key - The cache key\n   * @returns The cached value, or undefined if not found\n   */\n  get(key: K): V | undefined {\n    const value = this.cache.get(key);\n\n    if (value !== undefined) {\n      // Move to end (most recent) by deleting and re-adding\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Check if a key exists in the cache\n   *\n   * @param key - The cache key\n   * @returns True if the key exists\n   */\n  has(key: K): boolean {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Remove a specific key from the cache\n   *\n   * @param key - The cache key\n   * @returns True if the key was removed, false if it didn't exist\n   */\n  delete(key: K): boolean {\n    return this.cache.delete(key);\n  }\n\n  /**\n   * Clear all entries from the cache\n   */\n  clear(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get the current number of items in the cache\n   */\n  get size(): number {\n    return this.cache.size;\n  }\n}\n","/**\n * Token estimation service using Anthropic's recommended heuristic.\n * For Claude 3+ models, Anthropic recommends ~3.5 characters per token\n * for English text. This varies by language.\n *\n * Note: The official @anthropic-ai/tokenizer package only works for\n * pre-Claude 3 models. For accurate counts on Claude 3+, use the\n * Token Count API. This heuristic is suitable for display purposes.\n */\n\nconst CHARS_PER_TOKEN = 3.5;\n\n/**\n * Estimate token count for a string using character-based heuristic.\n * @param text - The text to estimate tokens for\n * @returns Estimated token count (rounded up)\n */\nexport function estimateTokens(text: string): number {\n  if (!text) return 0;\n  return Math.ceil(text.length / CHARS_PER_TOKEN);\n}\n\n/**\n * Format token count for display with appropriate suffix.\n * @param tokens - Token count\n * @returns Formatted string like \"~1.2k\" or \"~847\"\n */\nexport function formatTokenCount(tokens: number): string {\n  if (tokens >= 1000) {\n    return `~${(tokens / 1000).toFixed(1)}k`;\n  }\n  return `~${String(tokens)}`;\n}\n","import type { ToolHandler, ToolResponse } from '../types.js';\nimport type { SearchArgs, GetFullContextArgs } from '../schemas/index.js';\nimport { SearchArgsSchema, GetFullContextArgsSchema } from '../schemas/index.js';\nimport type { SearchQuery, DocumentId, StoreId } from '../../types/index.js';\nimport { LRUCache } from '../cache.js';\nimport type { SearchResult } from '../../types/search.js';\nimport { createLogger, summarizePayload } from '../../logging/index.js';\nimport { estimateTokens, formatTokenCount } from '../../services/token.service.js';\n\nconst logger = createLogger('mcp-search');\n\n// Create result cache for get_full_context\n// Uses LRU cache to prevent memory leaks (max 1000 items)\nexport const resultCache = new LRUCache<DocumentId, SearchResult>(1000);\n\n/**\n * Handle search requests\n *\n * Searches across specified stores (or all stores if none specified) using\n * hybrid vector + FTS search. Results are cached for get_full_context retrieval.\n */\nexport const handleSearch: ToolHandler<SearchArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = SearchArgsSchema.parse(args);\n\n  logger.info({\n    query: validated.query,\n    stores: validated.stores,\n    detail: validated.detail,\n    limit: validated.limit,\n    intent: validated.intent,\n  }, 'Search started');\n\n  const { services } = context;\n\n  // Get all stores if none specified, resolve store names to IDs\n  const storeIds: StoreId[] = validated.stores !== undefined\n    ? await Promise.all(validated.stores.map(async (s) => {\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        const store = await services.store.getByIdOrName(s as StoreId);\n        if (!store) {\n          throw new Error(`Store not found: ${s}`);\n        }\n        return store.id;\n      }))\n    : (await services.store.list()).map(s => s.id);\n\n  // Initialize stores with error handling\n  try {\n    for (const storeId of storeIds) {\n      await services.lance.initialize(storeId);\n    }\n  } catch (error) {\n    throw new Error(\n      `Failed to initialize vector stores: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n\n  // Perform search\n  const searchQuery: SearchQuery = {\n    query: validated.query,\n    stores: storeIds,\n    mode: 'hybrid',\n    limit: validated.limit,\n    detail: validated.detail\n  };\n\n  const results = await services.search.search(searchQuery);\n\n  // Cache results for get_full_context (with LRU eviction)\n  for (const result of results.results) {\n    resultCache.set(result.id, result);\n  }\n\n  // Add repoRoot to results for cloned repos\n  const enhancedResults = await Promise.all(results.results.map(async (r) => {\n    const storeId = r.metadata.storeId;\n    const store = await services.store.getByIdOrName(storeId);\n\n    return {\n      id: r.id,\n      score: r.score,\n      summary: {\n        ...r.summary,\n        storeName: store?.name,\n        repoRoot: store !== undefined && store.type === 'repo' ? store.path : undefined\n      },\n      context: r.context,\n      full: r.full\n    };\n  }));\n\n  const responseJson = JSON.stringify({\n    results: enhancedResults,\n    totalResults: results.totalResults,\n    mode: results.mode,\n    timeMs: results.timeMs\n  }, null, 2);\n\n  // Calculate actual token estimate based on response content\n  const responseTokens = estimateTokens(responseJson);\n\n  // Create visible header with token usage\n  const header = `Search: \"${validated.query}\" | Results: ${String(results.totalResults)} | ${formatTokenCount(responseTokens)} tokens | ${String(results.timeMs)}ms\\n\\n`;\n\n  // Log the complete MCP response that will be sent to Claude Code\n  logger.info({\n    query: validated.query,\n    totalResults: results.totalResults,\n    responseTokens,\n    timeMs: results.timeMs,\n    ...summarizePayload(responseJson, 'mcp-response', validated.query),\n  }, 'Search complete - context sent to Claude Code');\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: header + responseJson\n      }\n    ]\n  };\n};\n\n/**\n * Handle get_full_context requests\n *\n * Retrieves full context for a previously cached search result.\n * If the result isn't already full, re-queries with full detail level.\n */\nexport const handleGetFullContext: ToolHandler<GetFullContextArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = GetFullContextArgsSchema.parse(args);\n\n  logger.info({ resultId: validated.resultId }, 'Get full context requested');\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const resultId = validated.resultId as DocumentId;\n\n  // Check cache for result\n  const cachedResult = resultCache.get(resultId);\n\n  if (!cachedResult) {\n    throw new Error(\n      `Result not found in cache: ${resultId}. Run a search first to cache results.`\n    );\n  }\n\n  // If result already has full context, return it\n  if (cachedResult.full) {\n    const responseJson = JSON.stringify({\n      id: cachedResult.id,\n      score: cachedResult.score,\n      summary: cachedResult.summary,\n      context: cachedResult.context,\n      full: cachedResult.full\n    }, null, 2);\n\n    logger.info({\n      resultId,\n      cached: true,\n      hasFullContext: true,\n      ...summarizePayload(responseJson, 'mcp-full-context', resultId),\n    }, 'Full context retrieved from cache');\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: responseJson\n        }\n      ]\n    };\n  }\n\n  // Otherwise, re-query with full detail\n  const { services } = context;\n  const store = await services.store.getByIdOrName(cachedResult.metadata.storeId);\n\n  if (!store) {\n    throw new Error(`Store not found: ${cachedResult.metadata.storeId}`);\n  }\n\n  await services.lance.initialize(store.id);\n\n  const searchQuery: SearchQuery = {\n    query: cachedResult.content.substring(0, 100), // Use snippet of content as query\n    stores: [store.id],\n    mode: 'hybrid',\n    limit: 1,\n    detail: 'full'\n  };\n\n  const results = await services.search.search(searchQuery);\n\n  // Find matching result by ID\n  const fullResult = results.results.find(r => r.id === resultId);\n\n  if (!fullResult) {\n    // Return cached result even if we couldn't get full detail\n    return {\n      content: [\n        {\n          type: 'text',\n          text: JSON.stringify({\n            id: cachedResult.id,\n            score: cachedResult.score,\n            summary: cachedResult.summary,\n            context: cachedResult.context,\n            warning: 'Could not retrieve full context, returning cached minimal result'\n          }, null, 2)\n        }\n      ]\n    };\n  }\n\n  // Update cache with full result\n  resultCache.set(resultId, fullResult);\n\n  const responseJson = JSON.stringify({\n    id: fullResult.id,\n    score: fullResult.score,\n    summary: fullResult.summary,\n    context: fullResult.context,\n    full: fullResult.full\n  }, null, 2);\n\n  logger.info({\n    resultId,\n    cached: false,\n    hasFullContext: true,\n    ...summarizePayload(responseJson, 'mcp-full-context', resultId),\n  }, 'Full context retrieved via re-query');\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: responseJson\n      }\n    ]\n  };\n};\n","import { z } from 'zod';\nimport type { ToolHandler } from '../types.js';\nimport {\n  SearchArgsSchema,\n  GetFullContextArgsSchema\n} from '../schemas/index.js';\nimport {\n  handleSearch,\n  handleGetFullContext\n} from './search.handler.js';\n\n/**\n * Tool definition with schema and handler\n */\nexport interface ToolDefinition {\n  name: string;\n  description: string;\n  schema: z.ZodType;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handler: ToolHandler<any>;\n}\n\n/**\n * Registry of native MCP tools\n *\n * Only search and get_full_context are native tools with full schemas.\n * Store and job management is consolidated into the execute meta-tool\n * (see commands/ directory and execute.handler.ts).\n */\nexport const tools: ToolDefinition[] = [\n  {\n    name: 'search',\n    description: 'Search all indexed knowledge stores with pattern detection and AI-optimized results. Returns structured code units with progressive context layers.',\n    schema: SearchArgsSchema,\n    handler: handleSearch\n  },\n  {\n    name: 'get_full_context',\n    description: 'Get complete code and context for a specific search result by ID. Use this after search to get full implementation details.',\n    schema: GetFullContextArgsSchema,\n    handler: handleGetFullContext\n  }\n];\n","import { z } from 'zod';\nimport type { HandlerContext, ToolResponse } from '../types.js';\n\n/**\n * Command definition for the execute meta-tool\n *\n * Each command has a name, description, optional args schema, and handler.\n * Commands are registered in the registry and invoked via execute(command, args).\n */\nexport interface CommandDefinition {\n  /** Command name (e.g., 'stores', 'store:info', 'job:status') */\n  name: string;\n  /** Human-readable description shown in help output */\n  description: string;\n  /** Optional Zod schema for argument validation */\n  argsSchema?: z.ZodType;\n  /** Handler function that executes the command */\n  handler: CommandHandler;\n}\n\n/**\n * Command handler function signature\n *\n * @param args - Validated command arguments (or empty object if no args)\n * @param context - Handler context with services and options\n * @returns Promise resolving to tool response\n */\nexport type CommandHandler = (\n  args: Record<string, unknown>,\n  context: HandlerContext\n) => Promise<ToolResponse>;\n\n/**\n * Command registry - singleton that holds all registered commands\n */\nclass CommandRegistry {\n  private readonly commands = new Map<string, CommandDefinition>();\n\n  /**\n   * Register a command\n   */\n  register(command: CommandDefinition): void {\n    if (this.commands.has(command.name)) {\n      throw new Error(`Command already registered: ${command.name}`);\n    }\n    this.commands.set(command.name, command);\n  }\n\n  /**\n   * Register multiple commands at once\n   */\n  registerAll(commands: CommandDefinition[]): void {\n    for (const command of commands) {\n      this.register(command);\n    }\n  }\n\n  /**\n   * Get a command by name\n   */\n  get(name: string): CommandDefinition | undefined {\n    return this.commands.get(name);\n  }\n\n  /**\n   * Check if a command exists\n   */\n  has(name: string): boolean {\n    return this.commands.has(name);\n  }\n\n  /**\n   * Get all registered commands\n   */\n  all(): CommandDefinition[] {\n    return Array.from(this.commands.values());\n  }\n\n  /**\n   * Get commands grouped by category (prefix before colon)\n   */\n  grouped(): Map<string, CommandDefinition[]> {\n    const groups = new Map<string, CommandDefinition[]>();\n\n    for (const cmd of this.commands.values()) {\n      const colonIndex = cmd.name.indexOf(':');\n      const category = colonIndex === -1 ? 'general' : cmd.name.slice(0, colonIndex);\n\n      const existing = groups.get(category) ?? [];\n      existing.push(cmd);\n      groups.set(category, existing);\n    }\n\n    return groups;\n  }\n}\n\n/** Global command registry instance */\nexport const commandRegistry = new CommandRegistry();\n\n/**\n * Execute a command by name\n *\n * @param commandName - The command to execute\n * @param args - Arguments to pass to the command\n * @param context - Handler context\n * @returns Promise resolving to tool response\n */\nexport async function executeCommand(\n  commandName: string,\n  args: Record<string, unknown>,\n  context: HandlerContext\n): Promise<ToolResponse> {\n  const command = commandRegistry.get(commandName);\n\n  if (command === undefined) {\n    throw new Error(\n      `Unknown command: ${commandName}. Use execute(\"commands\") to list available commands.`\n    );\n  }\n\n  // Validate args if schema provided (Zod parse returns unknown, safe to cast after validation)\n  /* eslint-disable @typescript-eslint/consistent-type-assertions */\n  const validatedArgs: Record<string, unknown> = command.argsSchema !== undefined\n    ? (command.argsSchema.parse(args) as Record<string, unknown>)\n    : args;\n  /* eslint-enable @typescript-eslint/consistent-type-assertions */\n\n  return command.handler(validatedArgs, context);\n}\n\n/**\n * Generate help text for a command or all commands\n */\nexport function generateHelp(commandName?: string): string {\n  if (commandName !== undefined) {\n    const command = commandRegistry.get(commandName);\n    if (command === undefined) {\n      throw new Error(`Unknown command: ${commandName}`);\n    }\n\n    const lines = [\n      `Command: ${command.name}`,\n      `Description: ${command.description}`,\n      ''\n    ];\n\n    if (command.argsSchema !== undefined) {\n      lines.push('Arguments:');\n      // Extract schema shape for documentation\n      const schema = command.argsSchema;\n      if (schema instanceof z.ZodObject) {\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        const shape = schema.shape as Record<string, z.ZodType>;\n        for (const [key, fieldSchema] of Object.entries(shape)) {\n          const isOptional = fieldSchema.safeParse(undefined).success;\n          const desc = fieldSchema.description ?? '';\n          lines.push(`  ${key}${isOptional ? ' (optional)' : ''}: ${desc}`);\n        }\n      }\n    } else {\n      lines.push('Arguments: none');\n    }\n\n    return lines.join('\\n');\n  }\n\n  // Generate help for all commands\n  const groups = commandRegistry.grouped();\n  const lines = ['Available commands:', ''];\n\n  for (const [category, commands] of groups) {\n    lines.push(`${category}:`);\n    for (const cmd of commands) {\n      lines.push(`  ${cmd.name} - ${cmd.description}`);\n    }\n    lines.push('');\n  }\n\n  lines.push('Use execute(\"help\", {command: \"name\"}) for detailed command help.');\n\n  return lines.join('\\n');\n}\n","import { z } from 'zod';\nimport type { CommandDefinition } from './registry.js';\nimport type {\n  ListStoresArgs,\n  GetStoreInfoArgs,\n  CreateStoreArgs,\n  IndexStoreArgs,\n  DeleteStoreArgs\n} from '../schemas/index.js';\nimport {\n  handleListStores,\n  handleGetStoreInfo,\n  handleCreateStore,\n  handleIndexStore,\n  handleDeleteStore\n} from '../handlers/store.handler.js';\n\n/**\n * Store management commands for the execute meta-tool\n *\n * These commands wrap the existing store handlers, providing\n * a unified interface through the execute command.\n *\n * Note: Type assertions are necessary here because CommandHandler uses\n * Record<string, unknown> for generic command args, while handlers expect\n * specific typed args. Zod validates at runtime before the cast.\n */\n/* eslint-disable @typescript-eslint/consistent-type-assertions */\nexport const storeCommands: CommandDefinition[] = [\n  {\n    name: 'stores',\n    description: 'List all indexed knowledge stores',\n    argsSchema: z.object({\n      type: z.enum(['file', 'repo', 'web']).optional().describe('Filter by store type')\n    }),\n    handler: (args, context) => handleListStores(args as unknown as ListStoresArgs, context)\n  },\n  {\n    name: 'store:info',\n    description: 'Get detailed information about a specific store',\n    argsSchema: z.object({\n      store: z.string().min(1).describe('Store name or ID')\n    }),\n    handler: (args, context) => handleGetStoreInfo(args as unknown as GetStoreInfoArgs, context)\n  },\n  {\n    name: 'store:create',\n    description: 'Create a new knowledge store from git URL or local path',\n    argsSchema: z.object({\n      name: z.string().min(1).describe('Store name'),\n      type: z.enum(['file', 'repo']).describe('Store type'),\n      source: z.string().min(1).describe('Git URL or local path'),\n      branch: z.string().optional().describe('Git branch (for repo type)'),\n      description: z.string().optional().describe('Store description')\n    }),\n    handler: (args, context) => handleCreateStore(args as unknown as CreateStoreArgs, context)\n  },\n  {\n    name: 'store:index',\n    description: 'Re-index a knowledge store to update search data',\n    argsSchema: z.object({\n      store: z.string().min(1).describe('Store name or ID')\n    }),\n    handler: (args, context) => handleIndexStore(args as unknown as IndexStoreArgs, context)\n  },\n  {\n    name: 'store:delete',\n    description: 'Delete a knowledge store and all associated data',\n    argsSchema: z.object({\n      store: z.string().min(1).describe('Store name or ID')\n    }),\n    handler: (args, context) => handleDeleteStore(args as unknown as DeleteStoreArgs, context)\n  }\n];\n/* eslint-enable @typescript-eslint/consistent-type-assertions */\n","import { rm } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { ToolHandler, ToolResponse } from '../types.js';\nimport type {\n  ListStoresArgs,\n  GetStoreInfoArgs,\n  CreateStoreArgs,\n  IndexStoreArgs,\n  DeleteStoreArgs\n} from '../schemas/index.js';\nimport {\n  ListStoresArgsSchema,\n  GetStoreInfoArgsSchema,\n  CreateStoreArgsSchema,\n  IndexStoreArgsSchema,\n  DeleteStoreArgsSchema\n} from '../schemas/index.js';\nimport { JobService } from '../../services/job.service.js';\nimport { spawnBackgroundWorker } from '../../workers/spawn-worker.js';\nimport { createStoreId } from '../../types/brands.js';\n\n/**\n * Handle list_stores requests\n *\n * Lists all knowledge stores with optional type filtering.\n */\nexport const handleListStores: ToolHandler<ListStoresArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = ListStoresArgsSchema.parse(args);\n\n  const { services } = context;\n\n  const stores = await services.store.list();\n  const filtered = validated.type !== undefined\n    ? stores.filter(s => s.type === validated.type)\n    : stores;\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          stores: filtered.map(s => ({\n            id: s.id,\n            name: s.name,\n            type: s.type,\n            path: 'path' in s ? s.path : undefined,\n            url: 'url' in s && s.url !== undefined ? s.url : undefined,\n            description: s.description,\n            createdAt: s.createdAt.toISOString()\n          }))\n        }, null, 2)\n      }\n    ]\n  };\n};\n\n/**\n * Handle get_store_info requests\n *\n * Retrieves detailed information about a specific store.\n */\nexport const handleGetStoreInfo: ToolHandler<GetStoreInfoArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = GetStoreInfoArgsSchema.parse(args);\n\n  const { services } = context;\n\n  const store = await services.store.getByIdOrName(createStoreId(validated.store));\n\n  if (store === undefined) {\n    throw new Error(`Store not found: ${validated.store}`);\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          id: store.id,\n          name: store.name,\n          type: store.type,\n          path: 'path' in store ? store.path : undefined,\n          url: 'url' in store && store.url !== undefined ? store.url : undefined,\n          branch: 'branch' in store ? store.branch : undefined,\n          description: store.description,\n          status: store.status,\n          createdAt: store.createdAt.toISOString(),\n          updatedAt: store.updatedAt.toISOString()\n        }, null, 2)\n      }\n    ]\n  };\n};\n\n/**\n * Handle create_store requests\n *\n * Creates a new knowledge store and starts background indexing.\n * Returns store info and job ID for tracking progress.\n */\nexport const handleCreateStore: ToolHandler<CreateStoreArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = CreateStoreArgsSchema.parse(args);\n\n  const { services, options } = context;\n\n  // Determine if source is a URL or path\n  const isUrl = validated.source.startsWith('http://') ||\n                validated.source.startsWith('https://') ||\n                validated.source.startsWith('git@');\n\n  const result = await services.store.create({\n    name: validated.name,\n    type: validated.type,\n    ...(isUrl ? { url: validated.source } : { path: validated.source }),\n    ...(validated.branch !== undefined ? { branch: validated.branch } : {}),\n    ...(validated.description !== undefined ? { description: validated.description } : {})\n  });\n\n  if (!result.success) {\n    throw new Error(result.error.message);\n  }\n\n  // Create background job for indexing\n  const jobService = new JobService(options.dataDir);\n  const jobDetails: Record<string, unknown> = {\n    storeName: result.data.name,\n    storeId: result.data.id\n  };\n  if (isUrl) {\n    jobDetails['url'] = validated.source;\n  }\n  if ('path' in result.data && result.data.path) {\n    jobDetails['path'] = result.data.path;\n  }\n  const job = jobService.createJob({\n    type: validated.type === 'repo' && isUrl ? 'clone' : 'index',\n    details: jobDetails,\n    message: `Indexing ${result.data.name}...`\n  });\n\n  // Spawn background worker (dataDir defaults to project-local .bluera if undefined)\n  spawnBackgroundWorker(job.id, options.dataDir ?? '');\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          store: {\n            id: result.data.id,\n            name: result.data.name,\n            type: result.data.type,\n            path: 'path' in result.data ? result.data.path : undefined\n          },\n          job: {\n            id: job.id,\n            status: job.status,\n            message: job.message\n          },\n          message: `Store created. Indexing started in background (Job ID: ${job.id})`\n        }, null, 2)\n      }\n    ]\n  };\n};\n\n/**\n * Handle index_store requests\n *\n * Re-indexes an existing store in the background.\n * Returns job ID for tracking progress.\n */\nexport const handleIndexStore: ToolHandler<IndexStoreArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = IndexStoreArgsSchema.parse(args);\n\n  const { services, options } = context;\n\n  const store = await services.store.getByIdOrName(createStoreId(validated.store));\n\n  if (store === undefined) {\n    throw new Error(`Store not found: ${validated.store}`);\n  }\n\n  // Create background job for indexing\n  const jobService = new JobService(options.dataDir);\n  const jobDetails: Record<string, unknown> = {\n    storeName: store.name,\n    storeId: store.id\n  };\n  if ('path' in store && store.path) {\n    jobDetails['path'] = store.path;\n  }\n  const job = jobService.createJob({\n    type: 'index',\n    details: jobDetails,\n    message: `Re-indexing ${store.name}...`\n  });\n\n  // Spawn background worker (dataDir defaults to project-local .bluera if undefined)\n  spawnBackgroundWorker(job.id, options.dataDir ?? '');\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          store: {\n            id: store.id,\n            name: store.name\n          },\n          job: {\n            id: job.id,\n            status: job.status,\n            message: job.message\n          },\n          message: `Indexing started in background (Job ID: ${job.id})`\n        }, null, 2)\n      }\n    ]\n  };\n};\n\n/**\n * Handle delete_store requests\n *\n * Deletes a store and all associated data:\n * - Removes from store registry\n * - Drops LanceDB table\n * - For repo stores with URL, removes cloned files\n */\nexport const handleDeleteStore: ToolHandler<DeleteStoreArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = DeleteStoreArgsSchema.parse(args);\n\n  const { services, options } = context;\n\n  const store = await services.store.getByIdOrName(createStoreId(validated.store));\n\n  if (store === undefined) {\n    throw new Error(`Store not found: ${validated.store}`);\n  }\n\n  // Delete LanceDB table\n  await services.lance.deleteStore(store.id);\n\n  // For repo stores cloned from URL, remove the cloned directory\n  if (store.type === 'repo' && 'url' in store && store.url !== undefined) {\n    if (options.dataDir === undefined) {\n      throw new Error('dataDir is required to delete cloned repository files');\n    }\n    const repoPath = join(options.dataDir, 'repos', store.id);\n    await rm(repoPath, { recursive: true, force: true });\n  }\n\n  // Delete from registry\n  const result = await services.store.delete(store.id);\n  if (!result.success) {\n    throw new Error(result.error.message);\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          deleted: true,\n          store: {\n            id: store.id,\n            name: store.name,\n            type: store.type\n          },\n          message: `Successfully deleted store: ${store.name}`\n        }, null, 2)\n      }\n    ]\n  };\n};\n","import { spawn } from 'child_process';\nimport { fileURLToPath } from 'url';\nimport path from 'path';\n\n/**\n * Spawn a background worker process to execute a job\n *\n * The worker runs detached from the parent process, allowing the\n * parent to exit while the worker continues running.\n *\n * @param jobId - The ID of the job to execute\n */\nexport function spawnBackgroundWorker(jobId: string, dataDir: string): void {\n  // Determine the worker script path\n  // In production, this will be the compiled dist file\n  // In development, we need to use tsx to run TypeScript\n  const __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n  // Check if we're running from dist (production) or src (development)\n  const isProduction = __dirname.includes('/dist/');\n\n  let command: string;\n  let args: string[];\n\n  if (isProduction) {\n    // Production: Use Node.js directly with compiled file\n    const workerScript = path.join(__dirname, 'background-worker-cli.js');\n    command = process.execPath; // Use the same Node.js binary\n    args = [workerScript, jobId];\n  } else {\n    // Development: Use tsx to run TypeScript directly\n    const workerScript = path.join(__dirname, 'background-worker-cli.ts');\n    command = 'npx';\n    args = ['tsx', workerScript, jobId];\n  }\n\n  // Spawn the worker process\n  const worker = spawn(command, args, {\n    detached: true,      // Detach from parent process\n    stdio: 'ignore',     // Don't pipe stdio (fully independent)\n    env: {\n      ...process.env,    // Inherit environment variables\n      BLUERA_DATA_DIR: dataDir  // Pass dataDir to worker\n    }\n  });\n\n  // Unref the worker so the parent can exit\n  worker.unref();\n}\n","import { z } from 'zod';\nimport type { CommandDefinition } from './registry.js';\nimport type {\n  CheckJobStatusArgs,\n  ListJobsArgs,\n  CancelJobArgs\n} from '../schemas/index.js';\nimport {\n  handleCheckJobStatus,\n  handleListJobs,\n  handleCancelJob\n} from '../handlers/job.handler.js';\n\n/**\n * Job management commands for the execute meta-tool\n *\n * These commands wrap the existing job handlers, providing\n * a unified interface through the execute command.\n *\n * Note: Type assertions are necessary here because CommandHandler uses\n * Record<string, unknown> for generic command args, while handlers expect\n * specific typed args. Zod validates at runtime before the cast.\n */\n/* eslint-disable @typescript-eslint/consistent-type-assertions */\nexport const jobCommands: CommandDefinition[] = [\n  {\n    name: 'jobs',\n    description: 'List all background jobs',\n    argsSchema: z.object({\n      activeOnly: z.boolean().optional().describe('Only show active jobs'),\n      status: z.enum(['pending', 'running', 'completed', 'failed', 'cancelled'])\n        .optional()\n        .describe('Filter by job status')\n    }),\n    handler: (args, context) => handleListJobs(args as unknown as ListJobsArgs, context)\n  },\n  {\n    name: 'job:status',\n    description: 'Check the status of a specific background job',\n    argsSchema: z.object({\n      jobId: z.string().min(1).describe('Job ID to check')\n    }),\n    handler: (args, context) => handleCheckJobStatus(args as unknown as CheckJobStatusArgs, context)\n  },\n  {\n    name: 'job:cancel',\n    description: 'Cancel a running or pending background job',\n    argsSchema: z.object({\n      jobId: z.string().min(1).describe('Job ID to cancel')\n    }),\n    handler: (args, context) => handleCancelJob(args as unknown as CancelJobArgs, context)\n  }\n];\n/* eslint-enable @typescript-eslint/consistent-type-assertions */\n","import type { ToolHandler, ToolResponse } from '../types.js';\nimport type {\n  CheckJobStatusArgs,\n  ListJobsArgs,\n  CancelJobArgs\n} from '../schemas/index.js';\nimport {\n  CheckJobStatusArgsSchema,\n  ListJobsArgsSchema,\n  CancelJobArgsSchema\n} from '../schemas/index.js';\nimport { JobService } from '../../services/job.service.js';\n\n/**\n * Handle check_job_status requests\n *\n * Retrieves the current status of a background job.\n */\nexport const handleCheckJobStatus: ToolHandler<CheckJobStatusArgs> = (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = CheckJobStatusArgsSchema.parse(args);\n\n  const { options } = context;\n\n  const jobService = new JobService(options.dataDir);\n  const job = jobService.getJob(validated.jobId);\n\n  if (!job) {\n    throw new Error(`Job not found: ${validated.jobId}`);\n  }\n\n  return Promise.resolve({\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(job, null, 2)\n      }\n    ]\n  });\n};\n\n/**\n * Handle list_jobs requests\n *\n * Lists all jobs with optional filtering by status or active status.\n */\nexport const handleListJobs: ToolHandler<ListJobsArgs> = (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = ListJobsArgsSchema.parse(args);\n\n  const { options } = context;\n\n  const jobService = new JobService(options.dataDir);\n\n  let jobs;\n  if (validated.activeOnly === true) {\n    jobs = jobService.listActiveJobs();\n  } else if (validated.status !== undefined) {\n    jobs = jobService.listJobs(validated.status);\n  } else {\n    jobs = jobService.listJobs();\n  }\n\n  return Promise.resolve({\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({ jobs }, null, 2)\n      }\n    ]\n  });\n};\n\n/**\n * Handle cancel_job requests\n *\n * Cancels a running or pending background job.\n * Kills the worker process if it exists.\n */\nexport const handleCancelJob: ToolHandler<CancelJobArgs> = (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = CancelJobArgsSchema.parse(args);\n\n  const { options } = context;\n\n  const jobService = new JobService(options.dataDir);\n  const result = jobService.cancelJob(validated.jobId);\n\n  if (!result.success) {\n    throw new Error(result.error.message);\n  }\n\n  const job = jobService.getJob(validated.jobId);\n\n  return Promise.resolve({\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          success: true,\n          job,\n          message: 'Job cancelled successfully'\n        }, null, 2)\n      }\n    ]\n  });\n};\n","import { z } from 'zod';\nimport type { CommandDefinition } from './registry.js';\nimport type { ToolResponse } from '../types.js';\nimport { commandRegistry, generateHelp } from './registry.js';\n\n/**\n * Meta commands for introspection and help\n *\n * These commands provide self-documentation for the execute tool,\n * allowing users to discover available commands and their usage.\n */\nexport const metaCommands: CommandDefinition[] = [\n  {\n    name: 'commands',\n    description: 'List all available commands',\n    handler: (): Promise<ToolResponse> => {\n      const commands = commandRegistry.all();\n      const commandList = commands.map(cmd => ({\n        name: cmd.name,\n        description: cmd.description\n      }));\n\n      return Promise.resolve({\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify({ commands: commandList }, null, 2)\n          }\n        ]\n      });\n    }\n  },\n  {\n    name: 'help',\n    description: 'Show help for a specific command or list all commands',\n    argsSchema: z.object({\n      command: z.string().optional().describe('Command name to get help for')\n    }),\n    handler: (args: Record<string, unknown>): Promise<ToolResponse> => {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      const commandName = args['command'] as string | undefined;\n      const helpText = generateHelp(commandName);\n\n      return Promise.resolve({\n        content: [\n          {\n            type: 'text' as const,\n            text: helpText\n          }\n        ]\n      });\n    }\n  }\n];\n","/**\n * Command registration for the execute meta-tool\n *\n * This module registers all commands with the command registry.\n * Import this module to ensure all commands are available.\n */\n\nimport { commandRegistry } from './registry.js';\nimport { storeCommands } from './store.commands.js';\nimport { jobCommands } from './job.commands.js';\nimport { metaCommands } from './meta.commands.js';\n\n// Register all commands\ncommandRegistry.registerAll(storeCommands);\ncommandRegistry.registerAll(jobCommands);\ncommandRegistry.registerAll(metaCommands);\n\n// Re-export for convenience\nexport { commandRegistry, executeCommand, generateHelp } from './registry.js';\nexport type { CommandDefinition, CommandHandler } from './registry.js';\n","import type { ToolHandler, ToolResponse } from '../types.js';\nimport type { ExecuteArgs } from '../schemas/index.js';\nimport { ExecuteArgsSchema } from '../schemas/index.js';\n// Import commands module to register all commands\nimport '../commands/index.js';\nimport { executeCommand } from '../commands/index.js';\n\n/**\n * Handle execute requests\n *\n * This is the meta-tool handler that routes to registered commands.\n * It consolidates store and job management into a single tool surface.\n */\nexport const handleExecute: ToolHandler<ExecuteArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = ExecuteArgsSchema.parse(args);\n\n  const commandArgs = validated.args ?? {};\n\n  return executeCommand(validated.command, commandArgs, context);\n};\n"],"mappings":"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","names":["responseJson","z","lines","z","__dirname","z","z","z","z","z","logger"]}