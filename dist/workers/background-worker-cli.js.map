{"version":3,"sources":["../../src/workers/background-worker.ts","../../src/workers/pid-file.ts","../../src/workers/background-worker-cli.ts"],"sourcesContent":["import { createHash } from 'node:crypto';\nimport { IntelligentCrawler, type CrawlProgress } from '../crawl/intelligent-crawler.js';\nimport { IndexService } from '../services/index.service.js';\nimport { JobService } from '../services/job.service.js';\nimport { StoreService } from '../services/store.service.js';\nimport { createStoreId, createDocumentId } from '../types/brands.js';\nimport type { EmbeddingEngine } from '../db/embeddings.js';\nimport type { LanceStore } from '../db/lance.js';\nimport type { Document } from '../types/document.js';\nimport type { Job } from '../types/job.js';\n\n/**\n * Calculate index progress as a percentage, handling division by zero.\n * @param current - Current number of items processed\n * @param total - Total number of items (may be 0)\n * @param scale - Scale factor for progress (default 100 for 0-100%)\n * @returns Progress value, or 0 if total is 0\n */\nexport function calculateIndexProgress(\n  current: number,\n  total: number,\n  scale: number = 100\n): number {\n  if (total === 0) return 0;\n  return (current / total) * scale;\n}\n\nexport class BackgroundWorker {\n  constructor(\n    private readonly jobService: JobService,\n    private readonly storeService: StoreService,\n    private readonly indexService: IndexService,\n    private readonly lanceStore: LanceStore,\n    private readonly embeddingEngine: EmbeddingEngine\n  ) {}\n\n  /**\n   * Execute a job based on its type\n   */\n  async executeJob(jobId: string): Promise<void> {\n    const job = this.jobService.getJob(jobId);\n\n    if (!job) {\n      throw new Error(`Job ${jobId} not found`);\n    }\n\n    try {\n      // Update to running status\n      this.jobService.updateJob(jobId, {\n        status: 'running',\n        message: `Starting ${job.type} operation...`,\n        progress: 0,\n        details: { startedAt: new Date().toISOString() },\n      });\n\n      // Execute based on job type\n      switch (job.type) {\n        case 'clone':\n          await this.executeCloneJob(job);\n          break;\n        case 'index':\n          await this.executeIndexJob(job);\n          break;\n        case 'crawl':\n          await this.executeCrawlJob(job);\n          break;\n        default:\n          throw new Error(`Unknown job type: ${String(job.type)}`);\n      }\n\n      // Mark as completed\n      this.jobService.updateJob(jobId, {\n        status: 'completed',\n        progress: 100,\n        message: `${job.type} operation completed successfully`,\n        details: { completedAt: new Date().toISOString() },\n      });\n    } catch (error) {\n      // Mark as failed\n      const errorDetails: Record<string, unknown> = {\n        completedAt: new Date().toISOString(),\n      };\n      if (error instanceof Error && error.stack !== undefined) {\n        errorDetails['error'] = error.stack;\n      } else {\n        errorDetails['error'] = String(error);\n      }\n      this.jobService.updateJob(jobId, {\n        status: 'failed',\n        message: error instanceof Error ? error.message : 'Unknown error',\n        details: errorDetails,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a clone job (git clone + initial indexing)\n   */\n  private async executeCloneJob(job: Job): Promise<void> {\n    const { storeId } = job.details;\n\n    if (storeId === undefined || typeof storeId !== 'string') {\n      throw new Error('Store ID required for clone job');\n    }\n\n    // Get the store\n    const store = await this.storeService.get(createStoreId(storeId));\n    if (!store) {\n      throw new Error(`Store ${storeId} not found`);\n    }\n\n    // Clone is already done by the time the job is created\n    // (happens in StoreService.create), so we just need to index\n\n    // Update progress - cloning considered done (30%)\n    this.jobService.updateJob(job.id, {\n      status: 'running',\n      message: 'Repository cloned, starting indexing...',\n      progress: 30,\n    });\n\n    // Index the repository with progress updates\n    const result = await this.indexService.indexStore(\n      store,\n      (event: { type: string; current: number; total: number; message: string }) => {\n        // Check if job was cancelled\n        const currentJob = this.jobService.getJob(job.id);\n        if (currentJob?.status === 'cancelled') {\n          throw new Error('Job cancelled by user');\n        }\n\n        // Indexing is 70% of total progress (30-100%)\n        const indexProgress = calculateIndexProgress(event.current, event.total, 70);\n        const totalProgress = 30 + indexProgress;\n\n        this.jobService.updateJob(job.id, {\n          message: `Indexed ${String(event.current)}/${String(event.total)} files`,\n          progress: Math.min(99, totalProgress), // Cap at 99 until fully complete\n          details: {\n            filesProcessed: event.current,\n            totalFiles: event.total,\n          },\n        });\n      }\n    );\n\n    if (!result.success) {\n      throw result.error;\n    }\n  }\n\n  /**\n   * Execute an index job (re-indexing existing store)\n   */\n  private async executeIndexJob(job: Job): Promise<void> {\n    const { storeId } = job.details;\n\n    if (storeId === undefined || typeof storeId !== 'string') {\n      throw new Error('Store ID required for index job');\n    }\n\n    // Get the store\n    const store = await this.storeService.getByIdOrName(createStoreId(storeId));\n    if (!store) {\n      throw new Error(`Store ${storeId} not found`);\n    }\n\n    // Index with progress updates\n    const result = await this.indexService.indexStore(\n      store,\n      (event: { type: string; current: number; total: number; message: string }) => {\n        // Check if job was cancelled\n        const currentJob = this.jobService.getJob(job.id);\n        if (currentJob?.status === 'cancelled') {\n          throw new Error('Job cancelled by user');\n        }\n\n        const progress = calculateIndexProgress(event.current, event.total);\n\n        this.jobService.updateJob(job.id, {\n          message: `Indexed ${String(event.current)}/${String(event.total)} files`,\n          progress: Math.min(99, progress), // Cap at 99 until fully complete\n          details: {\n            filesProcessed: event.current,\n            totalFiles: event.total,\n          },\n        });\n      }\n    );\n\n    if (!result.success) {\n      throw result.error;\n    }\n  }\n\n  /**\n   * Execute a crawl job (web crawling + indexing)\n   */\n  private async executeCrawlJob(job: Job): Promise<void> {\n    const { storeId, url, crawlInstruction, extractInstruction, maxPages, simple, useHeadless } =\n      job.details;\n\n    if (storeId === undefined || typeof storeId !== 'string') {\n      throw new Error('Store ID required for crawl job');\n    }\n    if (url === undefined || typeof url !== 'string') {\n      throw new Error('URL required for crawl job');\n    }\n\n    // Get the store\n    const store = await this.storeService.get(createStoreId(storeId));\n    if (store?.type !== 'web') {\n      throw new Error(`Web store ${storeId} not found`);\n    }\n\n    const resolvedMaxPages = typeof maxPages === 'number' ? maxPages : 50;\n    const crawler = new IntelligentCrawler();\n\n    // Listen for progress events\n    crawler.on('progress', (progress: CrawlProgress) => {\n      // Check if job was cancelled - just return early, for-await loop will throw and finally will cleanup\n      const currentJob = this.jobService.getJob(job.id);\n      if (currentJob?.status === 'cancelled') {\n        return;\n      }\n\n      // Crawling is 80% of total progress (0-80%)\n      const crawlProgress = (progress.pagesVisited / resolvedMaxPages) * 80;\n\n      this.jobService.updateJob(job.id, {\n        message:\n          progress.message ??\n          `Crawling page ${String(progress.pagesVisited)}/${String(resolvedMaxPages)}`,\n        progress: Math.min(80, crawlProgress),\n        details: { pagesCrawled: progress.pagesVisited },\n      });\n    });\n\n    try {\n      await this.lanceStore.initialize(store.id);\n      const docs: Document[] = [];\n\n      // Build crawl options, only including defined values\n      const crawlOptions: {\n        maxPages: number;\n        simple: boolean;\n        useHeadless: boolean;\n        crawlInstruction?: string;\n        extractInstruction?: string;\n      } = {\n        maxPages: resolvedMaxPages,\n        simple: simple ?? false,\n        useHeadless: useHeadless ?? false,\n      };\n      if (crawlInstruction !== undefined) {\n        crawlOptions.crawlInstruction = crawlInstruction;\n      }\n      if (extractInstruction !== undefined) {\n        crawlOptions.extractInstruction = extractInstruction;\n      }\n\n      // Crawl pages using IntelligentCrawler\n      for await (const result of crawler.crawl(url, crawlOptions)) {\n        // Check cancellation between pages\n        const currentJob = this.jobService.getJob(job.id);\n        if (currentJob?.status === 'cancelled') {\n          throw new Error('Job cancelled by user');\n        }\n\n        // Embed and index the content (use extracted if available, otherwise markdown)\n        const contentToEmbed = result.extracted ?? result.markdown;\n        const vector = await this.embeddingEngine.embed(contentToEmbed);\n\n        docs.push({\n          id: createDocumentId(`${store.id}-${createHash('md5').update(result.url).digest('hex')}`),\n          content: contentToEmbed,\n          vector,\n          metadata: {\n            type: 'web',\n            storeId: store.id,\n            url: result.url,\n            title: result.title,\n            extracted: result.extracted !== undefined,\n            depth: result.depth,\n            indexedAt: new Date(),\n          },\n        });\n      }\n\n      // Index all documents (remaining 20%)\n      if (docs.length > 0) {\n        this.jobService.updateJob(job.id, {\n          message: 'Indexing crawled documents...',\n          progress: 85,\n        });\n\n        await this.lanceStore.addDocuments(store.id, docs);\n        // Create FTS index for full-text search\n        await this.lanceStore.createFtsIndex(store.id);\n      }\n\n      this.jobService.updateJob(job.id, {\n        message: `Crawled and indexed ${String(docs.length)} pages`,\n        progress: 100,\n        details: { pagesCrawled: docs.length },\n      });\n    } finally {\n      await crawler.stop();\n    }\n  }\n}\n","import fs from 'fs';\nimport path from 'path';\n\n/**\n * Result of a PID file delete operation.\n * Delete operations are best-effort and should not throw.\n */\nexport interface PidFileResult {\n  success: boolean;\n  error?: Error;\n}\n\n/**\n * Context for PID file deletion - indicates when the delete is happening.\n * Used for logging/debugging purposes.\n */\nexport type PidFileDeleteContext = 'sigterm' | 'success' | 'failure';\n\n/**\n * Write PID file - CRITICAL operation that must succeed.\n *\n * If the PID file cannot be written, the job cannot be cancelled through\n * the job management system. This is a critical failure and the job\n * should not proceed.\n *\n * @param pidFile - Absolute path to the PID file\n * @param pid - Process ID to write\n * @throws Error if PID file cannot be written\n */\nexport function writePidFile(pidFile: string, pid: number): void {\n  try {\n    fs.writeFileSync(pidFile, pid.toString(), 'utf-8');\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new Error(\n      `CRITICAL: Failed to write PID file ${pidFile}. ` +\n        `Job cannot be cancelled without PID file. ` +\n        `Original error: ${message}`\n    );\n  }\n}\n\n/**\n * Delete PID file - best-effort cleanup during shutdown.\n *\n * This operation should NEVER throw. During process shutdown (SIGTERM,\n * job success, job failure), failing to delete a PID file should not\n * prevent the process from exiting cleanly.\n *\n * Stale PID files are cleaned up by JobService.cleanupOldJobs().\n *\n * @param pidFile - Absolute path to the PID file\n * @param _context - Context indicating when the delete is happening (for future logging)\n * @returns Result indicating success or failure with error details\n */\nexport function deletePidFile(pidFile: string, _context: PidFileDeleteContext): PidFileResult {\n  try {\n    fs.unlinkSync(pidFile);\n    return { success: true };\n  } catch (error) {\n    // ENOENT = file doesn't exist - that's success (nothing to delete)\n    if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {\n      return { success: true };\n    }\n    // Any other error = failure (permission denied, etc.)\n    return {\n      success: false,\n      error: error instanceof Error ? error : new Error(String(error)),\n    };\n  }\n}\n\n/**\n * Build the path to a PID file for a given job.\n *\n * @param jobsDir - Directory where job files are stored\n * @param jobId - Job identifier\n * @returns Absolute path to the PID file\n */\nexport function buildPidFilePath(jobsDir: string, jobId: string): string {\n  return path.join(jobsDir, `${jobId}.pid`);\n}\n","#!/usr/bin/env node\nimport { BackgroundWorker } from './background-worker.js';\nimport { writePidFile, deletePidFile, buildPidFilePath } from './pid-file.js';\nimport { createServices } from '../services/index.js';\nimport { JobService } from '../services/job.service.js';\n\n/**\n * Background worker CLI entry point\n *\n * Usage: background-worker-cli <job-id>\n *\n * This process runs detached from the parent and executes a single job.\n */\n\nasync function main(): Promise<void> {\n  const jobId = process.argv[2];\n  const dataDir = process.env['BLUERA_DATA_DIR'];\n\n  if (jobId === undefined || jobId === '') {\n    console.error('Error: Job ID required');\n    console.error('Usage: background-worker-cli <job-id>');\n    process.exit(1);\n  }\n\n  // Initialize services\n  const jobService = new JobService(dataDir);\n  const services = await createServices(undefined, dataDir);\n\n  // Write PID file for job cancellation - CRITICAL: must succeed or job cannot be cancelled\n  const pidFile = buildPidFilePath(\n    jobService['jobsDir'], // Access private field for PID path\n    jobId\n  );\n\n  try {\n    writePidFile(pidFile, process.pid);\n  } catch (error) {\n    // CRITICAL: Cannot proceed without PID file - job would be uncancellable\n    console.error(error instanceof Error ? error.message : String(error));\n    process.exit(1);\n  }\n\n  // Handle SIGTERM for graceful shutdown\n  process.on('SIGTERM', () => {\n    console.log(`[${jobId}] Received SIGTERM, cancelling job...`);\n    jobService.updateJob(jobId, {\n      status: 'cancelled',\n      message: 'Job cancelled by user',\n    });\n\n    // Clean up PID file (best-effort - don't block shutdown)\n    const deleteResult = deletePidFile(pidFile, 'sigterm');\n    if (!deleteResult.success && deleteResult.error !== undefined) {\n      console.error(\n        `Warning: Could not remove PID file during SIGTERM: ${deleteResult.error.message}`\n      );\n    }\n\n    process.exit(0);\n  });\n\n  // Create worker and execute job\n  const worker = new BackgroundWorker(\n    jobService,\n    services.store,\n    services.index,\n    services.lance,\n    services.embeddings\n  );\n\n  try {\n    await worker.executeJob(jobId);\n\n    // Clean up PID file on success (best-effort - don't change exit code)\n    const successCleanup = deletePidFile(pidFile, 'success');\n    if (!successCleanup.success && successCleanup.error !== undefined) {\n      console.error(\n        `Warning: Could not remove PID file after success: ${successCleanup.error.message}`\n      );\n    }\n\n    console.log(`[${jobId}] Job completed successfully`);\n    process.exit(0);\n  } catch (error) {\n    // Job service already updated with failure status in BackgroundWorker\n    console.error(`[${jobId}] Job failed:`, error);\n\n    // Clean up PID file on failure (best-effort - exit code reflects job failure)\n    const failureCleanup = deletePidFile(pidFile, 'failure');\n    if (!failureCleanup.success && failureCleanup.error !== undefined) {\n      console.error(\n        `Warning: Could not remove PID file after failure: ${failureCleanup.error.message}`\n      );\n    }\n\n    process.exit(1);\n  }\n}\n\nmain().catch((error: unknown) => {\n  console.error('Fatal error in background worker:', error);\n  process.exit(1);\n});\n"],"mappings":"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","names":[]}