{"version":3,"sources":["../../src/workers/background-worker-cli.ts","../../src/workers/background-worker.ts"],"sourcesContent":["#!/usr/bin/env node\nimport fs from 'fs';\nimport path from 'path';\nimport { JobService } from '../services/job.service.js';\nimport { BackgroundWorker } from './background-worker.js';\nimport { createServices } from '../services/index.js';\n\n/**\n * Background worker CLI entry point\n *\n * Usage: background-worker-cli <job-id>\n *\n * This process runs detached from the parent and executes a single job.\n */\n\nasync function main(): Promise<void> {\n  const jobId = process.argv[2];\n  const dataDir = process.env['BLUERA_DATA_DIR'];\n\n  if (jobId === undefined || jobId === '') {\n    console.error('Error: Job ID required');\n    console.error('Usage: background-worker-cli <job-id>');\n    process.exit(1);\n  }\n\n  // Initialize services\n  const jobService = new JobService(dataDir);\n  const services = await createServices(undefined, dataDir);\n\n  // Write PID file for job cancellation\n  const pidFile = path.join(\n    jobService['jobsDir'], // Access private field for PID path\n    `${jobId}.pid`\n  );\n\n  try {\n    fs.writeFileSync(pidFile, process.pid.toString(), 'utf-8');\n  } catch (error) {\n    console.error('Warning: Could not write PID file:', error);\n  }\n\n  // Handle SIGTERM for graceful shutdown\n  process.on('SIGTERM', () => {\n    console.log(`[${jobId}] Received SIGTERM, cancelling job...`);\n    jobService.updateJob(jobId, {\n      status: 'cancelled',\n      message: 'Job cancelled by user'\n    });\n\n    // Clean up PID file\n    try {\n      if (fs.existsSync(pidFile)) {\n        fs.unlinkSync(pidFile);\n      }\n    } catch (error) {\n      console.error('Warning: Could not remove PID file:', error);\n    }\n\n    process.exit(0);\n  });\n\n  // Create worker and execute job\n  const worker = new BackgroundWorker(\n    jobService,\n    services.store,\n    services.index,\n    services.lance,\n    services.embeddings\n  );\n\n  try {\n    await worker.executeJob(jobId);\n\n    // Clean up PID file on success\n    try {\n      if (fs.existsSync(pidFile)) {\n        fs.unlinkSync(pidFile);\n      }\n    } catch (error) {\n      console.error('Warning: Could not remove PID file:', error);\n    }\n\n    console.log(`[${jobId}] Job completed successfully`);\n    process.exit(0);\n  } catch (error) {\n    // Job service already updated with failure status in BackgroundWorker\n    console.error(`[${jobId}] Job failed:`, error);\n\n    // Clean up PID file on failure\n    try {\n      if (fs.existsSync(pidFile)) {\n        fs.unlinkSync(pidFile);\n      }\n    } catch (cleanupError) {\n      console.error('Warning: Could not remove PID file:', cleanupError);\n    }\n\n    process.exit(1);\n  }\n}\n\nmain().catch((error: unknown) => {\n  console.error('Fatal error in background worker:', error);\n  process.exit(1);\n});\n","import { createHash } from 'node:crypto';\nimport { JobService } from '../services/job.service.js';\nimport { StoreService } from '../services/store.service.js';\nimport { IndexService } from '../services/index.service.js';\nimport type { LanceStore } from '../db/lance.js';\nimport type { EmbeddingEngine } from '../db/embeddings.js';\nimport { IntelligentCrawler, type CrawlProgress } from '../crawl/intelligent-crawler.js';\nimport type { Job } from '../types/job.js';\nimport type { Document } from '../types/document.js';\nimport { createStoreId, createDocumentId } from '../types/brands.js';\n\n/**\n * Calculate index progress as a percentage, handling division by zero.\n * @param current - Current number of items processed\n * @param total - Total number of items (may be 0)\n * @param scale - Scale factor for progress (default 100 for 0-100%)\n * @returns Progress value, or 0 if total is 0\n */\nexport function calculateIndexProgress(current: number, total: number, scale: number = 100): number {\n  if (total === 0) return 0;\n  return (current / total) * scale;\n}\n\nexport class BackgroundWorker {\n  constructor(\n    private readonly jobService: JobService,\n    private readonly storeService: StoreService,\n    private readonly indexService: IndexService,\n    private readonly lanceStore: LanceStore,\n    private readonly embeddingEngine: EmbeddingEngine\n  ) {}\n\n  /**\n   * Execute a job based on its type\n   */\n  async executeJob(jobId: string): Promise<void> {\n    const job = this.jobService.getJob(jobId);\n\n    if (!job) {\n      throw new Error(`Job ${jobId} not found`);\n    }\n\n    try {\n      // Update to running status\n      this.jobService.updateJob(jobId, {\n        status: 'running',\n        message: `Starting ${job.type} operation...`,\n        progress: 0,\n        details: { startedAt: new Date().toISOString() }\n      });\n\n      // Execute based on job type\n      switch (job.type) {\n        case 'clone':\n          await this.executeCloneJob(job);\n          break;\n        case 'index':\n          await this.executeIndexJob(job);\n          break;\n        case 'crawl':\n          await this.executeCrawlJob(job);\n          break;\n        default:\n          throw new Error(`Unknown job type: ${String(job.type)}`);\n      }\n\n      // Mark as completed\n      this.jobService.updateJob(jobId, {\n        status: 'completed',\n        progress: 100,\n        message: `${job.type} operation completed successfully`,\n        details: { completedAt: new Date().toISOString() }\n      });\n    } catch (error) {\n      // Mark as failed\n      const errorDetails: Record<string, unknown> = {\n        completedAt: new Date().toISOString()\n      };\n      if (error instanceof Error && error.stack !== undefined) {\n        errorDetails['error'] = error.stack;\n      } else {\n        errorDetails['error'] = String(error);\n      }\n      this.jobService.updateJob(jobId, {\n        status: 'failed',\n        message: error instanceof Error ? error.message : 'Unknown error',\n        details: errorDetails\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a clone job (git clone + initial indexing)\n   */\n  private async executeCloneJob(job: Job): Promise<void> {\n    const { storeId } = job.details;\n\n    if (storeId === undefined || typeof storeId !== 'string') {\n      throw new Error('Store ID required for clone job');\n    }\n\n    // Get the store\n    const store = await this.storeService.get(createStoreId(storeId));\n    if (!store) {\n      throw new Error(`Store ${storeId} not found`);\n    }\n\n    // Clone is already done by the time the job is created\n    // (happens in StoreService.create), so we just need to index\n\n    // Update progress - cloning considered done (30%)\n    this.jobService.updateJob(job.id, {\n      status: 'running',\n      message: 'Repository cloned, starting indexing...',\n      progress: 30\n    });\n\n    // Index the repository with progress updates\n    const result = await this.indexService.indexStore(store, (event: { type: string; current: number; total: number; message: string }) => {\n      // Check if job was cancelled\n      const currentJob = this.jobService.getJob(job.id);\n      if (currentJob?.status === 'cancelled') {\n        throw new Error('Job cancelled by user');\n      }\n\n      // Indexing is 70% of total progress (30-100%)\n      const indexProgress = calculateIndexProgress(event.current, event.total, 70);\n      const totalProgress = 30 + indexProgress;\n\n      this.jobService.updateJob(job.id, {\n        message: `Indexed ${String(event.current)}/${String(event.total)} files`,\n        progress: Math.min(99, totalProgress), // Cap at 99 until fully complete\n        details: {\n          filesProcessed: event.current,\n          totalFiles: event.total\n        }\n      });\n    });\n\n    if (!result.success) {\n      throw result.error;\n    }\n  }\n\n  /**\n   * Execute an index job (re-indexing existing store)\n   */\n  private async executeIndexJob(job: Job): Promise<void> {\n    const { storeId } = job.details;\n\n    if (storeId === undefined || typeof storeId !== 'string') {\n      throw new Error('Store ID required for index job');\n    }\n\n    // Get the store\n    const store = await this.storeService.getByIdOrName(createStoreId(storeId));\n    if (!store) {\n      throw new Error(`Store ${storeId} not found`);\n    }\n\n    // Index with progress updates\n    const result = await this.indexService.indexStore(store, (event: { type: string; current: number; total: number; message: string }) => {\n      // Check if job was cancelled\n      const currentJob = this.jobService.getJob(job.id);\n      if (currentJob?.status === 'cancelled') {\n        throw new Error('Job cancelled by user');\n      }\n\n      const progress = calculateIndexProgress(event.current, event.total);\n\n      this.jobService.updateJob(job.id, {\n        message: `Indexed ${String(event.current)}/${String(event.total)} files`,\n        progress: Math.min(99, progress), // Cap at 99 until fully complete\n        details: {\n          filesProcessed: event.current,\n          totalFiles: event.total\n        }\n      });\n    });\n\n    if (!result.success) {\n      throw result.error;\n    }\n  }\n\n  /**\n   * Execute a crawl job (web crawling + indexing)\n   */\n  private async executeCrawlJob(job: Job): Promise<void> {\n    const {\n      storeId,\n      url,\n      crawlInstruction,\n      extractInstruction,\n      maxPages,\n      simple,\n      useHeadless,\n    } = job.details;\n\n    if (storeId === undefined || typeof storeId !== 'string') {\n      throw new Error('Store ID required for crawl job');\n    }\n    if (url === undefined || typeof url !== 'string') {\n      throw new Error('URL required for crawl job');\n    }\n\n    // Get the store\n    const store = await this.storeService.get(createStoreId(storeId));\n    if (!store || store.type !== 'web') {\n      throw new Error(`Web store ${storeId} not found`);\n    }\n\n    const resolvedMaxPages = typeof maxPages === 'number' ? maxPages : 50;\n    const crawler = new IntelligentCrawler();\n\n    // Listen for progress events\n    crawler.on('progress', (progress: CrawlProgress) => {\n      // Check if job was cancelled - just return early, for-await loop will throw and finally will cleanup\n      const currentJob = this.jobService.getJob(job.id);\n      if (currentJob?.status === 'cancelled') {\n        return;\n      }\n\n      // Crawling is 80% of total progress (0-80%)\n      const crawlProgress = (progress.pagesVisited / resolvedMaxPages) * 80;\n\n      this.jobService.updateJob(job.id, {\n        message: progress.message ?? `Crawling page ${String(progress.pagesVisited)}/${String(resolvedMaxPages)}`,\n        progress: Math.min(80, crawlProgress),\n        details: { pagesCrawled: progress.pagesVisited }\n      });\n    });\n\n    try {\n      await this.lanceStore.initialize(store.id);\n      const docs: Document[] = [];\n\n      // Build crawl options, only including defined values\n      const crawlOptions: {\n        maxPages: number;\n        simple: boolean;\n        useHeadless: boolean;\n        crawlInstruction?: string;\n        extractInstruction?: string;\n      } = {\n        maxPages: resolvedMaxPages,\n        simple: simple ?? false,\n        useHeadless: useHeadless ?? false,\n      };\n      if (crawlInstruction !== undefined) {\n        crawlOptions.crawlInstruction = crawlInstruction;\n      }\n      if (extractInstruction !== undefined) {\n        crawlOptions.extractInstruction = extractInstruction;\n      }\n\n      // Crawl pages using IntelligentCrawler\n      for await (const result of crawler.crawl(url, crawlOptions)) {\n        // Check cancellation between pages\n        const currentJob = this.jobService.getJob(job.id);\n        if (currentJob?.status === 'cancelled') {\n          throw new Error('Job cancelled by user');\n        }\n\n        // Embed and index the content (use extracted if available, otherwise markdown)\n        const contentToEmbed = result.extracted ?? result.markdown;\n        const vector = await this.embeddingEngine.embed(contentToEmbed);\n\n        docs.push({\n          id: createDocumentId(`${store.id}-${createHash('md5').update(result.url).digest('hex')}`),\n          content: contentToEmbed,\n          vector,\n          metadata: {\n            type: 'web',\n            storeId: store.id,\n            url: result.url,\n            title: result.title,\n            extracted: result.extracted !== undefined,\n            depth: result.depth,\n            indexedAt: new Date(),\n          },\n        });\n      }\n\n      // Index all documents (remaining 20%)\n      if (docs.length > 0) {\n        this.jobService.updateJob(job.id, {\n          message: 'Indexing crawled documents...',\n          progress: 85\n        });\n\n        await this.lanceStore.addDocuments(store.id, docs);\n      }\n\n      this.jobService.updateJob(job.id, {\n        message: `Crawled and indexed ${String(docs.length)} pages`,\n        progress: 100,\n        details: { pagesCrawled: docs.length }\n      });\n    } finally {\n      await crawler.stop();\n    }\n  }\n}\n"],"mappings":"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","names":[]}