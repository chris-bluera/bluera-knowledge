{"version":3,"sources":["../src/services/watch.service.ts"],"sourcesContent":["import { watch, type FSWatcher } from 'chokidar';\nimport type { FileStore, RepoStore } from '../types/store.js';\nimport type { IndexService } from './index.service.js';\nimport type { LanceStore } from '../db/lance.js';\n\nexport class WatchService {\n  private readonly watchers: Map<string, FSWatcher> = new Map();\n  private readonly pendingTimeouts: Map<string, NodeJS.Timeout> = new Map();\n  private readonly indexService: IndexService;\n  private readonly lanceStore: LanceStore;\n\n  constructor(indexService: IndexService, lanceStore: LanceStore) {\n    this.indexService = indexService;\n    this.lanceStore = lanceStore;\n  }\n\n  async watch(\n    store: FileStore | RepoStore,\n    debounceMs = 1000,\n    onReindex?: () => void\n  ): Promise<void> {\n    if (this.watchers.has(store.id)) {\n      return Promise.resolve(); // Already watching\n    }\n\n    let timeout: NodeJS.Timeout | null = null;\n\n    const watcher = watch(store.path, {\n      ignored: /(^|[/\\\\])\\.(git|node_modules|dist|build)/,\n      persistent: true,\n      ignoreInitial: true,\n    });\n\n    const reindexHandler = (): void => {\n      if (timeout) clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        this.pendingTimeouts.delete(store.id);\n        void (async (): Promise<void> => {\n          try {\n            await this.lanceStore.initialize(store.id);\n            await this.indexService.indexStore(store);\n            onReindex?.();\n          } catch (error) {\n            console.error('Error during reindexing:', error);\n          }\n        })();\n      }, debounceMs);\n      this.pendingTimeouts.set(store.id, timeout);\n    };\n\n    watcher.on('all', reindexHandler);\n\n    watcher.on('error', (error) => {\n      console.error('Watcher error:', error);\n    });\n\n    this.watchers.set(store.id, watcher);\n    return Promise.resolve();\n  }\n\n  async unwatch(storeId: string): Promise<void> {\n    // Clear any pending timeout to prevent timer leak\n    const pendingTimeout = this.pendingTimeouts.get(storeId);\n    if (pendingTimeout) {\n      clearTimeout(pendingTimeout);\n      this.pendingTimeouts.delete(storeId);\n    }\n\n    const watcher = this.watchers.get(storeId);\n    if (watcher) {\n      await watcher.close();\n      this.watchers.delete(storeId);\n    }\n  }\n\n  async unwatchAll(): Promise<void> {\n    for (const [id] of this.watchers) {\n      await this.unwatch(id);\n    }\n  }\n}\n"],"mappings":";AAAA,SAAS,aAA6B;AAK/B,IAAM,eAAN,MAAmB;AAAA,EACP,WAAmC,oBAAI,IAAI;AAAA,EAC3C,kBAA+C,oBAAI,IAAI;AAAA,EACvD;AAAA,EACA;AAAA,EAEjB,YAAY,cAA4B,YAAwB;AAC9D,SAAK,eAAe;AACpB,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,MAAM,MACJ,OACA,aAAa,KACb,WACe;AACf,QAAI,KAAK,SAAS,IAAI,MAAM,EAAE,GAAG;AAC/B,aAAO,QAAQ,QAAQ;AAAA,IACzB;AAEA,QAAI,UAAiC;AAErC,UAAM,UAAU,MAAM,MAAM,MAAM;AAAA,MAChC,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,eAAe;AAAA,IACjB,CAAC;AAED,UAAM,iBAAiB,MAAY;AACjC,UAAI,QAAS,cAAa,OAAO;AACjC,gBAAU,WAAW,MAAM;AACzB,aAAK,gBAAgB,OAAO,MAAM,EAAE;AACpC,cAAM,YAA2B;AAC/B,cAAI;AACF,kBAAM,KAAK,WAAW,WAAW,MAAM,EAAE;AACzC,kBAAM,KAAK,aAAa,WAAW,KAAK;AACxC,wBAAY;AAAA,UACd,SAAS,OAAO;AACd,oBAAQ,MAAM,4BAA4B,KAAK;AAAA,UACjD;AAAA,QACF,GAAG;AAAA,MACL,GAAG,UAAU;AACb,WAAK,gBAAgB,IAAI,MAAM,IAAI,OAAO;AAAA,IAC5C;AAEA,YAAQ,GAAG,OAAO,cAAc;AAEhC,YAAQ,GAAG,SAAS,CAAC,UAAU;AAC7B,cAAQ,MAAM,kBAAkB,KAAK;AAAA,IACvC,CAAC;AAED,SAAK,SAAS,IAAI,MAAM,IAAI,OAAO;AACnC,WAAO,QAAQ,QAAQ;AAAA,EACzB;AAAA,EAEA,MAAM,QAAQ,SAAgC;AAE5C,UAAM,iBAAiB,KAAK,gBAAgB,IAAI,OAAO;AACvD,QAAI,gBAAgB;AAClB,mBAAa,cAAc;AAC3B,WAAK,gBAAgB,OAAO,OAAO;AAAA,IACrC;AAEA,UAAM,UAAU,KAAK,SAAS,IAAI,OAAO;AACzC,QAAI,SAAS;AACX,YAAM,QAAQ,MAAM;AACpB,WAAK,SAAS,OAAO,OAAO;AAAA,IAC9B;AAAA,EACF;AAAA,EAEA,MAAM,aAA4B;AAChC,eAAW,CAAC,EAAE,KAAK,KAAK,UAAU;AAChC,YAAM,KAAK,QAAQ,EAAE;AAAA,IACvB;AAAA,EACF;AACF;","names":[]}