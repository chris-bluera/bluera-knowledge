{"version":3,"sources":["../src/mcp/server.ts","../src/analysis/zil/zil-lexer.ts","../src/analysis/zil/zil-special-forms.ts","../src/analysis/zil/zil-parser.ts","../src/analysis/zil/zil-adapter.ts","../src/mcp/commands/job.commands.ts","../src/mcp/schemas/index.ts","../src/mcp/handlers/job.handler.ts","../src/mcp/commands/meta.commands.ts","../src/mcp/commands/registry.ts","../src/mcp/commands/store.commands.ts","../src/mcp/handlers/store.handler.ts","../src/workers/spawn-worker.ts","../src/mcp/commands/sync.commands.ts","../src/services/store-definition.service.ts","../src/types/store-definition.ts","../src/mcp/commands/index.ts","../src/mcp/handlers/execute.handler.ts","../src/services/token.service.ts","../src/mcp/cache.ts","../src/mcp/handlers/search.handler.ts","../src/mcp/handlers/index.ts"],"sourcesContent":["import { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';\nimport { AdapterRegistry } from '../analysis/adapter-registry.js';\nimport { ZilAdapter } from '../analysis/zil/index.js';\nimport { createLogger } from '../logging/index.js';\nimport { createServices, destroyServices } from '../services/index.js';\nimport { handleExecute } from './handlers/execute.handler.js';\nimport { tools } from './handlers/index.js';\nimport { ExecuteArgsSchema } from './schemas/index.js';\nimport type { MCPServerOptions } from './types.js';\n\nconst logger = createLogger('mcp-server');\n\n// Register built-in language adapters\nconst registry = AdapterRegistry.getInstance();\nif (!registry.hasExtension('.zil')) {\n  registry.register(new ZilAdapter());\n}\n\n// eslint-disable-next-line @typescript-eslint/no-deprecated\nexport function createMCPServer(options: MCPServerOptions): Server {\n  // eslint-disable-next-line @typescript-eslint/no-deprecated\n  const server = new Server(\n    {\n      name: 'bluera-knowledge',\n      version: '1.0.0',\n    },\n    {\n      capabilities: {\n        tools: {},\n      },\n    }\n  );\n\n  // List available tools - consolidated from 10 tools to 3 for reduced context overhead\n  server.setRequestHandler(ListToolsRequestSchema, () => {\n    return Promise.resolve({\n      tools: [\n        // Native search tool with full schema (most used, benefits from detailed params)\n        {\n          name: 'search',\n          description:\n            'Search all indexed knowledge stores with pattern detection and AI-optimized results. Returns structured code units with progressive context layers.',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              query: {\n                type: 'string',\n                description:\n                  'Search query (can include type signatures, constraints, or natural language)',\n              },\n              intent: {\n                type: 'string',\n                enum: [\n                  'find-pattern',\n                  'find-implementation',\n                  'find-usage',\n                  'find-definition',\n                  'find-documentation',\n                ],\n                description: 'Search intent for better ranking',\n              },\n              mode: {\n                type: 'string',\n                enum: ['vector', 'fts', 'hybrid'],\n                default: 'hybrid',\n                description:\n                  'Search mode: vector (embeddings only), fts (full-text only), hybrid (both, default)',\n              },\n              detail: {\n                type: 'string',\n                enum: ['minimal', 'contextual', 'full'],\n                default: 'minimal',\n                description:\n                  'Context detail level: minimal (summary only), contextual (+ imports/types), full (+ complete code)',\n              },\n              limit: {\n                type: 'number',\n                default: 10,\n                description: 'Maximum number of results',\n              },\n              stores: {\n                type: 'array',\n                items: { type: 'string' },\n                description: 'Specific store IDs to search (optional)',\n              },\n              threshold: {\n                type: 'number',\n                description: 'Minimum normalized score (0-1). Filters out low-relevance results.',\n              },\n              minRelevance: {\n                type: 'number',\n                description:\n                  'Minimum raw cosine similarity (0-1). Returns empty if no results meet threshold. Use to filter irrelevant results.',\n              },\n            },\n            required: ['query'],\n          },\n        },\n        // Native get_full_context tool (frequently used after search)\n        {\n          name: 'get_full_context',\n          description:\n            'Get complete code and context for a specific search result by ID. Use this after search to get full implementation details.',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              resultId: {\n                type: 'string',\n                description: 'Result ID from previous search',\n              },\n            },\n            required: ['resultId'],\n          },\n        },\n        // Meta-tool for store and job management (consolidates 8 tools into 1)\n        {\n          name: 'execute',\n          description:\n            'Execute store/job management commands. Commands: stores, store:info, store:create, store:index, store:delete, jobs, job:status, job:cancel, help, commands',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              command: {\n                type: 'string',\n                description: 'Command to execute (e.g., \"stores\", \"store:create\", \"jobs\", \"help\")',\n              },\n              args: {\n                type: 'object',\n                description: 'Command arguments (e.g., {store: \"mystore\"} for store:info)',\n              },\n            },\n            required: ['command'],\n          },\n        },\n      ],\n    });\n  });\n\n  // Handle tool calls\n  server.setRequestHandler(CallToolRequestSchema, async (request) => {\n    const { name, arguments: args } = request.params;\n    const startTime = Date.now();\n\n    logger.info({ tool: name, args: JSON.stringify(args) }, 'Tool invoked');\n\n    // Create services once (needed by all handlers)\n    const services = await createServices(options.config, options.dataDir, options.projectRoot);\n    const context = { services, options };\n\n    try {\n      let result;\n\n      // Handle execute meta-tool\n      if (name === 'execute') {\n        const validated = ExecuteArgsSchema.parse(args ?? {});\n        result = await handleExecute(validated, context);\n      } else {\n        // Find handler in registry for native tools (search, get_full_context)\n        const tool = tools.find((t) => t.name === name);\n        if (tool === undefined) {\n          throw new Error(`Unknown tool: ${name}`);\n        }\n\n        // Validate arguments with Zod\n        const validated = tool.schema.parse(args ?? {});\n\n        // Execute handler with context\n        result = await tool.handler(validated, context);\n      }\n\n      const durationMs = Date.now() - startTime;\n      logger.info({ tool: name, durationMs }, 'Tool completed');\n\n      return result;\n    } catch (error) {\n      const durationMs = Date.now() - startTime;\n      logger.error(\n        {\n          tool: name,\n          durationMs,\n          error: error instanceof Error ? error.message : String(error),\n        },\n        'Tool execution failed'\n      );\n      throw error;\n    } finally {\n      // Always cleanup services to prevent resource leaks\n      // (PythonBridge processes, LanceDB connections)\n      await destroyServices(services);\n    }\n  });\n\n  return server;\n}\n\nexport async function runMCPServer(options: MCPServerOptions): Promise<void> {\n  logger.info(\n    {\n      dataDir: options.dataDir,\n      projectRoot: options.projectRoot,\n    },\n    'MCP server starting'\n  );\n\n  const server = createMCPServer(options);\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n\n  logger.info('MCP server connected to stdio transport');\n}\n\n// Run the server only when this file is executed directly (not imported by CLI)\n// Check if we're running as the mcp/server entry point vs being imported by index.js\nconst scriptPath = process.argv[1] ?? '';\nconst isMCPServerEntry = scriptPath.endsWith('mcp/server.js') || scriptPath.endsWith('mcp/server');\n\nif (isMCPServerEntry) {\n  const projectRoot = process.env['PROJECT_ROOT'];\n  if (projectRoot === undefined) {\n    throw new Error('PROJECT_ROOT environment variable is required');\n  }\n  runMCPServer({\n    dataDir: process.env['DATA_DIR'],\n    config: process.env['CONFIG_PATH'],\n    projectRoot,\n  }).catch((error: unknown) => {\n    logger.error(\n      { error: error instanceof Error ? error.message : String(error) },\n      'Failed to start MCP server'\n    );\n    process.exit(1);\n  });\n}\n","/**\n * ZIL Lexer\n *\n * Tokenizes ZIL (Zork Implementation Language) source code.\n * ZIL is a Lisp-like language with angle brackets for forms instead of parentheses.\n *\n * Key syntax:\n * - Forms: <FORM arg1 arg2 ...>\n * - Strings: \"text\"\n * - Numbers: 42, -10\n * - Atoms: ROUTINE, V-LOOK, EQUAL?\n * - Comments: ; line comment\n * - Global refs: ,FOO\n * - Local refs: .BAR\n */\n\nexport enum TokenType {\n  LANGLE = 'LANGLE', // <\n  RANGLE = 'RANGLE', // >\n  LPAREN = 'LPAREN', // (\n  RPAREN = 'RPAREN', // )\n  ATOM = 'ATOM', // Symbols/identifiers\n  STRING = 'STRING', // \"text\"\n  NUMBER = 'NUMBER', // 42, -10\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  line: number;\n  column: number;\n}\n\n/**\n * Lexer for ZIL source code\n */\nexport class ZilLexer {\n  private input = '';\n  private pos = 0;\n  private line = 1;\n  private column = 1;\n  private tokens: Token[] = [];\n\n  /**\n   * Tokenize ZIL source code\n   *\n   * @param input - Source code string\n   * @returns Array of tokens\n   * @throws On unterminated strings\n   */\n  tokenize(input: string): Token[] {\n    this.input = input;\n    this.pos = 0;\n    this.line = 1;\n    this.column = 1;\n    this.tokens = [];\n\n    while (!this.isAtEnd()) {\n      this.scanToken();\n    }\n\n    return this.tokens;\n  }\n\n  private isAtEnd(): boolean {\n    return this.pos >= this.input.length;\n  }\n\n  private peek(): string {\n    if (this.isAtEnd()) return '\\0';\n    return this.input[this.pos] ?? '\\0';\n  }\n\n  private advance(): string {\n    const char = this.input[this.pos] ?? '\\0';\n    this.pos++;\n\n    if (char === '\\n') {\n      this.line++;\n      this.column = 1;\n    } else {\n      this.column++;\n    }\n\n    return char;\n  }\n\n  private addToken(type: TokenType, value: string, startLine: number, startColumn: number): void {\n    this.tokens.push({\n      type,\n      value,\n      line: startLine,\n      column: startColumn,\n    });\n  }\n\n  private scanToken(): void {\n    const startLine = this.line;\n    const startColumn = this.column;\n    const char = this.advance();\n\n    switch (char) {\n      case '<':\n        this.addToken(TokenType.LANGLE, '<', startLine, startColumn);\n        break;\n      case '>':\n        this.addToken(TokenType.RANGLE, '>', startLine, startColumn);\n        break;\n      case '(':\n        this.addToken(TokenType.LPAREN, '(', startLine, startColumn);\n        break;\n      case ')':\n        this.addToken(TokenType.RPAREN, ')', startLine, startColumn);\n        break;\n      case '\"':\n        this.scanString(startLine, startColumn);\n        break;\n      case ';':\n        this.skipComment();\n        break;\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        // Skip whitespace\n        break;\n      default:\n        if (this.isDigit(char) || (char === '-' && this.isDigit(this.peek()))) {\n          this.scanNumber(char, startLine, startColumn);\n        } else if (this.isAtomStart(char)) {\n          this.scanAtom(char, startLine, startColumn);\n        }\n        // Ignore other characters\n        break;\n    }\n  }\n\n  private scanString(startLine: number, startColumn: number): void {\n    let value = '';\n\n    while (!this.isAtEnd() && this.peek() !== '\"') {\n      const char = this.peek();\n\n      if (char === '\\\\') {\n        this.advance(); // consume backslash\n        const escaped = this.advance();\n        switch (escaped) {\n          case '\"':\n            value += '\"';\n            break;\n          case '\\\\':\n            value += '\\\\';\n            break;\n          case 'n':\n            value += '\\n';\n            break;\n          case 't':\n            value += '\\t';\n            break;\n          default:\n            value += escaped;\n            break;\n        }\n      } else {\n        value += this.advance();\n      }\n    }\n\n    if (this.isAtEnd()) {\n      throw new Error(\n        `Unterminated string at line ${String(startLine)}, column ${String(startColumn)}`\n      );\n    }\n\n    // Consume closing quote\n    this.advance();\n\n    this.addToken(TokenType.STRING, value, startLine, startColumn);\n  }\n\n  private scanNumber(firstChar: string, startLine: number, startColumn: number): void {\n    let value = firstChar;\n\n    while (this.isDigit(this.peek())) {\n      value += this.advance();\n    }\n\n    this.addToken(TokenType.NUMBER, value, startLine, startColumn);\n  }\n\n  private scanAtom(firstChar: string, startLine: number, startColumn: number): void {\n    let value = firstChar;\n\n    while (this.isAtomChar(this.peek())) {\n      value += this.advance();\n    }\n\n    this.addToken(TokenType.ATOM, value, startLine, startColumn);\n  }\n\n  private skipComment(): void {\n    // Skip until end of line\n    while (!this.isAtEnd() && this.peek() !== '\\n') {\n      this.advance();\n    }\n  }\n\n  private isDigit(char: string): boolean {\n    return char >= '0' && char <= '9';\n  }\n\n  private isAtomStart(char: string): boolean {\n    return (\n      (char >= 'A' && char <= 'Z') ||\n      (char >= 'a' && char <= 'z') ||\n      char === '_' ||\n      char === ',' || // Global reference prefix\n      char === '.' || // Local reference prefix\n      char === '%' || // Sometimes used in ZIL\n      char === '#' // Hash prefix\n    );\n  }\n\n  private isAtomChar(char: string): boolean {\n    return (\n      (char >= 'A' && char <= 'Z') ||\n      (char >= 'a' && char <= 'z') ||\n      (char >= '0' && char <= '9') ||\n      char === '_' ||\n      char === '-' ||\n      char === '?' ||\n      char === '!' ||\n      char === ',' ||\n      char === '.' ||\n      char === '%' ||\n      char === '#'\n    );\n  }\n}\n","/**\n * ZIL Special Forms and Builtins\n *\n * These are NOT treated as function calls when building the call graph.\n * Special forms are control flow, assignment, and predicates.\n * Builtins are runtime primitives.\n */\n\n/**\n * Special forms - language-level constructs, not function calls\n */\nexport const ZIL_SPECIAL_FORMS = new Set([\n  // Conditionals\n  'COND',\n  'AND',\n  'OR',\n  'NOT',\n  'IF',\n  'ELSE',\n\n  // Assignment\n  'SET',\n  'SETG',\n  'BIND',\n  'PROG',\n\n  // Loops\n  'REPEAT',\n  'DO',\n  'MAP',\n  'MAPF',\n  'MAPR',\n  'MAPRET',\n  'MAPLEAVE',\n\n  // Output\n  'TELL',\n  'PRINT',\n  'PRINTN',\n  'PRINTD',\n  'PRINTC',\n  'PRINTR',\n  'CRLF',\n\n  // Control flow\n  'RETURN',\n  'AGAIN',\n  'RTRUE',\n  'RFALSE',\n  'QUIT',\n\n  // Predicates (end with ?)\n  'EQUAL?',\n  'ZERO?',\n  'LESS?',\n  'GRTR?',\n  'FSET?',\n  'IN?',\n  'VERB?',\n  'PRSO?',\n  'PRSI?',\n  'HELD?',\n  'HERE?',\n  'ACCESSIBLE?',\n  'VISIBLE?',\n  'FIRST?',\n  'NEXT?',\n  'PROB?',\n  'RANDOM',\n\n  // Property/flag manipulation\n  'FSET',\n  'FCLEAR',\n  'GETP',\n  'PUTP',\n  'GETPT',\n  'PTSIZE',\n\n  // Object manipulation\n  'MOVE',\n  'REMOVE',\n  'LOC',\n  'FIRST',\n  'NEXT',\n\n  // Arithmetic\n  'ADD',\n  'SUB',\n  'MUL',\n  'DIV',\n  'MOD',\n  'BAND',\n  'BOR',\n  'BCOM',\n  'LSH',\n\n  // Table operations\n  'GET',\n  'PUT',\n  'GETB',\n  'PUTB',\n  'TABLE',\n  'ITABLE',\n  'LTABLE',\n  'PTABLE',\n\n  // Stack operations\n  'PUSH',\n  'POP',\n  'FSTACK',\n\n  // Input\n  'READ',\n  'INPUT',\n  'READLINE',\n\n  // Definition forms (handled separately for symbol extraction)\n  'ROUTINE',\n  'OBJECT',\n  'ROOM',\n  'GLOBAL',\n  'CONSTANT',\n  'SYNTAX',\n  'INSERT-FILE',\n\n  // Misc builtins\n  'VERSION?',\n  'ASCII',\n  'USL',\n  'APPLY',\n  'EVAL',\n  'FORM',\n  'REST',\n  'LENGTH',\n  'NTH',\n  'ZGET',\n  'ZPUT',\n  'ZWSTR',\n  'DIROUT',\n  'DIRIN',\n  'BUFOUT',\n  'HLIGHT',\n  'COLOR',\n  'FONT',\n  'SPLIT',\n  'SCREEN',\n  'WINGET',\n  'WINPUT',\n  'WINATTR',\n  'PICINF',\n  'DISPLAY',\n  'DCLEAR',\n  'SOUND',\n  'INTBL?',\n  'CATCH',\n  'THROW',\n  'LEGAL?',\n  'COPYT',\n  'VALUE',\n  'GASSIGNED?',\n  'ASSIGNED?',\n  'DEFINE',\n  'DEFMAC',\n]);\n\n/**\n * Check if a form head is a special form or builtin\n */\nexport function isSpecialForm(name: string): boolean {\n  return ZIL_SPECIAL_FORMS.has(name.toUpperCase());\n}\n\n/**\n * Definition forms that create symbols\n */\nexport const ZIL_DEFINITION_FORMS = new Set([\n  'ROUTINE',\n  'OBJECT',\n  'ROOM',\n  'GLOBAL',\n  'CONSTANT',\n  'SYNTAX',\n  'VERB',\n  'DEFINE',\n  'DEFMAC',\n]);\n\n/**\n * Check if a form head is a definition form\n */\nexport function isDefinitionForm(name: string): boolean {\n  return ZIL_DEFINITION_FORMS.has(name.toUpperCase());\n}\n","/**\n * ZIL Parser\n *\n * Parses ZIL source code into an AST-like structure and extracts:\n * - Symbols (ROUTINE, OBJECT, ROOM, GLOBAL, CONSTANT, SYNTAX)\n * - Imports (INSERT-FILE)\n * - Call relationships (filtering out special forms)\n */\n\nimport { ZilLexer, TokenType, type Token } from './zil-lexer.js';\nimport { isSpecialForm, isDefinitionForm } from './zil-special-forms.js';\nimport type { ImportInfo } from '../ast-parser.js';\n\n/**\n * A ZIL form node (angle-bracket expression)\n */\nexport interface ZilForm {\n  /** The head/operator of the form (first atom after <) */\n  head: string;\n  /** Child nodes (atoms, strings, numbers, nested forms) */\n  children: ZilNode[];\n  /** Starting line number */\n  startLine: number;\n  /** Ending line number */\n  endLine: number;\n}\n\n/**\n * A parenthesized group (used for args lists)\n */\nexport interface ZilGroup {\n  type: 'group';\n  children: ZilNode[];\n  startLine: number;\n  endLine: number;\n}\n\n/**\n * A leaf node (atom, string, or number)\n */\nexport interface ZilLeaf {\n  type: 'atom' | 'string' | 'number';\n  value: string;\n  line: number;\n}\n\nexport type ZilNode = ZilForm | ZilGroup | ZilLeaf;\n\n/**\n * Extracted symbol from ZIL code\n */\nexport interface ZilSymbol {\n  name: string;\n  kind: 'routine' | 'object' | 'room' | 'global' | 'constant' | 'syntax' | 'verb';\n  startLine: number;\n  endLine: number;\n  signature?: string;\n}\n\n/**\n * A function call extracted from ZIL code\n */\nexport interface ZilCall {\n  caller: string;\n  callee: string;\n  line: number;\n}\n\n/**\n * Result of parsing a ZIL file\n */\nexport interface ZilParseResult {\n  forms: ZilForm[];\n  symbols: ZilSymbol[];\n  imports: ImportInfo[];\n  calls: ZilCall[];\n}\n\n/**\n * Parser for ZIL source code\n */\nexport class ZilParser {\n  private readonly lexer = new ZilLexer();\n  private tokens: Token[] = [];\n  private pos = 0;\n\n  /**\n   * Parse ZIL source code\n   */\n  parse(input: string): ZilParseResult {\n    this.tokens = this.lexer.tokenize(input);\n    this.pos = 0;\n\n    const forms: ZilForm[] = [];\n    const symbols: ZilSymbol[] = [];\n    const imports: ImportInfo[] = [];\n    const calls: ZilCall[] = [];\n\n    // Parse all top-level forms\n    while (!this.isAtEnd()) {\n      if (this.check(TokenType.LANGLE)) {\n        const form = this.parseForm();\n        if (form !== undefined) {\n          forms.push(form);\n\n          // Extract symbols from definition forms\n          const symbol = this.extractSymbol(form);\n          if (symbol !== undefined) {\n            symbols.push(symbol);\n          }\n\n          // Extract imports from INSERT-FILE\n          const imp = this.extractImport(form);\n          if (imp !== undefined) {\n            imports.push(imp);\n          }\n\n          // Extract calls from routines\n          if (form.head.toUpperCase() === 'ROUTINE') {\n            const routineName = this.getRoutineName(form);\n            if (routineName !== undefined) {\n              this.extractCalls(form, routineName, calls);\n            }\n          }\n        }\n      } else {\n        // Skip non-form tokens at top level\n        this.advance();\n      }\n    }\n\n    return { forms, symbols, imports, calls };\n  }\n\n  private isAtEnd(): boolean {\n    return this.pos >= this.tokens.length;\n  }\n\n  private peek(): Token | undefined {\n    return this.tokens[this.pos];\n  }\n\n  private check(type: TokenType): boolean {\n    if (this.isAtEnd()) return false;\n    return this.peek()?.type === type;\n  }\n\n  private advance(): Token | undefined {\n    if (!this.isAtEnd()) {\n      const token = this.tokens[this.pos];\n      this.pos++;\n      return token;\n    }\n    return undefined;\n  }\n\n  private parseForm(): ZilForm | undefined {\n    if (!this.check(TokenType.LANGLE)) return undefined;\n\n    const startToken = this.advance(); // consume <\n    const startLine = startToken?.line ?? 1;\n    let endLine = startLine;\n\n    // Get the head (first element)\n    let head = '';\n    if (this.check(TokenType.ATOM)) {\n      head = this.advance()?.value ?? '';\n    }\n\n    const children: ZilNode[] = [];\n\n    // Parse children until >\n    while (!this.isAtEnd() && !this.check(TokenType.RANGLE)) {\n      const child = this.parseNode();\n      if (child !== undefined) {\n        children.push(child);\n        endLine = this.getNodeEndLine(child);\n      } else {\n        // Skip unexpected tokens\n        this.advance();\n      }\n    }\n\n    if (this.check(TokenType.RANGLE)) {\n      const closeToken = this.advance();\n      endLine = closeToken?.line ?? endLine;\n    }\n\n    return { head, children, startLine, endLine };\n  }\n\n  private parseGroup(): ZilGroup | undefined {\n    if (!this.check(TokenType.LPAREN)) return undefined;\n\n    const startToken = this.advance(); // consume (\n    const startLine = startToken?.line ?? 1;\n    let endLine = startLine;\n\n    const children: ZilNode[] = [];\n\n    while (!this.isAtEnd() && !this.check(TokenType.RPAREN)) {\n      const child = this.parseNode();\n      if (child !== undefined) {\n        children.push(child);\n        endLine = this.getNodeEndLine(child);\n      } else {\n        this.advance();\n      }\n    }\n\n    if (this.check(TokenType.RPAREN)) {\n      const closeToken = this.advance();\n      endLine = closeToken?.line ?? endLine;\n    }\n\n    return { type: 'group', children, startLine, endLine };\n  }\n\n  private parseNode(): ZilNode | undefined {\n    const token = this.peek();\n    if (token === undefined) return undefined;\n\n    switch (token.type) {\n      case TokenType.LANGLE:\n        return this.parseForm();\n      case TokenType.LPAREN:\n        return this.parseGroup();\n      case TokenType.ATOM:\n        this.advance();\n        return { type: 'atom', value: token.value, line: token.line };\n      case TokenType.STRING:\n        this.advance();\n        return { type: 'string', value: token.value, line: token.line };\n      case TokenType.NUMBER:\n        this.advance();\n        return { type: 'number', value: token.value, line: token.line };\n      default:\n        return undefined;\n    }\n  }\n\n  private getNodeEndLine(node: ZilNode): number {\n    if ('endLine' in node) {\n      return node.endLine;\n    }\n    return node.line;\n  }\n\n  private extractSymbol(form: ZilForm): ZilSymbol | undefined {\n    const headUpper = form.head.toUpperCase();\n\n    if (!isDefinitionForm(headUpper)) {\n      return undefined;\n    }\n\n    // Get the name (first child that's an atom)\n    const nameNode = form.children.find((c): c is ZilLeaf => 'type' in c && c.type === 'atom');\n\n    if (nameNode === undefined) {\n      return undefined;\n    }\n\n    const kindMap: Record<string, ZilSymbol['kind']> = {\n      ROUTINE: 'routine',\n      OBJECT: 'object',\n      ROOM: 'room',\n      GLOBAL: 'global',\n      CONSTANT: 'constant',\n      SYNTAX: 'syntax',\n      VERB: 'verb',\n      DEFINE: 'routine',\n      DEFMAC: 'routine',\n    };\n\n    const kind = kindMap[headUpper];\n    if (kind === undefined) {\n      return undefined;\n    }\n\n    const result: ZilSymbol = {\n      name: nameNode.value,\n      kind,\n      startLine: form.startLine,\n      endLine: form.endLine,\n    };\n\n    if (headUpper === 'ROUTINE' || headUpper === 'DEFINE' || headUpper === 'DEFMAC') {\n      result.signature = this.extractRoutineSignature(form, nameNode.value);\n    }\n\n    return result;\n  }\n\n  private extractRoutineSignature(form: ZilForm, name: string): string {\n    // Find args group (first parenthesized group after name)\n    const argsGroup = form.children.find((c): c is ZilGroup => 'type' in c && c.type === 'group');\n\n    if (argsGroup === undefined) {\n      return `ROUTINE ${name} ()`;\n    }\n\n    const args = argsGroup.children\n      .filter((c): c is ZilLeaf => 'type' in c && c.type === 'atom')\n      .map((c) => c.value)\n      .join(' ');\n\n    return `ROUTINE ${name} (${args})`;\n  }\n\n  private extractImport(form: ZilForm): ImportInfo | undefined {\n    if (form.head.toUpperCase() !== 'INSERT-FILE') {\n      return undefined;\n    }\n\n    // Get the file name (first string child)\n    const fileNode = form.children.find((c): c is ZilLeaf => 'type' in c && c.type === 'string');\n\n    if (fileNode === undefined) {\n      return undefined;\n    }\n\n    return {\n      source: fileNode.value,\n      specifiers: [],\n      isType: false,\n    };\n  }\n\n  private getRoutineName(form: ZilForm): string | undefined {\n    const nameNode = form.children.find((c): c is ZilLeaf => 'type' in c && c.type === 'atom');\n    return nameNode?.value;\n  }\n\n  private extractCalls(node: ZilNode, caller: string, calls: ZilCall[]): void {\n    if ('head' in node) {\n      // It's a form\n      const headUpper = node.head.toUpperCase();\n\n      // If not a special form and not empty, it's a call\n      if (node.head !== '' && !isSpecialForm(headUpper)) {\n        calls.push({\n          caller,\n          callee: node.head,\n          line: node.startLine,\n        });\n      }\n\n      // Recurse into children\n      for (const child of node.children) {\n        this.extractCalls(child, caller, calls);\n      }\n    } else if ('type' in node && node.type === 'group') {\n      // Recurse into group children\n      for (const child of node.children) {\n        this.extractCalls(child, caller, calls);\n      }\n    }\n    // Leaf nodes don't contain calls\n  }\n}\n","/**\n * ZIL Language Adapter\n *\n * Implements LanguageAdapter for ZIL (Zork Implementation Language).\n * Provides full graph support: parsing, imports, chunking, and call analysis.\n */\n\nimport { ZilParser } from './zil-parser.js';\nimport type { CodeNode, ImportInfo } from '../ast-parser.js';\nimport type { GraphEdge } from '../code-graph.js';\nimport type { LanguageAdapter, ChunkResult } from '../language-adapter.js';\n\n/**\n * Language adapter for ZIL (Zork Implementation Language)\n */\nexport class ZilAdapter implements LanguageAdapter {\n  readonly languageId = 'zil';\n  readonly extensions = ['.zil', '.mud'];\n  readonly displayName = 'ZIL (Zork Implementation Language)';\n\n  private readonly parser = new ZilParser();\n\n  /**\n   * Parse ZIL code and extract symbols as CodeNode[]\n   */\n  parse(content: string, _filePath: string): CodeNode[] {\n    const result = this.parser.parse(content);\n\n    return result.symbols.map((symbol) => {\n      const node: CodeNode = {\n        type: this.mapSymbolKindToNodeType(symbol.kind),\n        name: symbol.name,\n        exported: true, // ZIL doesn't have export concept, treat all as exported\n        startLine: symbol.startLine,\n        endLine: symbol.endLine,\n      };\n\n      if (symbol.signature !== undefined) {\n        node.signature = symbol.signature;\n      }\n\n      return node;\n    });\n  }\n\n  /**\n   * Extract imports from INSERT-FILE directives\n   */\n  extractImports(content: string, _filePath: string): ImportInfo[] {\n    const result = this.parser.parse(content);\n    return result.imports;\n  }\n\n  /**\n   * Chunk ZIL code by top-level forms\n   */\n  chunk(content: string, _filePath: string): ChunkResult[] {\n    const result = this.parser.parse(content);\n    const lines = content.split('\\n');\n\n    return result.forms\n      .filter((form) => form.head !== '') // Skip empty forms\n      .map((form) => {\n        // Extract content from original source using line numbers\n        const chunkLines = lines.slice(form.startLine - 1, form.endLine);\n        const chunkContent = chunkLines.join('\\n');\n\n        // Find symbol for this form if it's a definition\n        const symbol = result.symbols.find(\n          (s) => s.startLine === form.startLine && s.endLine === form.endLine\n        );\n\n        const chunk: ChunkResult = {\n          content: chunkContent,\n          startLine: form.startLine,\n          endLine: form.endLine,\n        };\n\n        if (symbol !== undefined) {\n          chunk.symbolName = symbol.name;\n          chunk.symbolKind = symbol.kind;\n        }\n\n        return chunk;\n      });\n  }\n\n  /**\n   * Analyze call relationships within ZIL code\n   */\n  analyzeCallRelationships(content: string, filePath: string): GraphEdge[] {\n    const result = this.parser.parse(content);\n\n    return result.calls.map((call) => ({\n      from: `${filePath}:${call.caller}`,\n      to: `${filePath}:${call.callee}`,\n      type: 'calls' as const,\n      confidence: 0.9, // High confidence for ZIL - calls are explicit\n    }));\n  }\n\n  /**\n   * Map ZIL symbol kinds to CodeNode types\n   */\n  private mapSymbolKindToNodeType(kind: string): CodeNode['type'] {\n    switch (kind) {\n      case 'routine':\n        return 'function';\n      case 'object':\n      case 'room':\n      case 'global':\n      case 'constant':\n        return 'const';\n      case 'syntax':\n      case 'verb':\n        return 'const';\n      default:\n        return 'const';\n    }\n  }\n}\n","import { z } from 'zod';\nimport { handleCheckJobStatus, handleListJobs, handleCancelJob } from '../handlers/job.handler.js';\nimport type { CommandDefinition } from './registry.js';\nimport type { CheckJobStatusArgs, ListJobsArgs, CancelJobArgs } from '../schemas/index.js';\n\n/**\n * Job management commands for the execute meta-tool\n *\n * These commands wrap the existing job handlers, providing\n * a unified interface through the execute command.\n *\n * Note: Type assertions are necessary here because CommandHandler uses\n * Record<string, unknown> for generic command args, while handlers expect\n * specific typed args. Zod validates at runtime before the cast.\n */\n/* eslint-disable @typescript-eslint/consistent-type-assertions */\nexport const jobCommands: CommandDefinition[] = [\n  {\n    name: 'jobs',\n    description: 'List all background jobs',\n    argsSchema: z.object({\n      activeOnly: z.boolean().optional().describe('Only show active jobs'),\n      status: z\n        .enum(['pending', 'running', 'completed', 'failed', 'cancelled'])\n        .optional()\n        .describe('Filter by job status'),\n    }),\n    handler: (args, context) => handleListJobs(args as unknown as ListJobsArgs, context),\n  },\n  {\n    name: 'job:status',\n    description: 'Check the status of a specific background job',\n    argsSchema: z.object({\n      jobId: z.string().min(1).describe('Job ID to check'),\n    }),\n    handler: (args, context) =>\n      handleCheckJobStatus(args as unknown as CheckJobStatusArgs, context),\n  },\n  {\n    name: 'job:cancel',\n    description: 'Cancel a running or pending background job',\n    argsSchema: z.object({\n      jobId: z.string().min(1).describe('Job ID to cancel'),\n    }),\n    handler: (args, context) => handleCancelJob(args as unknown as CancelJobArgs, context),\n  },\n];\n/* eslint-enable @typescript-eslint/consistent-type-assertions */\n","import { z } from 'zod';\n\n/**\n * Validation schemas for all MCP tool inputs\n *\n * These schemas provide runtime type validation and better error messages\n * compared to manual type assertions.\n */\n\n// ============================================================================\n// Search Tool Schemas\n// ============================================================================\n\n/**\n * Schema for search tool arguments\n */\nexport const SearchArgsSchema = z.object({\n  query: z.string().min(1, 'Query must be a non-empty string'),\n  intent: z\n    .enum([\n      'find-pattern',\n      'find-implementation',\n      'find-usage',\n      'find-definition',\n      'find-documentation',\n    ])\n    .optional(),\n  mode: z.enum(['vector', 'fts', 'hybrid']).default('hybrid'),\n  detail: z.enum(['minimal', 'contextual', 'full']).default('minimal'),\n  limit: z.number().int().positive().default(10),\n  stores: z.array(z.string()).optional(),\n  threshold: z\n    .number()\n    .min(0, 'threshold must be between 0 and 1')\n    .max(1, 'threshold must be between 0 and 1')\n    .optional(),\n  minRelevance: z\n    .number()\n    .min(0, 'minRelevance must be between 0 and 1')\n    .max(1, 'minRelevance must be between 0 and 1')\n    .optional(),\n});\n\nexport type SearchArgs = z.infer<typeof SearchArgsSchema>;\n\n/**\n * Schema for get_full_context tool arguments\n */\nexport const GetFullContextArgsSchema = z.object({\n  resultId: z.string().min(1, 'Result ID must be a non-empty string'),\n});\n\nexport type GetFullContextArgs = z.infer<typeof GetFullContextArgsSchema>;\n\n// ============================================================================\n// Store Tool Schemas\n// ============================================================================\n\n/**\n * Schema for list_stores tool arguments\n */\nexport const ListStoresArgsSchema = z.object({\n  type: z.enum(['file', 'repo', 'web']).optional(),\n});\n\nexport type ListStoresArgs = z.infer<typeof ListStoresArgsSchema>;\n\n/**\n * Schema for get_store_info tool arguments\n */\nexport const GetStoreInfoArgsSchema = z.object({\n  store: z.string().min(1, 'Store name or ID must be a non-empty string'),\n});\n\nexport type GetStoreInfoArgs = z.infer<typeof GetStoreInfoArgsSchema>;\n\n/**\n * Schema for create_store tool arguments\n */\nexport const CreateStoreArgsSchema = z.object({\n  name: z.string().min(1, 'Store name must be a non-empty string'),\n  type: z.enum(['file', 'repo']),\n  source: z.string().min(1, 'Source path or URL must be a non-empty string'),\n  branch: z.string().optional(),\n  description: z.string().optional(),\n});\n\nexport type CreateStoreArgs = z.infer<typeof CreateStoreArgsSchema>;\n\n/**\n * Schema for index_store tool arguments\n */\nexport const IndexStoreArgsSchema = z.object({\n  store: z.string().min(1, 'Store name or ID must be a non-empty string'),\n});\n\nexport type IndexStoreArgs = z.infer<typeof IndexStoreArgsSchema>;\n\n/**\n * Schema for delete_store tool arguments\n */\nexport const DeleteStoreArgsSchema = z.object({\n  store: z.string().min(1, 'Store name or ID must be a non-empty string'),\n});\n\nexport type DeleteStoreArgs = z.infer<typeof DeleteStoreArgsSchema>;\n\n// ============================================================================\n// Job Tool Schemas\n// ============================================================================\n\n/**\n * Schema for check_job_status tool arguments\n */\nexport const CheckJobStatusArgsSchema = z.object({\n  jobId: z.string().min(1, 'Job ID must be a non-empty string'),\n});\n\nexport type CheckJobStatusArgs = z.infer<typeof CheckJobStatusArgsSchema>;\n\n/**\n * Schema for list_jobs tool arguments\n */\nexport const ListJobsArgsSchema = z.object({\n  activeOnly: z.boolean().optional(),\n  status: z.enum(['pending', 'running', 'completed', 'failed', 'cancelled']).optional(),\n});\n\nexport type ListJobsArgs = z.infer<typeof ListJobsArgsSchema>;\n\n/**\n * Schema for cancel_job tool arguments\n */\nexport const CancelJobArgsSchema = z.object({\n  jobId: z.string().min(1, 'Job ID must be a non-empty string'),\n});\n\nexport type CancelJobArgs = z.infer<typeof CancelJobArgsSchema>;\n\n// ============================================================================\n// Execute Meta-Tool Schema\n// ============================================================================\n\n/**\n * Schema for execute meta-tool arguments\n *\n * The execute tool consolidates store and job management commands\n * into a single tool, reducing context overhead.\n */\nexport const ExecuteArgsSchema = z.object({\n  command: z.string().min(1, 'Command name is required'),\n  args: z.record(z.string(), z.unknown()).optional(),\n});\n\nexport type ExecuteArgs = z.infer<typeof ExecuteArgsSchema>;\n","import { JobService } from '../../services/job.service.js';\nimport {\n  CheckJobStatusArgsSchema,\n  ListJobsArgsSchema,\n  CancelJobArgsSchema,\n} from '../schemas/index.js';\nimport type { CheckJobStatusArgs, ListJobsArgs, CancelJobArgs } from '../schemas/index.js';\nimport type { ToolHandler, ToolResponse } from '../types.js';\n\n/**\n * Handle check_job_status requests\n *\n * Retrieves the current status of a background job.\n */\nexport const handleCheckJobStatus: ToolHandler<CheckJobStatusArgs> = (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = CheckJobStatusArgsSchema.parse(args);\n\n  const { options } = context;\n\n  const jobService = new JobService(options.dataDir);\n  const job = jobService.getJob(validated.jobId);\n\n  if (!job) {\n    throw new Error(`Job not found: ${validated.jobId}`);\n  }\n\n  return Promise.resolve({\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(job, null, 2),\n      },\n    ],\n  });\n};\n\n/**\n * Handle list_jobs requests\n *\n * Lists all jobs with optional filtering by status or active status.\n */\nexport const handleListJobs: ToolHandler<ListJobsArgs> = (args, context): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = ListJobsArgsSchema.parse(args);\n\n  const { options } = context;\n\n  const jobService = new JobService(options.dataDir);\n\n  let jobs;\n  if (validated.activeOnly === true) {\n    jobs = jobService.listActiveJobs();\n  } else if (validated.status !== undefined) {\n    jobs = jobService.listJobs(validated.status);\n  } else {\n    jobs = jobService.listJobs();\n  }\n\n  return Promise.resolve({\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({ jobs }, null, 2),\n      },\n    ],\n  });\n};\n\n/**\n * Handle cancel_job requests\n *\n * Cancels a running or pending background job.\n * Kills the worker process if it exists.\n */\nexport const handleCancelJob: ToolHandler<CancelJobArgs> = (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = CancelJobArgsSchema.parse(args);\n\n  const { options } = context;\n\n  const jobService = new JobService(options.dataDir);\n  const result = jobService.cancelJob(validated.jobId);\n\n  if (!result.success) {\n    throw new Error(result.error.message);\n  }\n\n  const job = jobService.getJob(validated.jobId);\n\n  return Promise.resolve({\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(\n          {\n            success: true,\n            job,\n            message: 'Job cancelled successfully',\n          },\n          null,\n          2\n        ),\n      },\n    ],\n  });\n};\n","import { z } from 'zod';\nimport { commandRegistry, generateHelp } from './registry.js';\nimport type { CommandDefinition } from './registry.js';\nimport type { ToolResponse } from '../types.js';\n\n/**\n * Meta commands for introspection and help\n *\n * These commands provide self-documentation for the execute tool,\n * allowing users to discover available commands and their usage.\n */\nexport const metaCommands: CommandDefinition[] = [\n  {\n    name: 'commands',\n    description: 'List all available commands',\n    handler: (): Promise<ToolResponse> => {\n      const commands = commandRegistry.all();\n      const commandList = commands.map((cmd) => ({\n        name: cmd.name,\n        description: cmd.description,\n      }));\n\n      return Promise.resolve({\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify({ commands: commandList }, null, 2),\n          },\n        ],\n      });\n    },\n  },\n  {\n    name: 'help',\n    description: 'Show help for a specific command or list all commands',\n    argsSchema: z.object({\n      command: z.string().optional().describe('Command name to get help for'),\n    }),\n    handler: (args: Record<string, unknown>): Promise<ToolResponse> => {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      const commandName = args['command'] as string | undefined;\n      const helpText = generateHelp(commandName);\n\n      return Promise.resolve({\n        content: [\n          {\n            type: 'text' as const,\n            text: helpText,\n          },\n        ],\n      });\n    },\n  },\n];\n","import { z } from 'zod';\nimport type { HandlerContext, ToolResponse } from '../types.js';\n\n/**\n * Command definition for the execute meta-tool\n *\n * Each command has a name, description, optional args schema, and handler.\n * Commands are registered in the registry and invoked via execute(command, args).\n */\nexport interface CommandDefinition {\n  /** Command name (e.g., 'stores', 'store:info', 'job:status') */\n  name: string;\n  /** Human-readable description shown in help output */\n  description: string;\n  /** Optional Zod schema for argument validation */\n  argsSchema?: z.ZodType;\n  /** Handler function that executes the command */\n  handler: CommandHandler;\n}\n\n/**\n * Command handler function signature\n *\n * @param args - Validated command arguments (or empty object if no args)\n * @param context - Handler context with services and options\n * @returns Promise resolving to tool response\n */\nexport type CommandHandler = (\n  args: Record<string, unknown>,\n  context: HandlerContext\n) => Promise<ToolResponse>;\n\n/**\n * Command registry - singleton that holds all registered commands\n */\nclass CommandRegistry {\n  private readonly commands = new Map<string, CommandDefinition>();\n\n  /**\n   * Register a command\n   */\n  register(command: CommandDefinition): void {\n    if (this.commands.has(command.name)) {\n      throw new Error(`Command already registered: ${command.name}`);\n    }\n    this.commands.set(command.name, command);\n  }\n\n  /**\n   * Register multiple commands at once\n   */\n  registerAll(commands: CommandDefinition[]): void {\n    for (const command of commands) {\n      this.register(command);\n    }\n  }\n\n  /**\n   * Get a command by name\n   */\n  get(name: string): CommandDefinition | undefined {\n    return this.commands.get(name);\n  }\n\n  /**\n   * Check if a command exists\n   */\n  has(name: string): boolean {\n    return this.commands.has(name);\n  }\n\n  /**\n   * Get all registered commands\n   */\n  all(): CommandDefinition[] {\n    return Array.from(this.commands.values());\n  }\n\n  /**\n   * Get commands grouped by category (prefix before colon)\n   */\n  grouped(): Map<string, CommandDefinition[]> {\n    const groups = new Map<string, CommandDefinition[]>();\n\n    for (const cmd of this.commands.values()) {\n      const colonIndex = cmd.name.indexOf(':');\n      const category = colonIndex === -1 ? 'general' : cmd.name.slice(0, colonIndex);\n\n      const existing = groups.get(category) ?? [];\n      existing.push(cmd);\n      groups.set(category, existing);\n    }\n\n    return groups;\n  }\n}\n\n/** Global command registry instance */\nexport const commandRegistry = new CommandRegistry();\n\n/**\n * Execute a command by name\n *\n * @param commandName - The command to execute\n * @param args - Arguments to pass to the command\n * @param context - Handler context\n * @returns Promise resolving to tool response\n */\nexport async function executeCommand(\n  commandName: string,\n  args: Record<string, unknown>,\n  context: HandlerContext\n): Promise<ToolResponse> {\n  const command = commandRegistry.get(commandName);\n\n  if (command === undefined) {\n    throw new Error(\n      `Unknown command: ${commandName}. Use execute(\"commands\") to list available commands.`\n    );\n  }\n\n  // Validate args if schema provided (Zod parse returns unknown, safe to cast after validation)\n  /* eslint-disable @typescript-eslint/consistent-type-assertions */\n  const validatedArgs: Record<string, unknown> =\n    command.argsSchema !== undefined\n      ? (command.argsSchema.parse(args) as Record<string, unknown>)\n      : args;\n  /* eslint-enable @typescript-eslint/consistent-type-assertions */\n\n  return command.handler(validatedArgs, context);\n}\n\n/**\n * Generate help text for a command or all commands\n */\nexport function generateHelp(commandName?: string): string {\n  if (commandName !== undefined) {\n    const command = commandRegistry.get(commandName);\n    if (command === undefined) {\n      throw new Error(`Unknown command: ${commandName}`);\n    }\n\n    const lines = [`Command: ${command.name}`, `Description: ${command.description}`, ''];\n\n    if (command.argsSchema !== undefined) {\n      lines.push('Arguments:');\n      // Extract schema shape for documentation\n      const schema = command.argsSchema;\n      if (schema instanceof z.ZodObject) {\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        const shape = schema.shape as Record<string, z.ZodType>;\n        for (const [key, fieldSchema] of Object.entries(shape)) {\n          const isOptional = fieldSchema.safeParse(undefined).success;\n          const desc = fieldSchema.description ?? '';\n          lines.push(`  ${key}${isOptional ? ' (optional)' : ''}: ${desc}`);\n        }\n      }\n    } else {\n      lines.push('Arguments: none');\n    }\n\n    return lines.join('\\n');\n  }\n\n  // Generate help for all commands\n  const groups = commandRegistry.grouped();\n  const lines = ['Available commands:', ''];\n\n  for (const [category, commands] of groups) {\n    lines.push(`${category}:`);\n    for (const cmd of commands) {\n      lines.push(`  ${cmd.name} - ${cmd.description}`);\n    }\n    lines.push('');\n  }\n\n  lines.push('Use execute(\"help\", {command: \"name\"}) for detailed command help.');\n\n  return lines.join('\\n');\n}\n","import { z } from 'zod';\nimport {\n  handleListStores,\n  handleGetStoreInfo,\n  handleCreateStore,\n  handleIndexStore,\n  handleDeleteStore,\n} from '../handlers/store.handler.js';\nimport type { CommandDefinition } from './registry.js';\nimport type {\n  ListStoresArgs,\n  GetStoreInfoArgs,\n  CreateStoreArgs,\n  IndexStoreArgs,\n  DeleteStoreArgs,\n} from '../schemas/index.js';\n\n/**\n * Store management commands for the execute meta-tool\n *\n * These commands wrap the existing store handlers, providing\n * a unified interface through the execute command.\n *\n * Note: Type assertions are necessary here because CommandHandler uses\n * Record<string, unknown> for generic command args, while handlers expect\n * specific typed args. Zod validates at runtime before the cast.\n */\n/* eslint-disable @typescript-eslint/consistent-type-assertions */\nexport const storeCommands: CommandDefinition[] = [\n  {\n    name: 'stores',\n    description: 'List all indexed knowledge stores',\n    argsSchema: z.object({\n      type: z.enum(['file', 'repo', 'web']).optional().describe('Filter by store type'),\n    }),\n    handler: (args, context) => handleListStores(args as unknown as ListStoresArgs, context),\n  },\n  {\n    name: 'store:info',\n    description: 'Get detailed information about a specific store',\n    argsSchema: z.object({\n      store: z.string().min(1).describe('Store name or ID'),\n    }),\n    handler: (args, context) => handleGetStoreInfo(args as unknown as GetStoreInfoArgs, context),\n  },\n  {\n    name: 'store:create',\n    description: 'Create a new knowledge store from git URL or local path',\n    argsSchema: z.object({\n      name: z.string().min(1).describe('Store name'),\n      type: z.enum(['file', 'repo']).describe('Store type'),\n      source: z.string().min(1).describe('Git URL or local path'),\n      branch: z.string().optional().describe('Git branch (for repo type)'),\n      description: z.string().optional().describe('Store description'),\n    }),\n    handler: (args, context) => handleCreateStore(args as unknown as CreateStoreArgs, context),\n  },\n  {\n    name: 'store:index',\n    description: 'Re-index a knowledge store to update search data',\n    argsSchema: z.object({\n      store: z.string().min(1).describe('Store name or ID'),\n    }),\n    handler: (args, context) => handleIndexStore(args as unknown as IndexStoreArgs, context),\n  },\n  {\n    name: 'store:delete',\n    description: 'Delete a knowledge store and all associated data',\n    argsSchema: z.object({\n      store: z.string().min(1).describe('Store name or ID'),\n    }),\n    handler: (args, context) => handleDeleteStore(args as unknown as DeleteStoreArgs, context),\n  },\n];\n/* eslint-enable @typescript-eslint/consistent-type-assertions */\n","import { rm } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport { JobService } from '../../services/job.service.js';\nimport { createStoreId } from '../../types/brands.js';\nimport { spawnBackgroundWorker } from '../../workers/spawn-worker.js';\nimport {\n  ListStoresArgsSchema,\n  GetStoreInfoArgsSchema,\n  CreateStoreArgsSchema,\n  IndexStoreArgsSchema,\n  DeleteStoreArgsSchema,\n} from '../schemas/index.js';\nimport type {\n  ListStoresArgs,\n  GetStoreInfoArgs,\n  CreateStoreArgs,\n  IndexStoreArgs,\n  DeleteStoreArgs,\n} from '../schemas/index.js';\nimport type { ToolHandler, ToolResponse } from '../types.js';\n\n/**\n * Handle list_stores requests\n *\n * Lists all knowledge stores with optional type filtering.\n */\nexport const handleListStores: ToolHandler<ListStoresArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = ListStoresArgsSchema.parse(args);\n\n  const { services } = context;\n\n  const stores = await services.store.list();\n  const filtered =\n    validated.type !== undefined ? stores.filter((s) => s.type === validated.type) : stores;\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(\n          {\n            stores: filtered.map((s) => ({\n              id: s.id,\n              name: s.name,\n              type: s.type,\n              path: 'path' in s ? s.path : undefined,\n              url: 'url' in s && s.url !== undefined ? s.url : undefined,\n              description: s.description,\n              createdAt: s.createdAt.toISOString(),\n            })),\n          },\n          null,\n          2\n        ),\n      },\n    ],\n  };\n};\n\n/**\n * Handle get_store_info requests\n *\n * Retrieves detailed information about a specific store.\n */\nexport const handleGetStoreInfo: ToolHandler<GetStoreInfoArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = GetStoreInfoArgsSchema.parse(args);\n\n  const { services } = context;\n\n  const store = await services.store.getByIdOrName(createStoreId(validated.store));\n\n  if (store === undefined) {\n    throw new Error(`Store not found: ${validated.store}`);\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(\n          {\n            id: store.id,\n            name: store.name,\n            type: store.type,\n            path: 'path' in store ? store.path : undefined,\n            url: 'url' in store && store.url !== undefined ? store.url : undefined,\n            branch: 'branch' in store ? store.branch : undefined,\n            description: store.description,\n            status: store.status,\n            createdAt: store.createdAt.toISOString(),\n            updatedAt: store.updatedAt.toISOString(),\n          },\n          null,\n          2\n        ),\n      },\n    ],\n  };\n};\n\n/**\n * Handle create_store requests\n *\n * Creates a new knowledge store and starts background indexing.\n * Returns store info and job ID for tracking progress.\n */\nexport const handleCreateStore: ToolHandler<CreateStoreArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = CreateStoreArgsSchema.parse(args);\n\n  const { services, options } = context;\n\n  // Determine if source is a URL or path\n  const isUrl =\n    validated.source.startsWith('http://') ||\n    validated.source.startsWith('https://') ||\n    validated.source.startsWith('git@');\n\n  const result = await services.store.create({\n    name: validated.name,\n    type: validated.type,\n    ...(isUrl ? { url: validated.source } : { path: validated.source }),\n    ...(validated.branch !== undefined ? { branch: validated.branch } : {}),\n    ...(validated.description !== undefined ? { description: validated.description } : {}),\n  });\n\n  if (!result.success) {\n    throw new Error(result.error.message);\n  }\n\n  // Create background job for indexing\n  const jobService = new JobService(options.dataDir);\n  const jobDetails: Record<string, unknown> = {\n    storeName: result.data.name,\n    storeId: result.data.id,\n  };\n  if (isUrl) {\n    jobDetails['url'] = validated.source;\n  }\n  if ('path' in result.data && result.data.path) {\n    jobDetails['path'] = result.data.path;\n  }\n  const job = jobService.createJob({\n    type: validated.type === 'repo' && isUrl ? 'clone' : 'index',\n    details: jobDetails,\n    message: `Indexing ${result.data.name}...`,\n  });\n\n  // Spawn background worker (dataDir defaults to project-local .bluera if undefined)\n  spawnBackgroundWorker(job.id, options.dataDir ?? '');\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(\n          {\n            store: {\n              id: result.data.id,\n              name: result.data.name,\n              type: result.data.type,\n              path: 'path' in result.data ? result.data.path : undefined,\n            },\n            job: {\n              id: job.id,\n              status: job.status,\n              message: job.message,\n            },\n            message: `Store created. Indexing started in background (Job ID: ${job.id})`,\n          },\n          null,\n          2\n        ),\n      },\n    ],\n  };\n};\n\n/**\n * Handle index_store requests\n *\n * Re-indexes an existing store in the background.\n * Returns job ID for tracking progress.\n */\nexport const handleIndexStore: ToolHandler<IndexStoreArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = IndexStoreArgsSchema.parse(args);\n\n  const { services, options } = context;\n\n  const store = await services.store.getByIdOrName(createStoreId(validated.store));\n\n  if (store === undefined) {\n    throw new Error(`Store not found: ${validated.store}`);\n  }\n\n  // Create background job for indexing\n  const jobService = new JobService(options.dataDir);\n  const jobDetails: Record<string, unknown> = {\n    storeName: store.name,\n    storeId: store.id,\n  };\n  if ('path' in store && store.path) {\n    jobDetails['path'] = store.path;\n  }\n  const job = jobService.createJob({\n    type: 'index',\n    details: jobDetails,\n    message: `Re-indexing ${store.name}...`,\n  });\n\n  // Spawn background worker (dataDir defaults to project-local .bluera if undefined)\n  spawnBackgroundWorker(job.id, options.dataDir ?? '');\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(\n          {\n            store: {\n              id: store.id,\n              name: store.name,\n            },\n            job: {\n              id: job.id,\n              status: job.status,\n              message: job.message,\n            },\n            message: `Indexing started in background (Job ID: ${job.id})`,\n          },\n          null,\n          2\n        ),\n      },\n    ],\n  };\n};\n\n/**\n * Handle delete_store requests\n *\n * Deletes a store and all associated data:\n * - Removes from store registry\n * - Drops LanceDB table\n * - For repo stores with URL, removes cloned files\n */\nexport const handleDeleteStore: ToolHandler<DeleteStoreArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = DeleteStoreArgsSchema.parse(args);\n\n  const { services, options } = context;\n\n  const store = await services.store.getByIdOrName(createStoreId(validated.store));\n\n  if (store === undefined) {\n    throw new Error(`Store not found: ${validated.store}`);\n  }\n\n  // Delete LanceDB table first (so searches don't return results for deleted store)\n  await services.lance.deleteStore(store.id);\n\n  // Delete code graph file\n  await services.codeGraph.deleteGraph(store.id);\n\n  // For repo stores cloned from URL, remove the cloned directory\n  if (store.type === 'repo' && 'url' in store && store.url !== undefined) {\n    if (options.dataDir === undefined) {\n      throw new Error('dataDir is required to delete cloned repository files');\n    }\n    const repoPath = join(options.dataDir, 'repos', store.id);\n    await rm(repoPath, { recursive: true, force: true });\n  }\n\n  // Delete from registry last\n  const result = await services.store.delete(store.id);\n  if (!result.success) {\n    throw new Error(result.error.message);\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(\n          {\n            deleted: true,\n            store: {\n              id: store.id,\n              name: store.name,\n              type: store.type,\n            },\n            message: `Successfully deleted store: ${store.name}`,\n          },\n          null,\n          2\n        ),\n      },\n    ],\n  };\n};\n","import { spawn } from 'child_process';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\n/**\n * Spawn a background worker process to execute a job\n *\n * The worker runs detached from the parent process, allowing the\n * parent to exit while the worker continues running.\n *\n * @param jobId - The ID of the job to execute\n */\nexport function spawnBackgroundWorker(jobId: string, dataDir: string): void {\n  // Determine the worker script path\n  // In production, this will be the compiled dist file\n  // In development, we need to use tsx to run TypeScript\n  const __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n  // Check if we're running from dist (production) or src (development)\n  const isProduction = __dirname.includes('/dist/');\n\n  let command: string;\n  let args: string[];\n\n  if (isProduction) {\n    // Production: Use Node.js directly with compiled file\n    const workerScript = path.join(__dirname, 'background-worker-cli.js');\n    command = process.execPath; // Use the same Node.js binary\n    args = [workerScript, jobId];\n  } else {\n    // Development: Use tsx to run TypeScript directly\n    const workerScript = path.join(__dirname, 'background-worker-cli.ts');\n    command = 'npx';\n    args = ['tsx', workerScript, jobId];\n  }\n\n  // Spawn the worker process\n  const worker = spawn(command, args, {\n    detached: true, // Detach from parent process\n    stdio: 'ignore', // Don't pipe stdio (fully independent)\n    env: {\n      ...process.env, // Inherit environment variables\n      BLUERA_DATA_DIR: dataDir, // Pass dataDir to worker\n    },\n  });\n\n  // Unref the worker so the parent can exit\n  worker.unref();\n}\n","import { z } from 'zod';\nimport { JobService } from '../../services/job.service.js';\nimport { StoreDefinitionService } from '../../services/store-definition.service.js';\nimport {\n  isFileStoreDefinition,\n  isRepoStoreDefinition,\n  isWebStoreDefinition,\n} from '../../types/store-definition.js';\nimport { spawnBackgroundWorker } from '../../workers/spawn-worker.js';\nimport type { CommandDefinition } from './registry.js';\nimport type { StoreDefinition } from '../../types/store-definition.js';\nimport type { HandlerContext, ToolResponse } from '../types.js';\n\n/**\n * Arguments for stores:sync command\n */\nexport interface SyncStoresArgs {\n  prune?: boolean;\n  dryRun?: boolean;\n  reindex?: boolean;\n}\n\n/**\n * Result of a sync operation\n */\ninterface SyncResult {\n  created: string[];\n  skipped: string[];\n  failed: Array<{ name: string; error: string }>;\n  orphans: string[];\n  pruned?: string[];\n  dryRun?: boolean;\n  wouldCreate?: string[];\n  wouldPrune?: string[];\n  reindexJobs?: Array<{ store: string; jobId: string }>;\n  wouldReindex?: string[];\n}\n\n/**\n * Handle stores:sync command\n *\n * Syncs stores from definitions config:\n * - Creates missing stores from definitions\n * - Reports stores not in definitions (orphans)\n * - Optionally prunes orphan stores\n */\nexport async function handleStoresSync(\n  args: SyncStoresArgs,\n  context: HandlerContext\n): Promise<ToolResponse> {\n  const { services, options } = context;\n  const projectRoot = options.projectRoot;\n\n  if (projectRoot === undefined) {\n    throw new Error('Project root is required for stores:sync');\n  }\n\n  const defService = new StoreDefinitionService(projectRoot);\n  const config = await defService.load();\n\n  const result: SyncResult = {\n    created: [],\n    skipped: [],\n    failed: [],\n    orphans: [],\n  };\n\n  if (args.dryRun === true) {\n    result.dryRun = true;\n    result.wouldCreate = [];\n    result.wouldPrune = [];\n  }\n\n  // Get existing stores\n  const existingStores = await services.store.list();\n  const existingNames = new Set(existingStores.map((s) => s.name));\n\n  // Process each definition\n  for (const def of config.stores) {\n    if (existingNames.has(def.name)) {\n      result.skipped.push(def.name);\n      continue;\n    }\n\n    if (args.dryRun === true) {\n      result.wouldCreate?.push(def.name);\n      continue;\n    }\n\n    // Try to create the store\n    const createResult = await createStoreFromDefinition(def, defService, services, context);\n    if (createResult.success) {\n      result.created.push(def.name);\n    } else {\n      result.failed.push({ name: def.name, error: createResult.error });\n    }\n  }\n\n  // Find orphans (stores not in definitions)\n  const definedNames = new Set(config.stores.map((d) => d.name));\n  for (const store of existingStores) {\n    if (!definedNames.has(store.name)) {\n      result.orphans.push(store.name);\n    }\n  }\n\n  // Prune orphans if requested\n  if (args.prune === true && result.orphans.length > 0) {\n    if (args.dryRun === true) {\n      result.wouldPrune = [...result.orphans];\n    } else {\n      result.pruned = [];\n      for (const orphanName of result.orphans) {\n        const store = await services.store.getByName(orphanName);\n        if (store !== undefined) {\n          const deleteResult = await services.store.delete(store.id, { skipDefinitionSync: true });\n          if (deleteResult.success) {\n            result.pruned.push(orphanName);\n          }\n        }\n      }\n    }\n  }\n\n  // Re-index existing stores if requested\n  if (args.reindex === true && result.skipped.length > 0) {\n    if (args.dryRun === true) {\n      result.wouldReindex = [...result.skipped];\n    } else {\n      result.reindexJobs = [];\n      const dataDir = options.dataDir;\n      if (dataDir === undefined) {\n        throw new Error('dataDir is required for reindexing');\n      }\n      const jobService = new JobService(dataDir);\n\n      for (const storeName of result.skipped) {\n        const store = await services.store.getByName(storeName);\n        if (store !== undefined) {\n          const job = jobService.createJob({\n            type: 'index',\n            details: { storeId: store.id, storeName: store.name },\n            message: `Re-indexing ${storeName}...`,\n          });\n          spawnBackgroundWorker(job.id, dataDir);\n          result.reindexJobs.push({ store: storeName, jobId: job.id });\n        }\n      }\n    }\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(result, null, 2),\n      },\n    ],\n  };\n}\n\n/**\n * Create a store from a definition\n */\nasync function createStoreFromDefinition(\n  def: StoreDefinition,\n  defService: StoreDefinitionService,\n  services: HandlerContext['services'],\n  _context: HandlerContext\n): Promise<{ success: true } | { success: false; error: string }> {\n  try {\n    if (isFileStoreDefinition(def)) {\n      // Resolve path relative to project root\n      const resolvedPath = defService.resolvePath(def.path);\n      const createResult = await services.store.create(\n        {\n          name: def.name,\n          type: 'file',\n          path: resolvedPath,\n          description: def.description,\n          tags: def.tags,\n        },\n        { skipDefinitionSync: true } // Don't re-add to definitions\n      );\n      if (!createResult.success) {\n        return { success: false, error: createResult.error.message };\n      }\n      return { success: true };\n    }\n\n    if (isRepoStoreDefinition(def)) {\n      const createResult = await services.store.create(\n        {\n          name: def.name,\n          type: 'repo',\n          url: def.url,\n          branch: def.branch,\n          depth: def.depth,\n          description: def.description,\n          tags: def.tags,\n        },\n        { skipDefinitionSync: true }\n      );\n      if (!createResult.success) {\n        return { success: false, error: createResult.error.message };\n      }\n      return { success: true };\n    }\n\n    if (isWebStoreDefinition(def)) {\n      const createResult = await services.store.create(\n        {\n          name: def.name,\n          type: 'web',\n          url: def.url,\n          depth: def.depth,\n          description: def.description,\n          tags: def.tags,\n        },\n        { skipDefinitionSync: true }\n      );\n      if (!createResult.success) {\n        return { success: false, error: createResult.error.message };\n      }\n      return { success: true };\n    }\n\n    return { success: false, error: 'Unknown store definition type' };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Sync commands for the execute meta-tool\n */\nexport const syncCommands: CommandDefinition[] = [\n  {\n    name: 'stores:sync',\n    description: 'Sync stores from definitions config (bootstrap on fresh clone)',\n    argsSchema: z.object({\n      prune: z.boolean().optional().describe('Remove stores not in definitions'),\n      dryRun: z.boolean().optional().describe('Show what would happen without making changes'),\n      reindex: z.boolean().optional().describe('Re-index existing stores after sync'),\n    }),\n    handler: (args: Record<string, unknown>, context: HandlerContext): Promise<ToolResponse> => {\n      const syncArgs: SyncStoresArgs = {};\n      if (typeof args['prune'] === 'boolean') {\n        syncArgs.prune = args['prune'];\n      }\n      if (typeof args['dryRun'] === 'boolean') {\n        syncArgs.dryRun = args['dryRun'];\n      }\n      if (typeof args['reindex'] === 'boolean') {\n        syncArgs.reindex = args['reindex'];\n      }\n      return handleStoresSync(syncArgs, context);\n    },\n  },\n];\n","import { readFile, writeFile, mkdir, access } from 'node:fs/promises';\nimport { dirname, resolve, isAbsolute, join } from 'node:path';\nimport { ProjectRootService } from './project-root.service.js';\nimport {\n  StoreDefinitionsConfigSchema,\n  DEFAULT_STORE_DEFINITIONS_CONFIG,\n} from '../types/store-definition.js';\nimport type { StoreDefinitionsConfig, StoreDefinition } from '../types/store-definition.js';\n\n/**\n * Check if a file exists\n */\nasync function fileExists(path: string): Promise<boolean> {\n  try {\n    await access(path);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Service for managing git-committable store definitions.\n *\n * Store definitions are saved to `.bluera/bluera-knowledge/stores.config.json`\n * within the project root. This file is designed to be committed to version\n * control, allowing teams to share store configurations.\n *\n * The actual store data (vector embeddings, cloned repos) lives in the data\n * directory and should be gitignored.\n */\nexport class StoreDefinitionService {\n  private readonly configPath: string;\n  private readonly projectRoot: string;\n  private config: StoreDefinitionsConfig | null = null;\n\n  constructor(projectRoot?: string) {\n    this.projectRoot = projectRoot ?? ProjectRootService.resolve();\n    this.configPath = join(this.projectRoot, '.bluera/bluera-knowledge/stores.config.json');\n  }\n\n  /**\n   * Load store definitions from config file.\n   * Returns empty config if file doesn't exist.\n   * Throws on parse/validation errors (fail fast per CLAUDE.md).\n   */\n  async load(): Promise<StoreDefinitionsConfig> {\n    if (this.config !== null) {\n      return this.config;\n    }\n\n    const exists = await fileExists(this.configPath);\n    if (!exists) {\n      // Deep clone to avoid mutating the shared default\n      this.config = {\n        ...DEFAULT_STORE_DEFINITIONS_CONFIG,\n        stores: [...DEFAULT_STORE_DEFINITIONS_CONFIG.stores],\n      };\n      return this.config;\n    }\n\n    const content = await readFile(this.configPath, 'utf-8');\n    let parsed: unknown;\n    try {\n      parsed = JSON.parse(content);\n    } catch (error) {\n      throw new Error(\n        `Failed to parse store definitions at ${this.configPath}: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n\n    const result = StoreDefinitionsConfigSchema.safeParse(parsed);\n    if (!result.success) {\n      throw new Error(`Invalid store definitions at ${this.configPath}: ${result.error.message}`);\n    }\n\n    this.config = result.data;\n    return this.config;\n  }\n\n  /**\n   * Save store definitions to config file.\n   */\n  async save(config: StoreDefinitionsConfig): Promise<void> {\n    await mkdir(dirname(this.configPath), { recursive: true });\n    await writeFile(this.configPath, JSON.stringify(config, null, 2));\n    this.config = config;\n  }\n\n  /**\n   * Add a store definition.\n   * Throws if a definition with the same name already exists.\n   */\n  async addDefinition(definition: StoreDefinition): Promise<void> {\n    const config = await this.load();\n    const existing = config.stores.find((s) => s.name === definition.name);\n    if (existing !== undefined) {\n      throw new Error(`Store definition \"${definition.name}\" already exists`);\n    }\n    config.stores.push(definition);\n    await this.save(config);\n  }\n\n  /**\n   * Remove a store definition by name.\n   * Returns true if removed, false if not found.\n   */\n  async removeDefinition(name: string): Promise<boolean> {\n    const config = await this.load();\n    const index = config.stores.findIndex((s) => s.name === name);\n    if (index === -1) {\n      return false;\n    }\n    config.stores.splice(index, 1);\n    await this.save(config);\n    return true;\n  }\n\n  /**\n   * Update an existing store definition.\n   * Only updates the provided fields, preserving others.\n   * Throws if definition not found.\n   */\n  async updateDefinition(\n    name: string,\n    updates: { description?: string; tags?: string[] }\n  ): Promise<void> {\n    const config = await this.load();\n    const index = config.stores.findIndex((s) => s.name === name);\n    if (index === -1) {\n      throw new Error(`Store definition \"${name}\" not found`);\n    }\n\n    // Merge updates while preserving type safety\n    // We only allow updating common optional fields (description, tags)\n    const existing = config.stores[index];\n    if (existing === undefined) {\n      throw new Error(`Store definition \"${name}\" not found at index ${String(index)}`);\n    }\n    if (updates.description !== undefined) {\n      existing.description = updates.description;\n    }\n    if (updates.tags !== undefined) {\n      existing.tags = updates.tags;\n    }\n    await this.save(config);\n  }\n\n  /**\n   * Get a store definition by name.\n   * Returns undefined if not found.\n   */\n  async getByName(name: string): Promise<StoreDefinition | undefined> {\n    const config = await this.load();\n    return config.stores.find((s) => s.name === name);\n  }\n\n  /**\n   * Check if any definitions exist.\n   */\n  async hasDefinitions(): Promise<boolean> {\n    const config = await this.load();\n    return config.stores.length > 0;\n  }\n\n  /**\n   * Resolve a file store path relative to project root.\n   */\n  resolvePath(path: string): string {\n    if (isAbsolute(path)) {\n      return path;\n    }\n    return resolve(this.projectRoot, path);\n  }\n\n  /**\n   * Get the config file path.\n   */\n  getConfigPath(): string {\n    return this.configPath;\n  }\n\n  /**\n   * Get the project root.\n   */\n  getProjectRoot(): string {\n    return this.projectRoot;\n  }\n\n  /**\n   * Clear the cached config (useful for testing).\n   */\n  clearCache(): void {\n    this.config = null;\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Store definition schemas for git-committable configuration.\n *\n * Store definitions capture the essential information needed to recreate\n * a store, without the runtime data (vector embeddings, cloned repos).\n * This allows teams to share store configurations via version control.\n */\n\n// ============================================================================\n// Base Schema\n// ============================================================================\n\n/**\n * Base fields common to all store definitions\n */\nconst BaseStoreDefinitionSchema = z.object({\n  name: z.string().min(1, 'Store name is required'),\n  description: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n});\n\n// ============================================================================\n// File Store Definition\n// ============================================================================\n\n/**\n * File store definition - references a local directory.\n * Path can be relative (resolved against project root) or absolute.\n */\nexport const FileStoreDefinitionSchema = BaseStoreDefinitionSchema.extend({\n  type: z.literal('file'),\n  path: z.string().min(1, 'Path is required for file stores'),\n});\n\nexport type FileStoreDefinition = z.infer<typeof FileStoreDefinitionSchema>;\n\n// ============================================================================\n// Repo Store Definition\n// ============================================================================\n\n/**\n * Repo store definition - references a git repository.\n * The repo will be cloned on sync.\n */\nexport const RepoStoreDefinitionSchema = BaseStoreDefinitionSchema.extend({\n  type: z.literal('repo'),\n  url: z.url('Valid URL is required for repo stores'),\n  branch: z.string().optional(),\n  depth: z.number().int().positive('Depth must be a positive integer').optional(),\n});\n\nexport type RepoStoreDefinition = z.infer<typeof RepoStoreDefinitionSchema>;\n\n// ============================================================================\n// Web Store Definition\n// ============================================================================\n\n/**\n * Web store definition - references a website to crawl.\n * Supports intelligent crawling with natural language instructions.\n */\nexport const WebStoreDefinitionSchema = BaseStoreDefinitionSchema.extend({\n  type: z.literal('web'),\n  url: z.url('Valid URL is required for web stores'),\n  depth: z.number().int().min(0, 'Depth must be non-negative').default(1),\n  maxPages: z.number().int().positive('maxPages must be a positive integer').optional(),\n  crawlInstructions: z.string().optional(),\n  extractInstructions: z.string().optional(),\n});\n\nexport type WebStoreDefinition = z.infer<typeof WebStoreDefinitionSchema>;\n\n// ============================================================================\n// Union Type\n// ============================================================================\n\n/**\n * Discriminated union of all store definition types.\n * Use the `type` field to narrow the type.\n */\nexport const StoreDefinitionSchema = z.discriminatedUnion('type', [\n  FileStoreDefinitionSchema,\n  RepoStoreDefinitionSchema,\n  WebStoreDefinitionSchema,\n]);\n\nexport type StoreDefinition = z.infer<typeof StoreDefinitionSchema>;\n\n// ============================================================================\n// Config Schema\n// ============================================================================\n\n/**\n * Root configuration schema for store definitions.\n * Version field enables future schema migrations.\n */\nexport const StoreDefinitionsConfigSchema = z.object({\n  version: z.literal(1),\n  stores: z.array(StoreDefinitionSchema),\n});\n\nexport type StoreDefinitionsConfig = z.infer<typeof StoreDefinitionsConfigSchema>;\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\nexport function isFileStoreDefinition(def: StoreDefinition): def is FileStoreDefinition {\n  return def.type === 'file';\n}\n\nexport function isRepoStoreDefinition(def: StoreDefinition): def is RepoStoreDefinition {\n  return def.type === 'repo';\n}\n\nexport function isWebStoreDefinition(def: StoreDefinition): def is WebStoreDefinition {\n  return def.type === 'web';\n}\n\n// ============================================================================\n// Default Config\n// ============================================================================\n\nexport const DEFAULT_STORE_DEFINITIONS_CONFIG: StoreDefinitionsConfig = {\n  version: 1,\n  stores: [],\n};\n","/**\n * Command registration for the execute meta-tool\n *\n * This module registers all commands with the command registry.\n * Import this module to ensure all commands are available.\n */\n\nimport { jobCommands } from './job.commands.js';\nimport { metaCommands } from './meta.commands.js';\nimport { commandRegistry } from './registry.js';\nimport { storeCommands } from './store.commands.js';\nimport { syncCommands } from './sync.commands.js';\n\n// Register all commands\ncommandRegistry.registerAll(storeCommands);\ncommandRegistry.registerAll(jobCommands);\ncommandRegistry.registerAll(metaCommands);\ncommandRegistry.registerAll(syncCommands);\n\n// Re-export for convenience\nexport { commandRegistry, executeCommand, generateHelp } from './registry.js';\nexport type { CommandDefinition, CommandHandler } from './registry.js';\n","// Import commands module - side effect registers all commands, then use executeCommand\nimport { executeCommand } from '../commands/index.js';\nimport { ExecuteArgsSchema } from '../schemas/index.js';\nimport type { ExecuteArgs } from '../schemas/index.js';\nimport type { ToolHandler, ToolResponse } from '../types.js';\n\n/**\n * Handle execute requests\n *\n * This is the meta-tool handler that routes to registered commands.\n * It consolidates store and job management into a single tool surface.\n */\nexport const handleExecute: ToolHandler<ExecuteArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = ExecuteArgsSchema.parse(args);\n\n  const commandArgs = validated.args ?? {};\n\n  return executeCommand(validated.command, commandArgs, context);\n};\n","/**\n * Token estimation service using Anthropic's recommended heuristic.\n * For Claude 3+ models, Anthropic recommends ~3.5 characters per token\n * for English text. This varies by language.\n *\n * Note: The official @anthropic-ai/tokenizer package only works for\n * pre-Claude 3 models. For accurate counts on Claude 3+, use the\n * Token Count API. This heuristic is suitable for display purposes.\n */\n\nconst CHARS_PER_TOKEN = 3.5;\n\n/**\n * Estimate token count for a string using character-based heuristic.\n * @param text - The text to estimate tokens for\n * @returns Estimated token count (rounded up)\n */\nexport function estimateTokens(text: string): number {\n  if (!text) return 0;\n  return Math.ceil(text.length / CHARS_PER_TOKEN);\n}\n\n/**\n * Format token count for display with appropriate suffix.\n * @param tokens - Token count\n * @returns Formatted string like \"~1.2k\" or \"~847\"\n */\nexport function formatTokenCount(tokens: number): string {\n  if (tokens >= 1000) {\n    return `~${(tokens / 1000).toFixed(1)}k`;\n  }\n  return `~${String(tokens)}`;\n}\n","/**\n * LRU (Least Recently Used) Cache implementation\n *\n * Maintains a cache with a maximum size, evicting the oldest (least recently used)\n * items when the capacity is exceeded. This prevents unbounded memory growth.\n *\n * Items are automatically moved to the end of the cache when accessed (via get),\n * making them the most recently used.\n */\nexport class LRUCache<K, V> {\n  private readonly cache = new Map<K, V>();\n  private readonly maxSize: number;\n\n  /**\n   * Create a new LRU cache\n   *\n   * @param maxSize - Maximum number of items to store (default: 1000)\n   */\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Store a value in the cache\n   *\n   * If the key already exists, it will be moved to the end (most recent).\n   * If the cache is at capacity, the oldest item will be evicted.\n   *\n   * @param key - The cache key\n   * @param value - The value to store\n   */\n  set(key: K, value: V): void {\n    // If key exists, delete it first to move it to the end\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    // Add the new/updated entry\n    this.cache.set(key, value);\n\n    // Evict oldest entry if over capacity\n    if (this.cache.size > this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey !== undefined) {\n        this.cache.delete(firstKey);\n      }\n    }\n  }\n\n  /**\n   * Retrieve a value from the cache\n   *\n   * If the key exists, it will be moved to the end (most recent).\n   *\n   * @param key - The cache key\n   * @returns The cached value, or undefined if not found\n   */\n  get(key: K): V | undefined {\n    const value = this.cache.get(key);\n\n    if (value !== undefined) {\n      // Move to end (most recent) by deleting and re-adding\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Check if a key exists in the cache\n   *\n   * @param key - The cache key\n   * @returns True if the key exists\n   */\n  has(key: K): boolean {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Remove a specific key from the cache\n   *\n   * @param key - The cache key\n   * @returns True if the key was removed, false if it didn't exist\n   */\n  delete(key: K): boolean {\n    return this.cache.delete(key);\n  }\n\n  /**\n   * Clear all entries from the cache\n   */\n  clear(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get the current number of items in the cache\n   */\n  get size(): number {\n    return this.cache.size;\n  }\n}\n","import { createLogger, summarizePayload } from '../../logging/index.js';\nimport { estimateTokens, formatTokenCount } from '../../services/token.service.js';\nimport { LRUCache } from '../cache.js';\nimport { SearchArgsSchema, GetFullContextArgsSchema } from '../schemas/index.js';\nimport type { SearchQuery, DocumentId, StoreId } from '../../types/index.js';\nimport type { SearchResult } from '../../types/search.js';\nimport type { SearchArgs, GetFullContextArgs } from '../schemas/index.js';\nimport type { ToolHandler, ToolResponse } from '../types.js';\n\nconst logger = createLogger('mcp-search');\n\n// Create result cache for get_full_context\n// Uses LRU cache to prevent memory leaks (max 1000 items)\nexport const resultCache = new LRUCache<DocumentId, SearchResult>(1000);\n\n/**\n * Handle search requests\n *\n * Searches across specified stores (or all stores if none specified) using\n * hybrid vector + FTS search. Results are cached for get_full_context retrieval.\n */\nexport const handleSearch: ToolHandler<SearchArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = SearchArgsSchema.parse(args);\n\n  logger.info(\n    {\n      query: validated.query,\n      stores: validated.stores,\n      mode: validated.mode,\n      detail: validated.detail,\n      limit: validated.limit,\n      intent: validated.intent,\n    },\n    'Search started'\n  );\n\n  const { services } = context;\n\n  // Get all stores if none specified, resolve store names to IDs\n  const storeIds: StoreId[] =\n    validated.stores !== undefined\n      ? await Promise.all(\n          validated.stores.map(async (s) => {\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n            const store = await services.store.getByIdOrName(s as StoreId);\n            if (!store) {\n              throw new Error(`Store not found: ${s}`);\n            }\n            return store.id;\n          })\n        )\n      : (await services.store.list()).map((s) => s.id);\n\n  // Initialize stores with error handling\n  try {\n    for (const storeId of storeIds) {\n      await services.lance.initialize(storeId);\n    }\n  } catch (error) {\n    throw new Error(\n      `Failed to initialize vector stores: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n\n  // Perform search\n  const searchQuery: SearchQuery = {\n    query: validated.query,\n    stores: storeIds,\n    mode: validated.mode,\n    limit: validated.limit,\n    detail: validated.detail,\n    threshold: validated.threshold,\n    minRelevance: validated.minRelevance,\n  };\n\n  const results = await services.search.search(searchQuery);\n\n  // Cache results for get_full_context (with LRU eviction)\n  for (const result of results.results) {\n    resultCache.set(result.id, result);\n  }\n\n  // Add repoRoot to results for cloned repos\n  const enhancedResults = await Promise.all(\n    results.results.map(async (r) => {\n      const storeId = r.metadata.storeId;\n      const store = await services.store.getByIdOrName(storeId);\n\n      return {\n        id: r.id,\n        score: r.score,\n        summary: {\n          ...r.summary,\n          storeName: store?.name,\n          repoRoot: store?.type === 'repo' ? store.path : undefined,\n        },\n        context: r.context,\n        full: r.full,\n      };\n    })\n  );\n\n  const responseJson = JSON.stringify(\n    {\n      results: enhancedResults,\n      totalResults: results.totalResults,\n      mode: results.mode,\n      timeMs: results.timeMs,\n      confidence: results.confidence,\n      maxRawScore: results.maxRawScore,\n    },\n    null,\n    2\n  );\n\n  // Calculate actual token estimate based on response content\n  const responseTokens = estimateTokens(responseJson);\n\n  // Create visible header with token usage and confidence\n  const confidenceInfo =\n    results.confidence !== undefined ? ` | Confidence: ${results.confidence}` : '';\n  const header = `Search: \"${validated.query}\" | Results: ${String(results.totalResults)} | ${formatTokenCount(responseTokens)} tokens | ${String(results.timeMs)}ms${confidenceInfo}\\n\\n`;\n\n  // Log the complete MCP response that will be sent to Claude Code\n  logger.info(\n    {\n      query: validated.query,\n      totalResults: results.totalResults,\n      responseTokens,\n      timeMs: results.timeMs,\n      ...summarizePayload(responseJson, 'mcp-response', validated.query),\n    },\n    'Search complete - context sent to Claude Code'\n  );\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: header + responseJson,\n      },\n    ],\n  };\n};\n\n/**\n * Handle get_full_context requests\n *\n * Retrieves full context for a previously cached search result.\n * If the result isn't already full, re-queries with full detail level.\n */\nexport const handleGetFullContext: ToolHandler<GetFullContextArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = GetFullContextArgsSchema.parse(args);\n\n  logger.info({ resultId: validated.resultId }, 'Get full context requested');\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const resultId = validated.resultId as DocumentId;\n\n  // Check cache for result\n  const cachedResult = resultCache.get(resultId);\n\n  if (!cachedResult) {\n    throw new Error(`Result not found in cache: ${resultId}. Run a search first to cache results.`);\n  }\n\n  // If result already has full context, return it\n  if (cachedResult.full) {\n    const responseJson = JSON.stringify(\n      {\n        id: cachedResult.id,\n        score: cachedResult.score,\n        summary: cachedResult.summary,\n        context: cachedResult.context,\n        full: cachedResult.full,\n      },\n      null,\n      2\n    );\n\n    logger.info(\n      {\n        resultId,\n        cached: true,\n        hasFullContext: true,\n        ...summarizePayload(responseJson, 'mcp-full-context', resultId),\n      },\n      'Full context retrieved from cache'\n    );\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: responseJson,\n        },\n      ],\n    };\n  }\n\n  // Otherwise, re-query with full detail\n  const { services } = context;\n  const store = await services.store.getByIdOrName(cachedResult.metadata.storeId);\n\n  if (!store) {\n    throw new Error(`Store not found: ${cachedResult.metadata.storeId}`);\n  }\n\n  await services.lance.initialize(store.id);\n\n  const searchQuery: SearchQuery = {\n    query: cachedResult.content.substring(0, 100), // Use snippet of content as query\n    stores: [store.id],\n    mode: 'hybrid',\n    limit: 1,\n    detail: 'full',\n  };\n\n  const results = await services.search.search(searchQuery);\n\n  // Find matching result by ID\n  const fullResult = results.results.find((r) => r.id === resultId);\n\n  if (!fullResult) {\n    // Return cached result even if we couldn't get full detail\n    return {\n      content: [\n        {\n          type: 'text',\n          text: JSON.stringify(\n            {\n              id: cachedResult.id,\n              score: cachedResult.score,\n              summary: cachedResult.summary,\n              context: cachedResult.context,\n              warning: 'Could not retrieve full context, returning cached minimal result',\n            },\n            null,\n            2\n          ),\n        },\n      ],\n    };\n  }\n\n  // Update cache with full result\n  resultCache.set(resultId, fullResult);\n\n  const responseJson = JSON.stringify(\n    {\n      id: fullResult.id,\n      score: fullResult.score,\n      summary: fullResult.summary,\n      context: fullResult.context,\n      full: fullResult.full,\n    },\n    null,\n    2\n  );\n\n  logger.info(\n    {\n      resultId,\n      cached: false,\n      hasFullContext: true,\n      ...summarizePayload(responseJson, 'mcp-full-context', resultId),\n    },\n    'Full context retrieved via re-query'\n  );\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: responseJson,\n      },\n    ],\n  };\n};\n","import { z } from 'zod';\nimport { handleSearch, handleGetFullContext } from './search.handler.js';\nimport { SearchArgsSchema, GetFullContextArgsSchema } from '../schemas/index.js';\nimport type { ToolHandler } from '../types.js';\n\n/**\n * Tool definition with schema and handler\n */\nexport interface ToolDefinition {\n  name: string;\n  description: string;\n  schema: z.ZodType;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- heterogeneous tool registry requires any; schema provides runtime type safety via Zod validation\n  handler: ToolHandler<any>;\n}\n\n/**\n * Registry of native MCP tools\n *\n * Only search and get_full_context are native tools with full schemas.\n * Store and job management is consolidated into the execute meta-tool\n * (see commands/ directory and execute.handler.ts).\n */\nexport const tools: ToolDefinition[] = [\n  {\n    name: 'search',\n    description:\n      'Search all indexed knowledge stores with pattern detection and AI-optimized results. Returns structured code units with progressive context layers.',\n    schema: SearchArgsSchema,\n    handler: handleSearch,\n  },\n  {\n    name: 'get_full_context',\n    description:\n      'Get complete code and context for a specific search result by ID. Use this after search to get full implementation details.',\n    schema: GetFullContextArgsSchema,\n    handler: handleGetFullContext,\n  },\n];\n"],"mappings":";;;;;;;;;;;;AAAA,SAAS,cAAc;AACvB,SAAS,4BAA4B;AACrC,SAAS,uBAAuB,8BAA8B;;;ACkCvD,IAAM,WAAN,MAAe;AAAA,EACZ,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,SAAS;AAAA,EACT,SAAkB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS3B,SAAS,OAAwB;AAC/B,SAAK,QAAQ;AACb,SAAK,MAAM;AACX,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,SAAS,CAAC;AAEf,WAAO,CAAC,KAAK,QAAQ,GAAG;AACtB,WAAK,UAAU;AAAA,IACjB;AAEA,WAAO,KAAK;AAAA,EACd;AAAA,EAEQ,UAAmB;AACzB,WAAO,KAAK,OAAO,KAAK,MAAM;AAAA,EAChC;AAAA,EAEQ,OAAe;AACrB,QAAI,KAAK,QAAQ,EAAG,QAAO;AAC3B,WAAO,KAAK,MAAM,KAAK,GAAG,KAAK;AAAA,EACjC;AAAA,EAEQ,UAAkB;AACxB,UAAM,OAAO,KAAK,MAAM,KAAK,GAAG,KAAK;AACrC,SAAK;AAEL,QAAI,SAAS,MAAM;AACjB,WAAK;AACL,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK;AAAA,IACP;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,SAAS,MAAiB,OAAe,WAAmB,aAA2B;AAC7F,SAAK,OAAO,KAAK;AAAA,MACf;AAAA,MACA;AAAA,MACA,MAAM;AAAA,MACN,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAAA,EAEQ,YAAkB;AACxB,UAAM,YAAY,KAAK;AACvB,UAAM,cAAc,KAAK;AACzB,UAAM,OAAO,KAAK,QAAQ;AAE1B,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,aAAK,SAAS,uBAAkB,KAAK,WAAW,WAAW;AAC3D;AAAA,MACF,KAAK;AACH,aAAK,SAAS,uBAAkB,KAAK,WAAW,WAAW;AAC3D;AAAA,MACF,KAAK;AACH,aAAK,SAAS,uBAAkB,KAAK,WAAW,WAAW;AAC3D;AAAA,MACF,KAAK;AACH,aAAK,SAAS,uBAAkB,KAAK,WAAW,WAAW;AAC3D;AAAA,MACF,KAAK;AACH,aAAK,WAAW,WAAW,WAAW;AACtC;AAAA,MACF,KAAK;AACH,aAAK,YAAY;AACjB;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAEH;AAAA,MACF;AACE,YAAI,KAAK,QAAQ,IAAI,KAAM,SAAS,OAAO,KAAK,QAAQ,KAAK,KAAK,CAAC,GAAI;AACrE,eAAK,WAAW,MAAM,WAAW,WAAW;AAAA,QAC9C,WAAW,KAAK,YAAY,IAAI,GAAG;AACjC,eAAK,SAAS,MAAM,WAAW,WAAW;AAAA,QAC5C;AAEA;AAAA,IACJ;AAAA,EACF;AAAA,EAEQ,WAAW,WAAmB,aAA2B;AAC/D,QAAI,QAAQ;AAEZ,WAAO,CAAC,KAAK,QAAQ,KAAK,KAAK,KAAK,MAAM,KAAK;AAC7C,YAAM,OAAO,KAAK,KAAK;AAEvB,UAAI,SAAS,MAAM;AACjB,aAAK,QAAQ;AACb,cAAM,UAAU,KAAK,QAAQ;AAC7B,gBAAQ,SAAS;AAAA,UACf,KAAK;AACH,qBAAS;AACT;AAAA,UACF,KAAK;AACH,qBAAS;AACT;AAAA,UACF,KAAK;AACH,qBAAS;AACT;AAAA,UACF,KAAK;AACH,qBAAS;AACT;AAAA,UACF;AACE,qBAAS;AACT;AAAA,QACJ;AAAA,MACF,OAAO;AACL,iBAAS,KAAK,QAAQ;AAAA,MACxB;AAAA,IACF;AAEA,QAAI,KAAK,QAAQ,GAAG;AAClB,YAAM,IAAI;AAAA,QACR,+BAA+B,OAAO,SAAS,CAAC,YAAY,OAAO,WAAW,CAAC;AAAA,MACjF;AAAA,IACF;AAGA,SAAK,QAAQ;AAEb,SAAK,SAAS,uBAAkB,OAAO,WAAW,WAAW;AAAA,EAC/D;AAAA,EAEQ,WAAW,WAAmB,WAAmB,aAA2B;AAClF,QAAI,QAAQ;AAEZ,WAAO,KAAK,QAAQ,KAAK,KAAK,CAAC,GAAG;AAChC,eAAS,KAAK,QAAQ;AAAA,IACxB;AAEA,SAAK,SAAS,uBAAkB,OAAO,WAAW,WAAW;AAAA,EAC/D;AAAA,EAEQ,SAAS,WAAmB,WAAmB,aAA2B;AAChF,QAAI,QAAQ;AAEZ,WAAO,KAAK,WAAW,KAAK,KAAK,CAAC,GAAG;AACnC,eAAS,KAAK,QAAQ;AAAA,IACxB;AAEA,SAAK,SAAS,mBAAgB,OAAO,WAAW,WAAW;AAAA,EAC7D;AAAA,EAEQ,cAAoB;AAE1B,WAAO,CAAC,KAAK,QAAQ,KAAK,KAAK,KAAK,MAAM,MAAM;AAC9C,WAAK,QAAQ;AAAA,IACf;AAAA,EACF;AAAA,EAEQ,QAAQ,MAAuB;AACrC,WAAO,QAAQ,OAAO,QAAQ;AAAA,EAChC;AAAA,EAEQ,YAAY,MAAuB;AACzC,WACG,QAAQ,OAAO,QAAQ,OACvB,QAAQ,OAAO,QAAQ,OACxB,SAAS,OACT,SAAS;AAAA,IACT,SAAS;AAAA,IACT,SAAS;AAAA,IACT,SAAS;AAAA,EAEb;AAAA,EAEQ,WAAW,MAAuB;AACxC,WACG,QAAQ,OAAO,QAAQ,OACvB,QAAQ,OAAO,QAAQ,OACvB,QAAQ,OAAO,QAAQ,OACxB,SAAS,OACT,SAAS,OACT,SAAS,OACT,SAAS,OACT,SAAS,OACT,SAAS,OACT,SAAS,OACT,SAAS;AAAA,EAEb;AACF;;;ACnOO,IAAM,oBAAoB,oBAAI,IAAI;AAAA;AAAA,EAEvC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAKM,SAAS,cAAc,MAAuB;AACnD,SAAO,kBAAkB,IAAI,KAAK,YAAY,CAAC;AACjD;AAKO,IAAM,uBAAuB,oBAAI,IAAI;AAAA,EAC1C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAKM,SAAS,iBAAiB,MAAuB;AACtD,SAAO,qBAAqB,IAAI,KAAK,YAAY,CAAC;AACpD;;;AC/GO,IAAM,YAAN,MAAgB;AAAA,EACJ,QAAQ,IAAI,SAAS;AAAA,EAC9B,SAAkB,CAAC;AAAA,EACnB,MAAM;AAAA;AAAA;AAAA;AAAA,EAKd,MAAM,OAA+B;AACnC,SAAK,SAAS,KAAK,MAAM,SAAS,KAAK;AACvC,SAAK,MAAM;AAEX,UAAM,QAAmB,CAAC;AAC1B,UAAM,UAAuB,CAAC;AAC9B,UAAM,UAAwB,CAAC;AAC/B,UAAM,QAAmB,CAAC;AAG1B,WAAO,CAAC,KAAK,QAAQ,GAAG;AACtB,UAAI,KAAK,2BAAsB,GAAG;AAChC,cAAM,OAAO,KAAK,UAAU;AAC5B,YAAI,SAAS,QAAW;AACtB,gBAAM,KAAK,IAAI;AAGf,gBAAM,SAAS,KAAK,cAAc,IAAI;AACtC,cAAI,WAAW,QAAW;AACxB,oBAAQ,KAAK,MAAM;AAAA,UACrB;AAGA,gBAAM,MAAM,KAAK,cAAc,IAAI;AACnC,cAAI,QAAQ,QAAW;AACrB,oBAAQ,KAAK,GAAG;AAAA,UAClB;AAGA,cAAI,KAAK,KAAK,YAAY,MAAM,WAAW;AACzC,kBAAM,cAAc,KAAK,eAAe,IAAI;AAC5C,gBAAI,gBAAgB,QAAW;AAC7B,mBAAK,aAAa,MAAM,aAAa,KAAK;AAAA,YAC5C;AAAA,UACF;AAAA,QACF;AAAA,MACF,OAAO;AAEL,aAAK,QAAQ;AAAA,MACf;AAAA,IACF;AAEA,WAAO,EAAE,OAAO,SAAS,SAAS,MAAM;AAAA,EAC1C;AAAA,EAEQ,UAAmB;AACzB,WAAO,KAAK,OAAO,KAAK,OAAO;AAAA,EACjC;AAAA,EAEQ,OAA0B;AAChC,WAAO,KAAK,OAAO,KAAK,GAAG;AAAA,EAC7B;AAAA,EAEQ,MAAM,MAA0B;AACtC,QAAI,KAAK,QAAQ,EAAG,QAAO;AAC3B,WAAO,KAAK,KAAK,GAAG,SAAS;AAAA,EAC/B;AAAA,EAEQ,UAA6B;AACnC,QAAI,CAAC,KAAK,QAAQ,GAAG;AACnB,YAAM,QAAQ,KAAK,OAAO,KAAK,GAAG;AAClC,WAAK;AACL,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,YAAiC;AACvC,QAAI,CAAC,KAAK,2BAAsB,EAAG,QAAO;AAE1C,UAAM,aAAa,KAAK,QAAQ;AAChC,UAAM,YAAY,YAAY,QAAQ;AACtC,QAAI,UAAU;AAGd,QAAI,OAAO;AACX,QAAI,KAAK,uBAAoB,GAAG;AAC9B,aAAO,KAAK,QAAQ,GAAG,SAAS;AAAA,IAClC;AAEA,UAAM,WAAsB,CAAC;AAG7B,WAAO,CAAC,KAAK,QAAQ,KAAK,CAAC,KAAK,2BAAsB,GAAG;AACvD,YAAM,QAAQ,KAAK,UAAU;AAC7B,UAAI,UAAU,QAAW;AACvB,iBAAS,KAAK,KAAK;AACnB,kBAAU,KAAK,eAAe,KAAK;AAAA,MACrC,OAAO;AAEL,aAAK,QAAQ;AAAA,MACf;AAAA,IACF;AAEA,QAAI,KAAK,2BAAsB,GAAG;AAChC,YAAM,aAAa,KAAK,QAAQ;AAChC,gBAAU,YAAY,QAAQ;AAAA,IAChC;AAEA,WAAO,EAAE,MAAM,UAAU,WAAW,QAAQ;AAAA,EAC9C;AAAA,EAEQ,aAAmC;AACzC,QAAI,CAAC,KAAK,2BAAsB,EAAG,QAAO;AAE1C,UAAM,aAAa,KAAK,QAAQ;AAChC,UAAM,YAAY,YAAY,QAAQ;AACtC,QAAI,UAAU;AAEd,UAAM,WAAsB,CAAC;AAE7B,WAAO,CAAC,KAAK,QAAQ,KAAK,CAAC,KAAK,2BAAsB,GAAG;AACvD,YAAM,QAAQ,KAAK,UAAU;AAC7B,UAAI,UAAU,QAAW;AACvB,iBAAS,KAAK,KAAK;AACnB,kBAAU,KAAK,eAAe,KAAK;AAAA,MACrC,OAAO;AACL,aAAK,QAAQ;AAAA,MACf;AAAA,IACF;AAEA,QAAI,KAAK,2BAAsB,GAAG;AAChC,YAAM,aAAa,KAAK,QAAQ;AAChC,gBAAU,YAAY,QAAQ;AAAA,IAChC;AAEA,WAAO,EAAE,MAAM,SAAS,UAAU,WAAW,QAAQ;AAAA,EACvD;AAAA,EAEQ,YAAiC;AACvC,UAAM,QAAQ,KAAK,KAAK;AACxB,QAAI,UAAU,OAAW,QAAO;AAEhC,YAAQ,MAAM,MAAM;AAAA,MAClB;AACE,eAAO,KAAK,UAAU;AAAA,MACxB;AACE,eAAO,KAAK,WAAW;AAAA,MACzB;AACE,aAAK,QAAQ;AACb,eAAO,EAAE,MAAM,QAAQ,OAAO,MAAM,OAAO,MAAM,MAAM,KAAK;AAAA,MAC9D;AACE,aAAK,QAAQ;AACb,eAAO,EAAE,MAAM,UAAU,OAAO,MAAM,OAAO,MAAM,MAAM,KAAK;AAAA,MAChE;AACE,aAAK,QAAQ;AACb,eAAO,EAAE,MAAM,UAAU,OAAO,MAAM,OAAO,MAAM,MAAM,KAAK;AAAA,MAChE;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EAEQ,eAAe,MAAuB;AAC5C,QAAI,aAAa,MAAM;AACrB,aAAO,KAAK;AAAA,IACd;AACA,WAAO,KAAK;AAAA,EACd;AAAA,EAEQ,cAAc,MAAsC;AAC1D,UAAM,YAAY,KAAK,KAAK,YAAY;AAExC,QAAI,CAAC,iBAAiB,SAAS,GAAG;AAChC,aAAO;AAAA,IACT;AAGA,UAAM,WAAW,KAAK,SAAS,KAAK,CAAC,MAAoB,UAAU,KAAK,EAAE,SAAS,MAAM;AAEzF,QAAI,aAAa,QAAW;AAC1B,aAAO;AAAA,IACT;AAEA,UAAM,UAA6C;AAAA,MACjD,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAEA,UAAM,OAAO,QAAQ,SAAS;AAC9B,QAAI,SAAS,QAAW;AACtB,aAAO;AAAA,IACT;AAEA,UAAM,SAAoB;AAAA,MACxB,MAAM,SAAS;AAAA,MACf;AAAA,MACA,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,IAChB;AAEA,QAAI,cAAc,aAAa,cAAc,YAAY,cAAc,UAAU;AAC/E,aAAO,YAAY,KAAK,wBAAwB,MAAM,SAAS,KAAK;AAAA,IACtE;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,wBAAwB,MAAe,MAAsB;AAEnE,UAAM,YAAY,KAAK,SAAS,KAAK,CAAC,MAAqB,UAAU,KAAK,EAAE,SAAS,OAAO;AAE5F,QAAI,cAAc,QAAW;AAC3B,aAAO,WAAW,IAAI;AAAA,IACxB;AAEA,UAAM,OAAO,UAAU,SACpB,OAAO,CAAC,MAAoB,UAAU,KAAK,EAAE,SAAS,MAAM,EAC5D,IAAI,CAAC,MAAM,EAAE,KAAK,EAClB,KAAK,GAAG;AAEX,WAAO,WAAW,IAAI,KAAK,IAAI;AAAA,EACjC;AAAA,EAEQ,cAAc,MAAuC;AAC3D,QAAI,KAAK,KAAK,YAAY,MAAM,eAAe;AAC7C,aAAO;AAAA,IACT;AAGA,UAAM,WAAW,KAAK,SAAS,KAAK,CAAC,MAAoB,UAAU,KAAK,EAAE,SAAS,QAAQ;AAE3F,QAAI,aAAa,QAAW;AAC1B,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,MACL,QAAQ,SAAS;AAAA,MACjB,YAAY,CAAC;AAAA,MACb,QAAQ;AAAA,IACV;AAAA,EACF;AAAA,EAEQ,eAAe,MAAmC;AACxD,UAAM,WAAW,KAAK,SAAS,KAAK,CAAC,MAAoB,UAAU,KAAK,EAAE,SAAS,MAAM;AACzF,WAAO,UAAU;AAAA,EACnB;AAAA,EAEQ,aAAa,MAAe,QAAgB,OAAwB;AAC1E,QAAI,UAAU,MAAM;AAElB,YAAM,YAAY,KAAK,KAAK,YAAY;AAGxC,UAAI,KAAK,SAAS,MAAM,CAAC,cAAc,SAAS,GAAG;AACjD,cAAM,KAAK;AAAA,UACT;AAAA,UACA,QAAQ,KAAK;AAAA,UACb,MAAM,KAAK;AAAA,QACb,CAAC;AAAA,MACH;AAGA,iBAAW,SAAS,KAAK,UAAU;AACjC,aAAK,aAAa,OAAO,QAAQ,KAAK;AAAA,MACxC;AAAA,IACF,WAAW,UAAU,QAAQ,KAAK,SAAS,SAAS;AAElD,iBAAW,SAAS,KAAK,UAAU;AACjC,aAAK,aAAa,OAAO,QAAQ,KAAK;AAAA,MACxC;AAAA,IACF;AAAA,EAEF;AACF;;;ACxVO,IAAM,aAAN,MAA4C;AAAA,EACxC,aAAa;AAAA,EACb,aAAa,CAAC,QAAQ,MAAM;AAAA,EAC5B,cAAc;AAAA,EAEN,SAAS,IAAI,UAAU;AAAA;AAAA;AAAA;AAAA,EAKxC,MAAM,SAAiB,WAA+B;AACpD,UAAM,SAAS,KAAK,OAAO,MAAM,OAAO;AAExC,WAAO,OAAO,QAAQ,IAAI,CAAC,WAAW;AACpC,YAAM,OAAiB;AAAA,QACrB,MAAM,KAAK,wBAAwB,OAAO,IAAI;AAAA,QAC9C,MAAM,OAAO;AAAA,QACb,UAAU;AAAA;AAAA,QACV,WAAW,OAAO;AAAA,QAClB,SAAS,OAAO;AAAA,MAClB;AAEA,UAAI,OAAO,cAAc,QAAW;AAClC,aAAK,YAAY,OAAO;AAAA,MAC1B;AAEA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,SAAiB,WAAiC;AAC/D,UAAM,SAAS,KAAK,OAAO,MAAM,OAAO;AACxC,WAAO,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAiB,WAAkC;AACvD,UAAM,SAAS,KAAK,OAAO,MAAM,OAAO;AACxC,UAAM,QAAQ,QAAQ,MAAM,IAAI;AAEhC,WAAO,OAAO,MACX,OAAO,CAAC,SAAS,KAAK,SAAS,EAAE,EACjC,IAAI,CAAC,SAAS;AAEb,YAAM,aAAa,MAAM,MAAM,KAAK,YAAY,GAAG,KAAK,OAAO;AAC/D,YAAM,eAAe,WAAW,KAAK,IAAI;AAGzC,YAAM,SAAS,OAAO,QAAQ;AAAA,QAC5B,CAAC,MAAM,EAAE,cAAc,KAAK,aAAa,EAAE,YAAY,KAAK;AAAA,MAC9D;AAEA,YAAM,QAAqB;AAAA,QACzB,SAAS;AAAA,QACT,WAAW,KAAK;AAAA,QAChB,SAAS,KAAK;AAAA,MAChB;AAEA,UAAI,WAAW,QAAW;AACxB,cAAM,aAAa,OAAO;AAC1B,cAAM,aAAa,OAAO;AAAA,MAC5B;AAEA,aAAO;AAAA,IACT,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB,SAAiB,UAA+B;AACvE,UAAM,SAAS,KAAK,OAAO,MAAM,OAAO;AAExC,WAAO,OAAO,MAAM,IAAI,CAAC,UAAU;AAAA,MACjC,MAAM,GAAG,QAAQ,IAAI,KAAK,MAAM;AAAA,MAChC,IAAI,GAAG,QAAQ,IAAI,KAAK,MAAM;AAAA,MAC9B,MAAM;AAAA,MACN,YAAY;AAAA;AAAA,IACd,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKQ,wBAAwB,MAAgC;AAC9D,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AAAA,EACF;AACF;;;ACxHA,SAAS,KAAAA,UAAS;;;ACAlB,SAAS,SAAS;AAgBX,IAAM,mBAAmB,EAAE,OAAO;AAAA,EACvC,OAAO,EAAE,OAAO,EAAE,IAAI,GAAG,kCAAkC;AAAA,EAC3D,QAAQ,EACL,KAAK;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC,EACA,SAAS;AAAA,EACZ,MAAM,EAAE,KAAK,CAAC,UAAU,OAAO,QAAQ,CAAC,EAAE,QAAQ,QAAQ;AAAA,EAC1D,QAAQ,EAAE,KAAK,CAAC,WAAW,cAAc,MAAM,CAAC,EAAE,QAAQ,SAAS;AAAA,EACnE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,QAAQ,EAAE;AAAA,EAC7C,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACrC,WAAW,EACR,OAAO,EACP,IAAI,GAAG,mCAAmC,EAC1C,IAAI,GAAG,mCAAmC,EAC1C,SAAS;AAAA,EACZ,cAAc,EACX,OAAO,EACP,IAAI,GAAG,sCAAsC,EAC7C,IAAI,GAAG,sCAAsC,EAC7C,SAAS;AACd,CAAC;AAOM,IAAM,2BAA2B,EAAE,OAAO;AAAA,EAC/C,UAAU,EAAE,OAAO,EAAE,IAAI,GAAG,sCAAsC;AACpE,CAAC;AAWM,IAAM,uBAAuB,EAAE,OAAO;AAAA,EAC3C,MAAM,EAAE,KAAK,CAAC,QAAQ,QAAQ,KAAK,CAAC,EAAE,SAAS;AACjD,CAAC;AAOM,IAAM,yBAAyB,EAAE,OAAO;AAAA,EAC7C,OAAO,EAAE,OAAO,EAAE,IAAI,GAAG,6CAA6C;AACxE,CAAC;AAOM,IAAM,wBAAwB,EAAE,OAAO;AAAA,EAC5C,MAAM,EAAE,OAAO,EAAE,IAAI,GAAG,uCAAuC;AAAA,EAC/D,MAAM,EAAE,KAAK,CAAC,QAAQ,MAAM,CAAC;AAAA,EAC7B,QAAQ,EAAE,OAAO,EAAE,IAAI,GAAG,+CAA+C;AAAA,EACzE,QAAQ,EAAE,OAAO,EAAE,SAAS;AAAA,EAC5B,aAAa,EAAE,OAAO,EAAE,SAAS;AACnC,CAAC;AAOM,IAAM,uBAAuB,EAAE,OAAO;AAAA,EAC3C,OAAO,EAAE,OAAO,EAAE,IAAI,GAAG,6CAA6C;AACxE,CAAC;AAOM,IAAM,wBAAwB,EAAE,OAAO;AAAA,EAC5C,OAAO,EAAE,OAAO,EAAE,IAAI,GAAG,6CAA6C;AACxE,CAAC;AAWM,IAAM,2BAA2B,EAAE,OAAO;AAAA,EAC/C,OAAO,EAAE,OAAO,EAAE,IAAI,GAAG,mCAAmC;AAC9D,CAAC;AAOM,IAAM,qBAAqB,EAAE,OAAO;AAAA,EACzC,YAAY,EAAE,QAAQ,EAAE,SAAS;AAAA,EACjC,QAAQ,EAAE,KAAK,CAAC,WAAW,WAAW,aAAa,UAAU,WAAW,CAAC,EAAE,SAAS;AACtF,CAAC;AAOM,IAAM,sBAAsB,EAAE,OAAO;AAAA,EAC1C,OAAO,EAAE,OAAO,EAAE,IAAI,GAAG,mCAAmC;AAC9D,CAAC;AAcM,IAAM,oBAAoB,EAAE,OAAO;AAAA,EACxC,SAAS,EAAE,OAAO,EAAE,IAAI,GAAG,0BAA0B;AAAA,EACrD,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,EAAE,QAAQ,CAAC,EAAE,SAAS;AACnD,CAAC;;;AC1IM,IAAM,uBAAwD,CACnE,MACA,YAC0B;AAE1B,QAAM,YAAY,yBAAyB,MAAM,IAAI;AAErD,QAAM,EAAE,QAAQ,IAAI;AAEpB,QAAM,aAAa,IAAI,WAAW,QAAQ,OAAO;AACjD,QAAM,MAAM,WAAW,OAAO,UAAU,KAAK;AAE7C,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MAAM,kBAAkB,UAAU,KAAK,EAAE;AAAA,EACrD;AAEA,SAAO,QAAQ,QAAQ;AAAA,IACrB,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK,UAAU,KAAK,MAAM,CAAC;AAAA,MACnC;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAOO,IAAM,iBAA4C,CAAC,MAAM,YAAmC;AAEjG,QAAM,YAAY,mBAAmB,MAAM,IAAI;AAE/C,QAAM,EAAE,QAAQ,IAAI;AAEpB,QAAM,aAAa,IAAI,WAAW,QAAQ,OAAO;AAEjD,MAAI;AACJ,MAAI,UAAU,eAAe,MAAM;AACjC,WAAO,WAAW,eAAe;AAAA,EACnC,WAAW,UAAU,WAAW,QAAW;AACzC,WAAO,WAAW,SAAS,UAAU,MAAM;AAAA,EAC7C,OAAO;AACL,WAAO,WAAW,SAAS;AAAA,EAC7B;AAEA,SAAO,QAAQ,QAAQ;AAAA,IACrB,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK,UAAU,EAAE,KAAK,GAAG,MAAM,CAAC;AAAA,MACxC;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAQO,IAAM,kBAA8C,CACzD,MACA,YAC0B;AAE1B,QAAM,YAAY,oBAAoB,MAAM,IAAI;AAEhD,QAAM,EAAE,QAAQ,IAAI;AAEpB,QAAM,aAAa,IAAI,WAAW,QAAQ,OAAO;AACjD,QAAM,SAAS,WAAW,UAAU,UAAU,KAAK;AAEnD,MAAI,CAAC,OAAO,SAAS;AACnB,UAAM,IAAI,MAAM,OAAO,MAAM,OAAO;AAAA,EACtC;AAEA,QAAM,MAAM,WAAW,OAAO,UAAU,KAAK;AAE7C,SAAO,QAAQ,QAAQ;AAAA,IACrB,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK;AAAA,UACT;AAAA,YACE,SAAS;AAAA,YACT;AAAA,YACA,SAAS;AAAA,UACX;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;;;AFhGO,IAAM,cAAmC;AAAA,EAC9C;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYC,GAAE,OAAO;AAAA,MACnB,YAAYA,GAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,uBAAuB;AAAA,MACnE,QAAQA,GACL,KAAK,CAAC,WAAW,WAAW,aAAa,UAAU,WAAW,CAAC,EAC/D,SAAS,EACT,SAAS,sBAAsB;AAAA,IACpC,CAAC;AAAA,IACD,SAAS,CAAC,MAAM,YAAY,eAAe,MAAiC,OAAO;AAAA,EACrF;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYA,GAAE,OAAO;AAAA,MACnB,OAAOA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,iBAAiB;AAAA,IACrD,CAAC;AAAA,IACD,SAAS,CAAC,MAAM,YACd,qBAAqB,MAAuC,OAAO;AAAA,EACvE;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYA,GAAE,OAAO;AAAA,MACnB,OAAOA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,kBAAkB;AAAA,IACtD,CAAC;AAAA,IACD,SAAS,CAAC,MAAM,YAAY,gBAAgB,MAAkC,OAAO;AAAA,EACvF;AACF;;;AG9CA,SAAS,KAAAC,UAAS;;;ACAlB,SAAS,KAAAC,UAAS;AAmClB,IAAM,kBAAN,MAAsB;AAAA,EACH,WAAW,oBAAI,IAA+B;AAAA;AAAA;AAAA;AAAA,EAK/D,SAAS,SAAkC;AACzC,QAAI,KAAK,SAAS,IAAI,QAAQ,IAAI,GAAG;AACnC,YAAM,IAAI,MAAM,+BAA+B,QAAQ,IAAI,EAAE;AAAA,IAC/D;AACA,SAAK,SAAS,IAAI,QAAQ,MAAM,OAAO;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,UAAqC;AAC/C,eAAW,WAAW,UAAU;AAC9B,WAAK,SAAS,OAAO;AAAA,IACvB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,MAA6C;AAC/C,WAAO,KAAK,SAAS,IAAI,IAAI;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,MAAuB;AACzB,WAAO,KAAK,SAAS,IAAI,IAAI;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKA,MAA2B;AACzB,WAAO,MAAM,KAAK,KAAK,SAAS,OAAO,CAAC;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,UAA4C;AAC1C,UAAM,SAAS,oBAAI,IAAiC;AAEpD,eAAW,OAAO,KAAK,SAAS,OAAO,GAAG;AACxC,YAAM,aAAa,IAAI,KAAK,QAAQ,GAAG;AACvC,YAAM,WAAW,eAAe,KAAK,YAAY,IAAI,KAAK,MAAM,GAAG,UAAU;AAE7E,YAAM,WAAW,OAAO,IAAI,QAAQ,KAAK,CAAC;AAC1C,eAAS,KAAK,GAAG;AACjB,aAAO,IAAI,UAAU,QAAQ;AAAA,IAC/B;AAEA,WAAO;AAAA,EACT;AACF;AAGO,IAAM,kBAAkB,IAAI,gBAAgB;AAUnD,eAAsB,eACpB,aACA,MACA,SACuB;AACvB,QAAM,UAAU,gBAAgB,IAAI,WAAW;AAE/C,MAAI,YAAY,QAAW;AACzB,UAAM,IAAI;AAAA,MACR,oBAAoB,WAAW;AAAA,IACjC;AAAA,EACF;AAIA,QAAM,gBACJ,QAAQ,eAAe,SAClB,QAAQ,WAAW,MAAM,IAAI,IAC9B;AAGN,SAAO,QAAQ,QAAQ,eAAe,OAAO;AAC/C;AAKO,SAAS,aAAa,aAA8B;AACzD,MAAI,gBAAgB,QAAW;AAC7B,UAAM,UAAU,gBAAgB,IAAI,WAAW;AAC/C,QAAI,YAAY,QAAW;AACzB,YAAM,IAAI,MAAM,oBAAoB,WAAW,EAAE;AAAA,IACnD;AAEA,UAAMC,SAAQ,CAAC,YAAY,QAAQ,IAAI,IAAI,gBAAgB,QAAQ,WAAW,IAAI,EAAE;AAEpF,QAAI,QAAQ,eAAe,QAAW;AACpC,MAAAA,OAAM,KAAK,YAAY;AAEvB,YAAM,SAAS,QAAQ;AACvB,UAAI,kBAAkBD,GAAE,WAAW;AAEjC,cAAM,QAAQ,OAAO;AACrB,mBAAW,CAAC,KAAK,WAAW,KAAK,OAAO,QAAQ,KAAK,GAAG;AACtD,gBAAM,aAAa,YAAY,UAAU,MAAS,EAAE;AACpD,gBAAM,OAAO,YAAY,eAAe;AACxC,UAAAC,OAAM,KAAK,KAAK,GAAG,GAAG,aAAa,gBAAgB,EAAE,KAAK,IAAI,EAAE;AAAA,QAClE;AAAA,MACF;AAAA,IACF,OAAO;AACL,MAAAA,OAAM,KAAK,iBAAiB;AAAA,IAC9B;AAEA,WAAOA,OAAM,KAAK,IAAI;AAAA,EACxB;AAGA,QAAM,SAAS,gBAAgB,QAAQ;AACvC,QAAM,QAAQ,CAAC,uBAAuB,EAAE;AAExC,aAAW,CAAC,UAAU,QAAQ,KAAK,QAAQ;AACzC,UAAM,KAAK,GAAG,QAAQ,GAAG;AACzB,eAAW,OAAO,UAAU;AAC1B,YAAM,KAAK,KAAK,IAAI,IAAI,MAAM,IAAI,WAAW,EAAE;AAAA,IACjD;AACA,UAAM,KAAK,EAAE;AAAA,EACf;AAEA,QAAM,KAAK,mEAAmE;AAE9E,SAAO,MAAM,KAAK,IAAI;AACxB;;;ADxKO,IAAM,eAAoC;AAAA,EAC/C;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,SAAS,MAA6B;AACpC,YAAM,WAAW,gBAAgB,IAAI;AACrC,YAAM,cAAc,SAAS,IAAI,CAAC,SAAS;AAAA,QACzC,MAAM,IAAI;AAAA,QACV,aAAa,IAAI;AAAA,MACnB,EAAE;AAEF,aAAO,QAAQ,QAAQ;AAAA,QACrB,SAAS;AAAA,UACP;AAAA,YACE,MAAM;AAAA,YACN,MAAM,KAAK,UAAU,EAAE,UAAU,YAAY,GAAG,MAAM,CAAC;AAAA,UACzD;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYC,GAAE,OAAO;AAAA,MACnB,SAASA,GAAE,OAAO,EAAE,SAAS,EAAE,SAAS,8BAA8B;AAAA,IACxE,CAAC;AAAA,IACD,SAAS,CAAC,SAAyD;AAEjE,YAAM,cAAc,KAAK,SAAS;AAClC,YAAM,WAAW,aAAa,WAAW;AAEzC,aAAO,QAAQ,QAAQ;AAAA,QACrB,SAAS;AAAA,UACP;AAAA,YACE,MAAM;AAAA,YACN,MAAM;AAAA,UACR;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF;;;AErDA,SAAS,KAAAC,UAAS;;;ACAlB,SAAS,UAAU;AACnB,SAAS,YAAY;;;ACDrB,SAAS,aAAa;AACtB,OAAO,UAAU;AACjB,SAAS,qBAAqB;AAUvB,SAAS,sBAAsB,OAAe,SAAuB;AAI1E,QAAMC,aAAY,KAAK,QAAQ,cAAc,YAAY,GAAG,CAAC;AAG7D,QAAM,eAAeA,WAAU,SAAS,QAAQ;AAEhD,MAAI;AACJ,MAAI;AAEJ,MAAI,cAAc;AAEhB,UAAM,eAAe,KAAK,KAAKA,YAAW,0BAA0B;AACpE,cAAU,QAAQ;AAClB,WAAO,CAAC,cAAc,KAAK;AAAA,EAC7B,OAAO;AAEL,UAAM,eAAe,KAAK,KAAKA,YAAW,0BAA0B;AACpE,cAAU;AACV,WAAO,CAAC,OAAO,cAAc,KAAK;AAAA,EACpC;AAGA,QAAM,SAAS,MAAM,SAAS,MAAM;AAAA,IAClC,UAAU;AAAA;AAAA,IACV,OAAO;AAAA;AAAA,IACP,KAAK;AAAA,MACH,GAAG,QAAQ;AAAA;AAAA,MACX,iBAAiB;AAAA;AAAA,IACnB;AAAA,EACF,CAAC;AAGD,SAAO,MAAM;AACf;;;ADtBO,IAAM,mBAAgD,OAC3D,MACA,YAC0B;AAE1B,QAAM,YAAY,qBAAqB,MAAM,IAAI;AAEjD,QAAM,EAAE,SAAS,IAAI;AAErB,QAAM,SAAS,MAAM,SAAS,MAAM,KAAK;AACzC,QAAM,WACJ,UAAU,SAAS,SAAY,OAAO,OAAO,CAAC,MAAM,EAAE,SAAS,UAAU,IAAI,IAAI;AAEnF,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK;AAAA,UACT;AAAA,YACE,QAAQ,SAAS,IAAI,CAAC,OAAO;AAAA,cAC3B,IAAI,EAAE;AAAA,cACN,MAAM,EAAE;AAAA,cACR,MAAM,EAAE;AAAA,cACR,MAAM,UAAU,IAAI,EAAE,OAAO;AAAA,cAC7B,KAAK,SAAS,KAAK,EAAE,QAAQ,SAAY,EAAE,MAAM;AAAA,cACjD,aAAa,EAAE;AAAA,cACf,WAAW,EAAE,UAAU,YAAY;AAAA,YACrC,EAAE;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAOO,IAAM,qBAAoD,OAC/D,MACA,YAC0B;AAE1B,QAAM,YAAY,uBAAuB,MAAM,IAAI;AAEnD,QAAM,EAAE,SAAS,IAAI;AAErB,QAAM,QAAQ,MAAM,SAAS,MAAM,cAAc,cAAc,UAAU,KAAK,CAAC;AAE/E,MAAI,UAAU,QAAW;AACvB,UAAM,IAAI,MAAM,oBAAoB,UAAU,KAAK,EAAE;AAAA,EACvD;AAEA,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK;AAAA,UACT;AAAA,YACE,IAAI,MAAM;AAAA,YACV,MAAM,MAAM;AAAA,YACZ,MAAM,MAAM;AAAA,YACZ,MAAM,UAAU,QAAQ,MAAM,OAAO;AAAA,YACrC,KAAK,SAAS,SAAS,MAAM,QAAQ,SAAY,MAAM,MAAM;AAAA,YAC7D,QAAQ,YAAY,QAAQ,MAAM,SAAS;AAAA,YAC3C,aAAa,MAAM;AAAA,YACnB,QAAQ,MAAM;AAAA,YACd,WAAW,MAAM,UAAU,YAAY;AAAA,YACvC,WAAW,MAAM,UAAU,YAAY;AAAA,UACzC;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAQO,IAAM,oBAAkD,OAC7D,MACA,YAC0B;AAE1B,QAAM,YAAY,sBAAsB,MAAM,IAAI;AAElD,QAAM,EAAE,UAAU,QAAQ,IAAI;AAG9B,QAAM,QACJ,UAAU,OAAO,WAAW,SAAS,KACrC,UAAU,OAAO,WAAW,UAAU,KACtC,UAAU,OAAO,WAAW,MAAM;AAEpC,QAAM,SAAS,MAAM,SAAS,MAAM,OAAO;AAAA,IACzC,MAAM,UAAU;AAAA,IAChB,MAAM,UAAU;AAAA,IAChB,GAAI,QAAQ,EAAE,KAAK,UAAU,OAAO,IAAI,EAAE,MAAM,UAAU,OAAO;AAAA,IACjE,GAAI,UAAU,WAAW,SAAY,EAAE,QAAQ,UAAU,OAAO,IAAI,CAAC;AAAA,IACrE,GAAI,UAAU,gBAAgB,SAAY,EAAE,aAAa,UAAU,YAAY,IAAI,CAAC;AAAA,EACtF,CAAC;AAED,MAAI,CAAC,OAAO,SAAS;AACnB,UAAM,IAAI,MAAM,OAAO,MAAM,OAAO;AAAA,EACtC;AAGA,QAAM,aAAa,IAAI,WAAW,QAAQ,OAAO;AACjD,QAAM,aAAsC;AAAA,IAC1C,WAAW,OAAO,KAAK;AAAA,IACvB,SAAS,OAAO,KAAK;AAAA,EACvB;AACA,MAAI,OAAO;AACT,eAAW,KAAK,IAAI,UAAU;AAAA,EAChC;AACA,MAAI,UAAU,OAAO,QAAQ,OAAO,KAAK,MAAM;AAC7C,eAAW,MAAM,IAAI,OAAO,KAAK;AAAA,EACnC;AACA,QAAM,MAAM,WAAW,UAAU;AAAA,IAC/B,MAAM,UAAU,SAAS,UAAU,QAAQ,UAAU;AAAA,IACrD,SAAS;AAAA,IACT,SAAS,YAAY,OAAO,KAAK,IAAI;AAAA,EACvC,CAAC;AAGD,wBAAsB,IAAI,IAAI,QAAQ,WAAW,EAAE;AAEnD,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK;AAAA,UACT;AAAA,YACE,OAAO;AAAA,cACL,IAAI,OAAO,KAAK;AAAA,cAChB,MAAM,OAAO,KAAK;AAAA,cAClB,MAAM,OAAO,KAAK;AAAA,cAClB,MAAM,UAAU,OAAO,OAAO,OAAO,KAAK,OAAO;AAAA,YACnD;AAAA,YACA,KAAK;AAAA,cACH,IAAI,IAAI;AAAA,cACR,QAAQ,IAAI;AAAA,cACZ,SAAS,IAAI;AAAA,YACf;AAAA,YACA,SAAS,0DAA0D,IAAI,EAAE;AAAA,UAC3E;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAQO,IAAM,mBAAgD,OAC3D,MACA,YAC0B;AAE1B,QAAM,YAAY,qBAAqB,MAAM,IAAI;AAEjD,QAAM,EAAE,UAAU,QAAQ,IAAI;AAE9B,QAAM,QAAQ,MAAM,SAAS,MAAM,cAAc,cAAc,UAAU,KAAK,CAAC;AAE/E,MAAI,UAAU,QAAW;AACvB,UAAM,IAAI,MAAM,oBAAoB,UAAU,KAAK,EAAE;AAAA,EACvD;AAGA,QAAM,aAAa,IAAI,WAAW,QAAQ,OAAO;AACjD,QAAM,aAAsC;AAAA,IAC1C,WAAW,MAAM;AAAA,IACjB,SAAS,MAAM;AAAA,EACjB;AACA,MAAI,UAAU,SAAS,MAAM,MAAM;AACjC,eAAW,MAAM,IAAI,MAAM;AAAA,EAC7B;AACA,QAAM,MAAM,WAAW,UAAU;AAAA,IAC/B,MAAM;AAAA,IACN,SAAS;AAAA,IACT,SAAS,eAAe,MAAM,IAAI;AAAA,EACpC,CAAC;AAGD,wBAAsB,IAAI,IAAI,QAAQ,WAAW,EAAE;AAEnD,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK;AAAA,UACT;AAAA,YACE,OAAO;AAAA,cACL,IAAI,MAAM;AAAA,cACV,MAAM,MAAM;AAAA,YACd;AAAA,YACA,KAAK;AAAA,cACH,IAAI,IAAI;AAAA,cACR,QAAQ,IAAI;AAAA,cACZ,SAAS,IAAI;AAAA,YACf;AAAA,YACA,SAAS,2CAA2C,IAAI,EAAE;AAAA,UAC5D;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAUO,IAAM,oBAAkD,OAC7D,MACA,YAC0B;AAE1B,QAAM,YAAY,sBAAsB,MAAM,IAAI;AAElD,QAAM,EAAE,UAAU,QAAQ,IAAI;AAE9B,QAAM,QAAQ,MAAM,SAAS,MAAM,cAAc,cAAc,UAAU,KAAK,CAAC;AAE/E,MAAI,UAAU,QAAW;AACvB,UAAM,IAAI,MAAM,oBAAoB,UAAU,KAAK,EAAE;AAAA,EACvD;AAGA,QAAM,SAAS,MAAM,YAAY,MAAM,EAAE;AAGzC,QAAM,SAAS,UAAU,YAAY,MAAM,EAAE;AAG7C,MAAI,MAAM,SAAS,UAAU,SAAS,SAAS,MAAM,QAAQ,QAAW;AACtE,QAAI,QAAQ,YAAY,QAAW;AACjC,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AACA,UAAM,WAAW,KAAK,QAAQ,SAAS,SAAS,MAAM,EAAE;AACxD,UAAM,GAAG,UAAU,EAAE,WAAW,MAAM,OAAO,KAAK,CAAC;AAAA,EACrD;AAGA,QAAM,SAAS,MAAM,SAAS,MAAM,OAAO,MAAM,EAAE;AACnD,MAAI,CAAC,OAAO,SAAS;AACnB,UAAM,IAAI,MAAM,OAAO,MAAM,OAAO;AAAA,EACtC;AAEA,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK;AAAA,UACT;AAAA,YACE,SAAS;AAAA,YACT,OAAO;AAAA,cACL,IAAI,MAAM;AAAA,cACV,MAAM,MAAM;AAAA,cACZ,MAAM,MAAM;AAAA,YACd;AAAA,YACA,SAAS,+BAA+B,MAAM,IAAI;AAAA,UACpD;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;ADjSO,IAAM,gBAAqC;AAAA,EAChD;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYC,GAAE,OAAO;AAAA,MACnB,MAAMA,GAAE,KAAK,CAAC,QAAQ,QAAQ,KAAK,CAAC,EAAE,SAAS,EAAE,SAAS,sBAAsB;AAAA,IAClF,CAAC;AAAA,IACD,SAAS,CAAC,MAAM,YAAY,iBAAiB,MAAmC,OAAO;AAAA,EACzF;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYA,GAAE,OAAO;AAAA,MACnB,OAAOA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,kBAAkB;AAAA,IACtD,CAAC;AAAA,IACD,SAAS,CAAC,MAAM,YAAY,mBAAmB,MAAqC,OAAO;AAAA,EAC7F;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYA,GAAE,OAAO;AAAA,MACnB,MAAMA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,YAAY;AAAA,MAC7C,MAAMA,GAAE,KAAK,CAAC,QAAQ,MAAM,CAAC,EAAE,SAAS,YAAY;AAAA,MACpD,QAAQA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,uBAAuB;AAAA,MAC1D,QAAQA,GAAE,OAAO,EAAE,SAAS,EAAE,SAAS,4BAA4B;AAAA,MACnE,aAAaA,GAAE,OAAO,EAAE,SAAS,EAAE,SAAS,mBAAmB;AAAA,IACjE,CAAC;AAAA,IACD,SAAS,CAAC,MAAM,YAAY,kBAAkB,MAAoC,OAAO;AAAA,EAC3F;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYA,GAAE,OAAO;AAAA,MACnB,OAAOA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,kBAAkB;AAAA,IACtD,CAAC;AAAA,IACD,SAAS,CAAC,MAAM,YAAY,iBAAiB,MAAmC,OAAO;AAAA,EACzF;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYA,GAAE,OAAO;AAAA,MACnB,OAAOA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,kBAAkB;AAAA,IACtD,CAAC;AAAA,IACD,SAAS,CAAC,MAAM,YAAY,kBAAkB,MAAoC,OAAO;AAAA,EAC3F;AACF;;;AGzEA,SAAS,KAAAC,UAAS;;;ACAlB,SAAS,UAAU,WAAW,OAAO,cAAc;AACnD,SAAS,SAAS,SAAS,YAAY,QAAAC,aAAY;;;ACDnD,SAAS,KAAAC,UAAS;AAiBlB,IAAM,4BAA4BA,GAAE,OAAO;AAAA,EACzC,MAAMA,GAAE,OAAO,EAAE,IAAI,GAAG,wBAAwB;AAAA,EAChD,aAAaA,GAAE,OAAO,EAAE,SAAS;AAAA,EACjC,MAAMA,GAAE,MAAMA,GAAE,OAAO,CAAC,EAAE,SAAS;AACrC,CAAC;AAUM,IAAM,4BAA4B,0BAA0B,OAAO;AAAA,EACxE,MAAMA,GAAE,QAAQ,MAAM;AAAA,EACtB,MAAMA,GAAE,OAAO,EAAE,IAAI,GAAG,kCAAkC;AAC5D,CAAC;AAYM,IAAM,4BAA4B,0BAA0B,OAAO;AAAA,EACxE,MAAMA,GAAE,QAAQ,MAAM;AAAA,EACtB,KAAKA,GAAE,IAAI,uCAAuC;AAAA,EAClD,QAAQA,GAAE,OAAO,EAAE,SAAS;AAAA,EAC5B,OAAOA,GAAE,OAAO,EAAE,IAAI,EAAE,SAAS,kCAAkC,EAAE,SAAS;AAChF,CAAC;AAYM,IAAM,2BAA2B,0BAA0B,OAAO;AAAA,EACvE,MAAMA,GAAE,QAAQ,KAAK;AAAA,EACrB,KAAKA,GAAE,IAAI,sCAAsC;AAAA,EACjD,OAAOA,GAAE,OAAO,EAAE,IAAI,EAAE,IAAI,GAAG,4BAA4B,EAAE,QAAQ,CAAC;AAAA,EACtE,UAAUA,GAAE,OAAO,EAAE,IAAI,EAAE,SAAS,qCAAqC,EAAE,SAAS;AAAA,EACpF,mBAAmBA,GAAE,OAAO,EAAE,SAAS;AAAA,EACvC,qBAAqBA,GAAE,OAAO,EAAE,SAAS;AAC3C,CAAC;AAYM,IAAM,wBAAwBA,GAAE,mBAAmB,QAAQ;AAAA,EAChE;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAYM,IAAM,+BAA+BA,GAAE,OAAO;AAAA,EACnD,SAASA,GAAE,QAAQ,CAAC;AAAA,EACpB,QAAQA,GAAE,MAAM,qBAAqB;AACvC,CAAC;AAQM,SAAS,sBAAsB,KAAkD;AACtF,SAAO,IAAI,SAAS;AACtB;AAEO,SAAS,sBAAsB,KAAkD;AACtF,SAAO,IAAI,SAAS;AACtB;AAEO,SAAS,qBAAqB,KAAiD;AACpF,SAAO,IAAI,SAAS;AACtB;AAMO,IAAM,mCAA2D;AAAA,EACtE,SAAS;AAAA,EACT,QAAQ,CAAC;AACX;;;ADpHA,eAAe,WAAWC,OAAgC;AACxD,MAAI;AACF,UAAM,OAAOA,KAAI;AACjB,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAYO,IAAM,yBAAN,MAA6B;AAAA,EACjB;AAAA,EACA;AAAA,EACT,SAAwC;AAAA,EAEhD,YAAY,aAAsB;AAChC,SAAK,cAAc,eAAe,mBAAmB,QAAQ;AAC7D,SAAK,aAAaC,MAAK,KAAK,aAAa,6CAA6C;AAAA,EACxF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OAAwC;AAC5C,QAAI,KAAK,WAAW,MAAM;AACxB,aAAO,KAAK;AAAA,IACd;AAEA,UAAM,SAAS,MAAM,WAAW,KAAK,UAAU;AAC/C,QAAI,CAAC,QAAQ;AAEX,WAAK,SAAS;AAAA,QACZ,GAAG;AAAA,QACH,QAAQ,CAAC,GAAG,iCAAiC,MAAM;AAAA,MACrD;AACA,aAAO,KAAK;AAAA,IACd;AAEA,UAAM,UAAU,MAAM,SAAS,KAAK,YAAY,OAAO;AACvD,QAAI;AACJ,QAAI;AACF,eAAS,KAAK,MAAM,OAAO;AAAA,IAC7B,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,wCAAwC,KAAK,UAAU,KACrD,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CACvD;AAAA,MACF;AAAA,IACF;AAEA,UAAM,SAAS,6BAA6B,UAAU,MAAM;AAC5D,QAAI,CAAC,OAAO,SAAS;AACnB,YAAM,IAAI,MAAM,gCAAgC,KAAK,UAAU,KAAK,OAAO,MAAM,OAAO,EAAE;AAAA,IAC5F;AAEA,SAAK,SAAS,OAAO;AACrB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,QAA+C;AACxD,UAAM,MAAM,QAAQ,KAAK,UAAU,GAAG,EAAE,WAAW,KAAK,CAAC;AACzD,UAAM,UAAU,KAAK,YAAY,KAAK,UAAU,QAAQ,MAAM,CAAC,CAAC;AAChE,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,cAAc,YAA4C;AAC9D,UAAM,SAAS,MAAM,KAAK,KAAK;AAC/B,UAAM,WAAW,OAAO,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS,WAAW,IAAI;AACrE,QAAI,aAAa,QAAW;AAC1B,YAAM,IAAI,MAAM,qBAAqB,WAAW,IAAI,kBAAkB;AAAA,IACxE;AACA,WAAO,OAAO,KAAK,UAAU;AAC7B,UAAM,KAAK,KAAK,MAAM;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,iBAAiB,MAAgC;AACrD,UAAM,SAAS,MAAM,KAAK,KAAK;AAC/B,UAAM,QAAQ,OAAO,OAAO,UAAU,CAAC,MAAM,EAAE,SAAS,IAAI;AAC5D,QAAI,UAAU,IAAI;AAChB,aAAO;AAAA,IACT;AACA,WAAO,OAAO,OAAO,OAAO,CAAC;AAC7B,UAAM,KAAK,KAAK,MAAM;AACtB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,iBACJ,MACA,SACe;AACf,UAAM,SAAS,MAAM,KAAK,KAAK;AAC/B,UAAM,QAAQ,OAAO,OAAO,UAAU,CAAC,MAAM,EAAE,SAAS,IAAI;AAC5D,QAAI,UAAU,IAAI;AAChB,YAAM,IAAI,MAAM,qBAAqB,IAAI,aAAa;AAAA,IACxD;AAIA,UAAM,WAAW,OAAO,OAAO,KAAK;AACpC,QAAI,aAAa,QAAW;AAC1B,YAAM,IAAI,MAAM,qBAAqB,IAAI,wBAAwB,OAAO,KAAK,CAAC,EAAE;AAAA,IAClF;AACA,QAAI,QAAQ,gBAAgB,QAAW;AACrC,eAAS,cAAc,QAAQ;AAAA,IACjC;AACA,QAAI,QAAQ,SAAS,QAAW;AAC9B,eAAS,OAAO,QAAQ;AAAA,IAC1B;AACA,UAAM,KAAK,KAAK,MAAM;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,UAAU,MAAoD;AAClE,UAAM,SAAS,MAAM,KAAK,KAAK;AAC/B,WAAO,OAAO,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS,IAAI;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAmC;AACvC,UAAM,SAAS,MAAM,KAAK,KAAK;AAC/B,WAAO,OAAO,OAAO,SAAS;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,YAAYD,OAAsB;AAChC,QAAI,WAAWA,KAAI,GAAG;AACpB,aAAOA;AAAA,IACT;AACA,WAAO,QAAQ,KAAK,aAAaA,KAAI;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAwB;AACtB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAyB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,aAAmB;AACjB,SAAK,SAAS;AAAA,EAChB;AACF;;;ADvJA,eAAsB,iBACpB,MACA,SACuB;AACvB,QAAM,EAAE,UAAU,QAAQ,IAAI;AAC9B,QAAM,cAAc,QAAQ;AAE5B,MAAI,gBAAgB,QAAW;AAC7B,UAAM,IAAI,MAAM,0CAA0C;AAAA,EAC5D;AAEA,QAAM,aAAa,IAAI,uBAAuB,WAAW;AACzD,QAAM,SAAS,MAAM,WAAW,KAAK;AAErC,QAAM,SAAqB;AAAA,IACzB,SAAS,CAAC;AAAA,IACV,SAAS,CAAC;AAAA,IACV,QAAQ,CAAC;AAAA,IACT,SAAS,CAAC;AAAA,EACZ;AAEA,MAAI,KAAK,WAAW,MAAM;AACxB,WAAO,SAAS;AAChB,WAAO,cAAc,CAAC;AACtB,WAAO,aAAa,CAAC;AAAA,EACvB;AAGA,QAAM,iBAAiB,MAAM,SAAS,MAAM,KAAK;AACjD,QAAM,gBAAgB,IAAI,IAAI,eAAe,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAG/D,aAAW,OAAO,OAAO,QAAQ;AAC/B,QAAI,cAAc,IAAI,IAAI,IAAI,GAAG;AAC/B,aAAO,QAAQ,KAAK,IAAI,IAAI;AAC5B;AAAA,IACF;AAEA,QAAI,KAAK,WAAW,MAAM;AACxB,aAAO,aAAa,KAAK,IAAI,IAAI;AACjC;AAAA,IACF;AAGA,UAAM,eAAe,MAAM,0BAA0B,KAAK,YAAY,UAAU,OAAO;AACvF,QAAI,aAAa,SAAS;AACxB,aAAO,QAAQ,KAAK,IAAI,IAAI;AAAA,IAC9B,OAAO;AACL,aAAO,OAAO,KAAK,EAAE,MAAM,IAAI,MAAM,OAAO,aAAa,MAAM,CAAC;AAAA,IAClE;AAAA,EACF;AAGA,QAAM,eAAe,IAAI,IAAI,OAAO,OAAO,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAC7D,aAAW,SAAS,gBAAgB;AAClC,QAAI,CAAC,aAAa,IAAI,MAAM,IAAI,GAAG;AACjC,aAAO,QAAQ,KAAK,MAAM,IAAI;AAAA,IAChC;AAAA,EACF;AAGA,MAAI,KAAK,UAAU,QAAQ,OAAO,QAAQ,SAAS,GAAG;AACpD,QAAI,KAAK,WAAW,MAAM;AACxB,aAAO,aAAa,CAAC,GAAG,OAAO,OAAO;AAAA,IACxC,OAAO;AACL,aAAO,SAAS,CAAC;AACjB,iBAAW,cAAc,OAAO,SAAS;AACvC,cAAM,QAAQ,MAAM,SAAS,MAAM,UAAU,UAAU;AACvD,YAAI,UAAU,QAAW;AACvB,gBAAM,eAAe,MAAM,SAAS,MAAM,OAAO,MAAM,IAAI,EAAE,oBAAoB,KAAK,CAAC;AACvF,cAAI,aAAa,SAAS;AACxB,mBAAO,OAAO,KAAK,UAAU;AAAA,UAC/B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,MAAI,KAAK,YAAY,QAAQ,OAAO,QAAQ,SAAS,GAAG;AACtD,QAAI,KAAK,WAAW,MAAM;AACxB,aAAO,eAAe,CAAC,GAAG,OAAO,OAAO;AAAA,IAC1C,OAAO;AACL,aAAO,cAAc,CAAC;AACtB,YAAM,UAAU,QAAQ;AACxB,UAAI,YAAY,QAAW;AACzB,cAAM,IAAI,MAAM,oCAAoC;AAAA,MACtD;AACA,YAAM,aAAa,IAAI,WAAW,OAAO;AAEzC,iBAAW,aAAa,OAAO,SAAS;AACtC,cAAM,QAAQ,MAAM,SAAS,MAAM,UAAU,SAAS;AACtD,YAAI,UAAU,QAAW;AACvB,gBAAM,MAAM,WAAW,UAAU;AAAA,YAC/B,MAAM;AAAA,YACN,SAAS,EAAE,SAAS,MAAM,IAAI,WAAW,MAAM,KAAK;AAAA,YACpD,SAAS,eAAe,SAAS;AAAA,UACnC,CAAC;AACD,gCAAsB,IAAI,IAAI,OAAO;AACrC,iBAAO,YAAY,KAAK,EAAE,OAAO,WAAW,OAAO,IAAI,GAAG,CAAC;AAAA,QAC7D;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,KAAK,UAAU,QAAQ,MAAM,CAAC;AAAA,MACtC;AAAA,IACF;AAAA,EACF;AACF;AAKA,eAAe,0BACb,KACA,YACA,UACA,UACgE;AAChE,MAAI;AACF,QAAI,sBAAsB,GAAG,GAAG;AAE9B,YAAM,eAAe,WAAW,YAAY,IAAI,IAAI;AACpD,YAAM,eAAe,MAAM,SAAS,MAAM;AAAA,QACxC;AAAA,UACE,MAAM,IAAI;AAAA,UACV,MAAM;AAAA,UACN,MAAM;AAAA,UACN,aAAa,IAAI;AAAA,UACjB,MAAM,IAAI;AAAA,QACZ;AAAA,QACA,EAAE,oBAAoB,KAAK;AAAA;AAAA,MAC7B;AACA,UAAI,CAAC,aAAa,SAAS;AACzB,eAAO,EAAE,SAAS,OAAO,OAAO,aAAa,MAAM,QAAQ;AAAA,MAC7D;AACA,aAAO,EAAE,SAAS,KAAK;AAAA,IACzB;AAEA,QAAI,sBAAsB,GAAG,GAAG;AAC9B,YAAM,eAAe,MAAM,SAAS,MAAM;AAAA,QACxC;AAAA,UACE,MAAM,IAAI;AAAA,UACV,MAAM;AAAA,UACN,KAAK,IAAI;AAAA,UACT,QAAQ,IAAI;AAAA,UACZ,OAAO,IAAI;AAAA,UACX,aAAa,IAAI;AAAA,UACjB,MAAM,IAAI;AAAA,QACZ;AAAA,QACA,EAAE,oBAAoB,KAAK;AAAA,MAC7B;AACA,UAAI,CAAC,aAAa,SAAS;AACzB,eAAO,EAAE,SAAS,OAAO,OAAO,aAAa,MAAM,QAAQ;AAAA,MAC7D;AACA,aAAO,EAAE,SAAS,KAAK;AAAA,IACzB;AAEA,QAAI,qBAAqB,GAAG,GAAG;AAC7B,YAAM,eAAe,MAAM,SAAS,MAAM;AAAA,QACxC;AAAA,UACE,MAAM,IAAI;AAAA,UACV,MAAM;AAAA,UACN,KAAK,IAAI;AAAA,UACT,OAAO,IAAI;AAAA,UACX,aAAa,IAAI;AAAA,UACjB,MAAM,IAAI;AAAA,QACZ;AAAA,QACA,EAAE,oBAAoB,KAAK;AAAA,MAC7B;AACA,UAAI,CAAC,aAAa,SAAS;AACzB,eAAO,EAAE,SAAS,OAAO,OAAO,aAAa,MAAM,QAAQ;AAAA,MAC7D;AACA,aAAO,EAAE,SAAS,KAAK;AAAA,IACzB;AAEA,WAAO,EAAE,SAAS,OAAO,OAAO,gCAAgC;AAAA,EAClE,SAAS,OAAO;AACd,WAAO;AAAA,MACL,SAAS;AAAA,MACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,IAC9D;AAAA,EACF;AACF;AAKO,IAAM,eAAoC;AAAA,EAC/C;AAAA,IACE,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAYE,GAAE,OAAO;AAAA,MACnB,OAAOA,GAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,kCAAkC;AAAA,MACzE,QAAQA,GAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,+CAA+C;AAAA,MACvF,SAASA,GAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,qCAAqC;AAAA,IAChF,CAAC;AAAA,IACD,SAAS,CAAC,MAA+B,YAAmD;AAC1F,YAAM,WAA2B,CAAC;AAClC,UAAI,OAAO,KAAK,OAAO,MAAM,WAAW;AACtC,iBAAS,QAAQ,KAAK,OAAO;AAAA,MAC/B;AACA,UAAI,OAAO,KAAK,QAAQ,MAAM,WAAW;AACvC,iBAAS,SAAS,KAAK,QAAQ;AAAA,MACjC;AACA,UAAI,OAAO,KAAK,SAAS,MAAM,WAAW;AACxC,iBAAS,UAAU,KAAK,SAAS;AAAA,MACnC;AACA,aAAO,iBAAiB,UAAU,OAAO;AAAA,IAC3C;AAAA,EACF;AACF;;;AGxPA,gBAAgB,YAAY,aAAa;AACzC,gBAAgB,YAAY,WAAW;AACvC,gBAAgB,YAAY,YAAY;AACxC,gBAAgB,YAAY,YAAY;;;ACLjC,IAAM,gBAA0C,OACrD,MACA,YAC0B;AAE1B,QAAM,YAAY,kBAAkB,MAAM,IAAI;AAE9C,QAAM,cAAc,UAAU,QAAQ,CAAC;AAEvC,SAAO,eAAe,UAAU,SAAS,aAAa,OAAO;AAC/D;;;ACZA,IAAM,kBAAkB;AAOjB,SAAS,eAAe,MAAsB;AACnD,MAAI,CAAC,KAAM,QAAO;AAClB,SAAO,KAAK,KAAK,KAAK,SAAS,eAAe;AAChD;AAOO,SAAS,iBAAiB,QAAwB;AACvD,MAAI,UAAU,KAAM;AAClB,WAAO,KAAK,SAAS,KAAM,QAAQ,CAAC,CAAC;AAAA,EACvC;AACA,SAAO,IAAI,OAAO,MAAM,CAAC;AAC3B;;;ACvBO,IAAM,WAAN,MAAqB;AAAA,EACT,QAAQ,oBAAI,IAAU;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOjB,YAAY,UAAkB,KAAM;AAClC,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,IAAI,KAAQ,OAAgB;AAE1B,QAAI,KAAK,MAAM,IAAI,GAAG,GAAG;AACvB,WAAK,MAAM,OAAO,GAAG;AAAA,IACvB;AAGA,SAAK,MAAM,IAAI,KAAK,KAAK;AAGzB,QAAI,KAAK,MAAM,OAAO,KAAK,SAAS;AAClC,YAAM,WAAW,KAAK,MAAM,KAAK,EAAE,KAAK,EAAE;AAC1C,UAAI,aAAa,QAAW;AAC1B,aAAK,MAAM,OAAO,QAAQ;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,KAAuB;AACzB,UAAM,QAAQ,KAAK,MAAM,IAAI,GAAG;AAEhC,QAAI,UAAU,QAAW;AAEvB,WAAK,MAAM,OAAO,GAAG;AACrB,WAAK,MAAM,IAAI,KAAK,KAAK;AAAA,IAC3B;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,KAAiB;AACnB,WAAO,KAAK,MAAM,IAAI,GAAG;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,KAAiB;AACtB,WAAO,KAAK,MAAM,OAAO,GAAG;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKA,QAAc;AACZ,SAAK,MAAM,MAAM;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,OAAe;AACjB,WAAO,KAAK,MAAM;AAAA,EACpB;AACF;;;AC7FA,IAAM,SAAS,aAAa,YAAY;AAIjC,IAAM,cAAc,IAAI,SAAmC,GAAI;AAQ/D,IAAM,eAAwC,OACnD,MACA,YAC0B;AAE1B,QAAM,YAAY,iBAAiB,MAAM,IAAI;AAE7C,SAAO;AAAA,IACL;AAAA,MACE,OAAO,UAAU;AAAA,MACjB,QAAQ,UAAU;AAAA,MAClB,MAAM,UAAU;AAAA,MAChB,QAAQ,UAAU;AAAA,MAClB,OAAO,UAAU;AAAA,MACjB,QAAQ,UAAU;AAAA,IACpB;AAAA,IACA;AAAA,EACF;AAEA,QAAM,EAAE,SAAS,IAAI;AAGrB,QAAM,WACJ,UAAU,WAAW,SACjB,MAAM,QAAQ;AAAA,IACZ,UAAU,OAAO,IAAI,OAAO,MAAM;AAEhC,YAAM,QAAQ,MAAM,SAAS,MAAM,cAAc,CAAY;AAC7D,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,oBAAoB,CAAC,EAAE;AAAA,MACzC;AACA,aAAO,MAAM;AAAA,IACf,CAAC;AAAA,EACH,KACC,MAAM,SAAS,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,EAAE;AAGnD,MAAI;AACF,eAAW,WAAW,UAAU;AAC9B,YAAM,SAAS,MAAM,WAAW,OAAO;AAAA,IACzC;AAAA,EACF,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,uCAAuC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,IAC/F;AAAA,EACF;AAGA,QAAM,cAA2B;AAAA,IAC/B,OAAO,UAAU;AAAA,IACjB,QAAQ;AAAA,IACR,MAAM,UAAU;AAAA,IAChB,OAAO,UAAU;AAAA,IACjB,QAAQ,UAAU;AAAA,IAClB,WAAW,UAAU;AAAA,IACrB,cAAc,UAAU;AAAA,EAC1B;AAEA,QAAM,UAAU,MAAM,SAAS,OAAO,OAAO,WAAW;AAGxD,aAAW,UAAU,QAAQ,SAAS;AACpC,gBAAY,IAAI,OAAO,IAAI,MAAM;AAAA,EACnC;AAGA,QAAM,kBAAkB,MAAM,QAAQ;AAAA,IACpC,QAAQ,QAAQ,IAAI,OAAO,MAAM;AAC/B,YAAM,UAAU,EAAE,SAAS;AAC3B,YAAM,QAAQ,MAAM,SAAS,MAAM,cAAc,OAAO;AAExD,aAAO;AAAA,QACL,IAAI,EAAE;AAAA,QACN,OAAO,EAAE;AAAA,QACT,SAAS;AAAA,UACP,GAAG,EAAE;AAAA,UACL,WAAW,OAAO;AAAA,UAClB,UAAU,OAAO,SAAS,SAAS,MAAM,OAAO;AAAA,QAClD;AAAA,QACA,SAAS,EAAE;AAAA,QACX,MAAM,EAAE;AAAA,MACV;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,eAAe,KAAK;AAAA,IACxB;AAAA,MACE,SAAS;AAAA,MACT,cAAc,QAAQ;AAAA,MACtB,MAAM,QAAQ;AAAA,MACd,QAAQ,QAAQ;AAAA,MAChB,YAAY,QAAQ;AAAA,MACpB,aAAa,QAAQ;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAGA,QAAM,iBAAiB,eAAe,YAAY;AAGlD,QAAM,iBACJ,QAAQ,eAAe,SAAY,kBAAkB,QAAQ,UAAU,KAAK;AAC9E,QAAM,SAAS,YAAY,UAAU,KAAK,gBAAgB,OAAO,QAAQ,YAAY,CAAC,MAAM,iBAAiB,cAAc,CAAC,aAAa,OAAO,QAAQ,MAAM,CAAC,KAAK,cAAc;AAAA;AAAA;AAGlL,SAAO;AAAA,IACL;AAAA,MACE,OAAO,UAAU;AAAA,MACjB,cAAc,QAAQ;AAAA,MACtB;AAAA,MACA,QAAQ,QAAQ;AAAA,MAChB,GAAG,iBAAiB,cAAc,gBAAgB,UAAU,KAAK;AAAA,IACnE;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM,SAAS;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AACF;AAQO,IAAM,uBAAwD,OACnE,MACA,YAC0B;AAE1B,QAAM,YAAY,yBAAyB,MAAM,IAAI;AAErD,SAAO,KAAK,EAAE,UAAU,UAAU,SAAS,GAAG,4BAA4B;AAG1E,QAAM,WAAW,UAAU;AAG3B,QAAM,eAAe,YAAY,IAAI,QAAQ;AAE7C,MAAI,CAAC,cAAc;AACjB,UAAM,IAAI,MAAM,8BAA8B,QAAQ,wCAAwC;AAAA,EAChG;AAGA,MAAI,aAAa,MAAM;AACrB,UAAMC,gBAAe,KAAK;AAAA,MACxB;AAAA,QACE,IAAI,aAAa;AAAA,QACjB,OAAO,aAAa;AAAA,QACpB,SAAS,aAAa;AAAA,QACtB,SAAS,aAAa;AAAA,QACtB,MAAM,aAAa;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,QACE;AAAA,QACA,QAAQ;AAAA,QACR,gBAAgB;AAAA,QAChB,GAAG,iBAAiBA,eAAc,oBAAoB,QAAQ;AAAA,MAChE;AAAA,MACA;AAAA,IACF;AAEA,WAAO;AAAA,MACL,SAAS;AAAA,QACP;AAAA,UACE,MAAM;AAAA,UACN,MAAMA;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,QAAM,EAAE,SAAS,IAAI;AACrB,QAAM,QAAQ,MAAM,SAAS,MAAM,cAAc,aAAa,SAAS,OAAO;AAE9E,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,oBAAoB,aAAa,SAAS,OAAO,EAAE;AAAA,EACrE;AAEA,QAAM,SAAS,MAAM,WAAW,MAAM,EAAE;AAExC,QAAM,cAA2B;AAAA,IAC/B,OAAO,aAAa,QAAQ,UAAU,GAAG,GAAG;AAAA;AAAA,IAC5C,QAAQ,CAAC,MAAM,EAAE;AAAA,IACjB,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AAEA,QAAM,UAAU,MAAM,SAAS,OAAO,OAAO,WAAW;AAGxD,QAAM,aAAa,QAAQ,QAAQ,KAAK,CAAC,MAAM,EAAE,OAAO,QAAQ;AAEhE,MAAI,CAAC,YAAY;AAEf,WAAO;AAAA,MACL,SAAS;AAAA,QACP;AAAA,UACE,MAAM;AAAA,UACN,MAAM,KAAK;AAAA,YACT;AAAA,cACE,IAAI,aAAa;AAAA,cACjB,OAAO,aAAa;AAAA,cACpB,SAAS,aAAa;AAAA,cACtB,SAAS,aAAa;AAAA,cACtB,SAAS;AAAA,YACX;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,cAAY,IAAI,UAAU,UAAU;AAEpC,QAAM,eAAe,KAAK;AAAA,IACxB;AAAA,MACE,IAAI,WAAW;AAAA,MACf,OAAO,WAAW;AAAA,MAClB,SAAS,WAAW;AAAA,MACpB,SAAS,WAAW;AAAA,MACpB,MAAM,WAAW;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,MACE;AAAA,MACA,QAAQ;AAAA,MACR,gBAAgB;AAAA,MAChB,GAAG,iBAAiB,cAAc,oBAAoB,QAAQ;AAAA,IAChE;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM;AAAA,QACN,MAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;;;ACvQO,IAAM,QAA0B;AAAA,EACrC;AAAA,IACE,MAAM;AAAA,IACN,aACE;AAAA,IACF,QAAQ;AAAA,IACR,SAAS;AAAA,EACX;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,aACE;AAAA,IACF,QAAQ;AAAA,IACR,SAAS;AAAA,EACX;AACF;;;ArB1BA,IAAMC,UAAS,aAAa,YAAY;AAGxC,IAAM,WAAW,gBAAgB,YAAY;AAC7C,IAAI,CAAC,SAAS,aAAa,MAAM,GAAG;AAClC,WAAS,SAAS,IAAI,WAAW,CAAC;AACpC;AAGO,SAAS,gBAAgB,SAAmC;AAEjE,QAAM,SAAS,IAAI;AAAA,IACjB;AAAA,MACE,MAAM;AAAA,MACN,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,cAAc;AAAA,QACZ,OAAO,CAAC;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAGA,SAAO,kBAAkB,wBAAwB,MAAM;AACrD,WAAO,QAAQ,QAAQ;AAAA,MACrB,OAAO;AAAA;AAAA,QAEL;AAAA,UACE,MAAM;AAAA,UACN,aACE;AAAA,UACF,aAAa;AAAA,YACX,MAAM;AAAA,YACN,YAAY;AAAA,cACV,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,aACE;AAAA,cACJ;AAAA,cACA,QAAQ;AAAA,gBACN,MAAM;AAAA,gBACN,MAAM;AAAA,kBACJ;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA;AAAA,gBACF;AAAA,gBACA,aAAa;AAAA,cACf;AAAA,cACA,MAAM;AAAA,gBACJ,MAAM;AAAA,gBACN,MAAM,CAAC,UAAU,OAAO,QAAQ;AAAA,gBAChC,SAAS;AAAA,gBACT,aACE;AAAA,cACJ;AAAA,cACA,QAAQ;AAAA,gBACN,MAAM;AAAA,gBACN,MAAM,CAAC,WAAW,cAAc,MAAM;AAAA,gBACtC,SAAS;AAAA,gBACT,aACE;AAAA,cACJ;AAAA,cACA,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,SAAS;AAAA,gBACT,aAAa;AAAA,cACf;AAAA,cACA,QAAQ;AAAA,gBACN,MAAM;AAAA,gBACN,OAAO,EAAE,MAAM,SAAS;AAAA,gBACxB,aAAa;AAAA,cACf;AAAA,cACA,WAAW;AAAA,gBACT,MAAM;AAAA,gBACN,aAAa;AAAA,cACf;AAAA,cACA,cAAc;AAAA,gBACZ,MAAM;AAAA,gBACN,aACE;AAAA,cACJ;AAAA,YACF;AAAA,YACA,UAAU,CAAC,OAAO;AAAA,UACpB;AAAA,QACF;AAAA;AAAA,QAEA;AAAA,UACE,MAAM;AAAA,UACN,aACE;AAAA,UACF,aAAa;AAAA,YACX,MAAM;AAAA,YACN,YAAY;AAAA,cACV,UAAU;AAAA,gBACR,MAAM;AAAA,gBACN,aAAa;AAAA,cACf;AAAA,YACF;AAAA,YACA,UAAU,CAAC,UAAU;AAAA,UACvB;AAAA,QACF;AAAA;AAAA,QAEA;AAAA,UACE,MAAM;AAAA,UACN,aACE;AAAA,UACF,aAAa;AAAA,YACX,MAAM;AAAA,YACN,YAAY;AAAA,cACV,SAAS;AAAA,gBACP,MAAM;AAAA,gBACN,aAAa;AAAA,cACf;AAAA,cACA,MAAM;AAAA,gBACJ,MAAM;AAAA,gBACN,aAAa;AAAA,cACf;AAAA,YACF;AAAA,YACA,UAAU,CAAC,SAAS;AAAA,UACtB;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AAGD,SAAO,kBAAkB,uBAAuB,OAAO,YAAY;AACjE,UAAM,EAAE,MAAM,WAAW,KAAK,IAAI,QAAQ;AAC1C,UAAM,YAAY,KAAK,IAAI;AAE3B,IAAAA,QAAO,KAAK,EAAE,MAAM,MAAM,MAAM,KAAK,UAAU,IAAI,EAAE,GAAG,cAAc;AAGtE,UAAM,WAAW,MAAM,eAAe,QAAQ,QAAQ,QAAQ,SAAS,QAAQ,WAAW;AAC1F,UAAM,UAAU,EAAE,UAAU,QAAQ;AAEpC,QAAI;AACF,UAAI;AAGJ,UAAI,SAAS,WAAW;AACtB,cAAM,YAAY,kBAAkB,MAAM,QAAQ,CAAC,CAAC;AACpD,iBAAS,MAAM,cAAc,WAAW,OAAO;AAAA,MACjD,OAAO;AAEL,cAAM,OAAO,MAAM,KAAK,CAAC,MAAM,EAAE,SAAS,IAAI;AAC9C,YAAI,SAAS,QAAW;AACtB,gBAAM,IAAI,MAAM,iBAAiB,IAAI,EAAE;AAAA,QACzC;AAGA,cAAM,YAAY,KAAK,OAAO,MAAM,QAAQ,CAAC,CAAC;AAG9C,iBAAS,MAAM,KAAK,QAAQ,WAAW,OAAO;AAAA,MAChD;AAEA,YAAM,aAAa,KAAK,IAAI,IAAI;AAChC,MAAAA,QAAO,KAAK,EAAE,MAAM,MAAM,WAAW,GAAG,gBAAgB;AAExD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM,aAAa,KAAK,IAAI,IAAI;AAChC,MAAAA,QAAO;AAAA,QACL;AAAA,UACE,MAAM;AAAA,UACN;AAAA,UACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,QAC9D;AAAA,QACA;AAAA,MACF;AACA,YAAM;AAAA,IACR,UAAE;AAGA,YAAM,gBAAgB,QAAQ;AAAA,IAChC;AAAA,EACF,CAAC;AAED,SAAO;AACT;AAEA,eAAsB,aAAa,SAA0C;AAC3E,EAAAA,QAAO;AAAA,IACL;AAAA,MACE,SAAS,QAAQ;AAAA,MACjB,aAAa,QAAQ;AAAA,IACvB;AAAA,IACA;AAAA,EACF;AAEA,QAAM,SAAS,gBAAgB,OAAO;AACtC,QAAM,YAAY,IAAI,qBAAqB;AAC3C,QAAM,OAAO,QAAQ,SAAS;AAE9B,EAAAA,QAAO,KAAK,yCAAyC;AACvD;AAIA,IAAM,aAAa,QAAQ,KAAK,CAAC,KAAK;AACtC,IAAM,mBAAmB,WAAW,SAAS,eAAe,KAAK,WAAW,SAAS,YAAY;AAEjG,IAAI,kBAAkB;AACpB,QAAM,cAAc,QAAQ,IAAI,cAAc;AAC9C,MAAI,gBAAgB,QAAW;AAC7B,UAAM,IAAI,MAAM,+CAA+C;AAAA,EACjE;AACA,eAAa;AAAA,IACX,SAAS,QAAQ,IAAI,UAAU;AAAA,IAC/B,QAAQ,QAAQ,IAAI,aAAa;AAAA,IACjC;AAAA,EACF,CAAC,EAAE,MAAM,CAAC,UAAmB;AAC3B,IAAAA,QAAO;AAAA,MACL,EAAE,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,EAAE;AAAA,MAChE;AAAA,IACF;AACA,YAAQ,KAAK,CAAC;AAAA,EAChB,CAAC;AACH;","names":["z","z","z","z","lines","z","z","__dirname","z","z","join","z","path","join","z","responseJson","logger"]}