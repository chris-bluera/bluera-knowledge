{"version":3,"sources":["../src/mcp/server.ts","../src/mcp/schemas/index.ts","../src/mcp/cache.ts","../src/mcp/handlers/search.handler.ts","../src/mcp/handlers/store.handler.ts","../src/workers/spawn-worker.ts","../src/mcp/handlers/job.handler.ts","../src/mcp/handlers/index.ts"],"sourcesContent":["import { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { createServices } from '../services/index.js';\nimport { tools } from './handlers/index.js';\nimport type { MCPServerOptions } from './types.js';\n\n// eslint-disable-next-line @typescript-eslint/no-deprecated\nexport function createMCPServer(options: MCPServerOptions): Server {\n  // eslint-disable-next-line @typescript-eslint/no-deprecated\n  const server = new Server(\n    {\n      name: 'bluera-knowledge',\n      version: '1.0.0',\n    },\n    {\n      capabilities: {\n        tools: {},\n      },\n    }\n  );\n\n  // List available tools\n  server.setRequestHandler(ListToolsRequestSchema, () => {\n    return Promise.resolve({\n      tools: [\n        {\n          name: 'search',\n          description: 'Search all indexed knowledge stores with pattern detection and AI-optimized results. Returns structured code units with progressive context layers.',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              query: {\n                type: 'string',\n                description: 'Search query (can include type signatures, constraints, or natural language)'\n              },\n              intent: {\n                type: 'string',\n                enum: ['find-pattern', 'find-implementation', 'find-usage', 'find-definition', 'find-documentation'],\n                description: 'Search intent for better ranking'\n              },\n              detail: {\n                type: 'string',\n                enum: ['minimal', 'contextual', 'full'],\n                default: 'minimal',\n                description: 'Context detail level: minimal (summary only), contextual (+ imports/types), full (+ complete code)'\n              },\n              limit: {\n                type: 'number',\n                default: 10,\n                description: 'Maximum number of results'\n              },\n              stores: {\n                type: 'array',\n                items: { type: 'string' },\n                description: 'Specific store IDs to search (optional)'\n              }\n            },\n            required: ['query']\n          }\n        },\n        {\n          name: 'list_stores',\n          description: 'List all indexed knowledge stores (library sources, reference material, documentation)',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              type: {\n                type: 'string',\n                enum: ['file', 'repo', 'web'],\n                description: 'Filter by store type (optional)'\n              }\n            }\n          }\n        },\n        {\n          name: 'get_store_info',\n          description: 'Get detailed information about a specific store including its file path for direct access',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              store: {\n                type: 'string',\n                description: 'Store name or ID'\n              }\n            },\n            required: ['store']\n          }\n        },\n        {\n          name: 'create_store',\n          description: 'Create a new knowledge store from git URL or local path',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              name: {\n                type: 'string',\n                description: 'Store name'\n              },\n              type: {\n                type: 'string',\n                enum: ['file', 'repo'],\n                description: 'Store type'\n              },\n              source: {\n                type: 'string',\n                description: 'Git URL or local path'\n              },\n              branch: {\n                type: 'string',\n                description: 'Git branch (for repo type)'\n              },\n              description: {\n                type: 'string',\n                description: 'Store description'\n              }\n            },\n            required: ['name', 'type', 'source']\n          }\n        },\n        {\n          name: 'index_store',\n          description: 'Index or re-index a knowledge store to make it searchable',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              store: {\n                type: 'string',\n                description: 'Store name or ID'\n              }\n            },\n            required: ['store']\n          }\n        },\n        {\n          name: 'delete_store',\n          description: 'Delete a knowledge store and all associated data (database, cloned files)',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              store: {\n                type: 'string',\n                description: 'Store name or ID to delete'\n              }\n            },\n            required: ['store']\n          }\n        },\n        {\n          name: 'get_full_context',\n          description: 'Get complete code and context for a specific search result by ID. Use this after search to get full implementation details.',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              resultId: {\n                type: 'string',\n                description: 'Result ID from previous search'\n              }\n            },\n            required: ['resultId']\n          }\n        },\n        {\n          name: 'check_job_status',\n          description: 'Check the status of a background job (clone, index, crawl operations)',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              jobId: {\n                type: 'string',\n                description: 'Job ID to check status for'\n              }\n            },\n            required: ['jobId']\n          }\n        },\n        {\n          name: 'list_jobs',\n          description: 'List all background jobs, optionally filtered by status',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              status: {\n                type: 'string',\n                enum: ['pending', 'running', 'completed', 'failed', 'cancelled'],\n                description: 'Filter jobs by status (optional)'\n              },\n              activeOnly: {\n                type: 'boolean',\n                default: false,\n                description: 'Only show active (pending/running) jobs'\n              }\n            }\n          }\n        },\n        {\n          name: 'cancel_job',\n          description: 'Cancel a running or pending background job',\n          inputSchema: {\n            type: 'object',\n            properties: {\n              jobId: {\n                type: 'string',\n                description: 'Job ID to cancel'\n              }\n            },\n            required: ['jobId']\n          }\n        }\n      ]\n    });\n  });\n\n  // Handle tool calls\n  server.setRequestHandler(CallToolRequestSchema, async (request) => {\n    const { name, arguments: args } = request.params;\n\n    // Find handler in registry\n    const tool = tools.find(t => t.name === name);\n    if (!tool) {\n      throw new Error(`Unknown tool: ${name}`);\n    }\n\n    // Validate arguments with Zod\n    const validated = tool.schema.parse(args ?? {});\n\n    // Create services once\n    const services = await createServices(\n      options.config,\n      options.dataDir,\n      options.projectRoot\n    );\n\n    // Execute handler with context\n    return tool.handler(validated, { services, options });\n  });\n\n  return server;\n}\n\nexport async function runMCPServer(options: MCPServerOptions): Promise<void> {\n  const server = createMCPServer(options);\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n\n  console.error('Bluera Knowledge MCP server running on stdio');\n}\n\n// Run the server when this file is executed directly\nrunMCPServer({\n  dataDir: process.env['DATA_DIR'],\n  config: process.env['CONFIG_PATH'],\n  projectRoot: process.env['PROJECT_ROOT'] ?? process.env['PWD']\n}).catch((error: unknown) => {\n  console.error('Failed to start MCP server:', error);\n  process.exit(1);\n});\n","import { z } from 'zod';\n\n/**\n * Validation schemas for all MCP tool inputs\n *\n * These schemas provide runtime type validation and better error messages\n * compared to manual type assertions.\n */\n\n// ============================================================================\n// Search Tool Schemas\n// ============================================================================\n\n/**\n * Schema for search tool arguments\n */\nexport const SearchArgsSchema = z.object({\n  query: z.string().min(1, 'Query must be a non-empty string'),\n  intent: z\n    .enum(['find-pattern', 'find-implementation', 'find-usage', 'find-definition', 'find-documentation'])\n    .optional(),\n  detail: z.enum(['minimal', 'contextual', 'full']).default('minimal'),\n  limit: z.number().int().positive().default(10),\n  stores: z.array(z.string()).optional()\n});\n\nexport type SearchArgs = z.infer<typeof SearchArgsSchema>;\n\n/**\n * Schema for get_full_context tool arguments\n */\nexport const GetFullContextArgsSchema = z.object({\n  resultId: z.string().min(1, 'Result ID must be a non-empty string')\n});\n\nexport type GetFullContextArgs = z.infer<typeof GetFullContextArgsSchema>;\n\n// ============================================================================\n// Store Tool Schemas\n// ============================================================================\n\n/**\n * Schema for list_stores tool arguments\n */\nexport const ListStoresArgsSchema = z.object({\n  type: z.enum(['file', 'repo', 'web']).optional()\n});\n\nexport type ListStoresArgs = z.infer<typeof ListStoresArgsSchema>;\n\n/**\n * Schema for get_store_info tool arguments\n */\nexport const GetStoreInfoArgsSchema = z.object({\n  store: z.string().min(1, 'Store name or ID must be a non-empty string')\n});\n\nexport type GetStoreInfoArgs = z.infer<typeof GetStoreInfoArgsSchema>;\n\n/**\n * Schema for create_store tool arguments\n */\nexport const CreateStoreArgsSchema = z.object({\n  name: z.string().min(1, 'Store name must be a non-empty string'),\n  type: z.enum(['file', 'repo']),\n  source: z.string().min(1, 'Source path or URL must be a non-empty string'),\n  branch: z.string().optional(),\n  description: z.string().optional()\n});\n\nexport type CreateStoreArgs = z.infer<typeof CreateStoreArgsSchema>;\n\n/**\n * Schema for index_store tool arguments\n */\nexport const IndexStoreArgsSchema = z.object({\n  store: z.string().min(1, 'Store name or ID must be a non-empty string')\n});\n\nexport type IndexStoreArgs = z.infer<typeof IndexStoreArgsSchema>;\n\n/**\n * Schema for delete_store tool arguments\n */\nexport const DeleteStoreArgsSchema = z.object({\n  store: z.string().min(1, 'Store name or ID must be a non-empty string')\n});\n\nexport type DeleteStoreArgs = z.infer<typeof DeleteStoreArgsSchema>;\n\n// ============================================================================\n// Job Tool Schemas\n// ============================================================================\n\n/**\n * Schema for check_job_status tool arguments\n */\nexport const CheckJobStatusArgsSchema = z.object({\n  jobId: z.string().min(1, 'Job ID must be a non-empty string')\n});\n\nexport type CheckJobStatusArgs = z.infer<typeof CheckJobStatusArgsSchema>;\n\n/**\n * Schema for list_jobs tool arguments\n */\nexport const ListJobsArgsSchema = z.object({\n  activeOnly: z.boolean().optional(),\n  status: z.enum(['pending', 'running', 'completed', 'failed', 'cancelled']).optional()\n});\n\nexport type ListJobsArgs = z.infer<typeof ListJobsArgsSchema>;\n\n/**\n * Schema for cancel_job tool arguments\n */\nexport const CancelJobArgsSchema = z.object({\n  jobId: z.string().min(1, 'Job ID must be a non-empty string')\n});\n\nexport type CancelJobArgs = z.infer<typeof CancelJobArgsSchema>;\n","/**\n * LRU (Least Recently Used) Cache implementation\n *\n * Maintains a cache with a maximum size, evicting the oldest (least recently used)\n * items when the capacity is exceeded. This prevents unbounded memory growth.\n *\n * Items are automatically moved to the end of the cache when accessed (via get),\n * making them the most recently used.\n */\nexport class LRUCache<K, V> {\n  private readonly cache = new Map<K, V>();\n  private readonly maxSize: number;\n\n  /**\n   * Create a new LRU cache\n   *\n   * @param maxSize - Maximum number of items to store (default: 1000)\n   */\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Store a value in the cache\n   *\n   * If the key already exists, it will be moved to the end (most recent).\n   * If the cache is at capacity, the oldest item will be evicted.\n   *\n   * @param key - The cache key\n   * @param value - The value to store\n   */\n  set(key: K, value: V): void {\n    // If key exists, delete it first to move it to the end\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    // Add the new/updated entry\n    this.cache.set(key, value);\n\n    // Evict oldest entry if over capacity\n    if (this.cache.size > this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey !== undefined) {\n        this.cache.delete(firstKey);\n      }\n    }\n  }\n\n  /**\n   * Retrieve a value from the cache\n   *\n   * If the key exists, it will be moved to the end (most recent).\n   *\n   * @param key - The cache key\n   * @returns The cached value, or undefined if not found\n   */\n  get(key: K): V | undefined {\n    const value = this.cache.get(key);\n\n    if (value !== undefined) {\n      // Move to end (most recent) by deleting and re-adding\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Check if a key exists in the cache\n   *\n   * @param key - The cache key\n   * @returns True if the key exists\n   */\n  has(key: K): boolean {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Remove a specific key from the cache\n   *\n   * @param key - The cache key\n   * @returns True if the key was removed, false if it didn't exist\n   */\n  delete(key: K): boolean {\n    return this.cache.delete(key);\n  }\n\n  /**\n   * Clear all entries from the cache\n   */\n  clear(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get the current number of items in the cache\n   */\n  get size(): number {\n    return this.cache.size;\n  }\n}\n","import type { ToolHandler, ToolResponse } from '../types.js';\nimport type { SearchArgs, GetFullContextArgs } from '../schemas/index.js';\nimport { SearchArgsSchema, GetFullContextArgsSchema } from '../schemas/index.js';\nimport type { SearchQuery, DocumentId, StoreId } from '../../types/index.js';\nimport { LRUCache } from '../cache.js';\nimport type { SearchResult } from '../../types/search.js';\n\n// Create result cache for get_full_context\n// Uses LRU cache to prevent memory leaks (max 1000 items)\nexport const resultCache = new LRUCache<DocumentId, SearchResult>(1000);\n\n/**\n * Handle search requests\n *\n * Searches across specified stores (or all stores if none specified) using\n * hybrid vector + FTS search. Results are cached for get_full_context retrieval.\n */\nexport const handleSearch: ToolHandler<SearchArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = SearchArgsSchema.parse(args);\n\n  const { services } = context;\n\n  // Get all stores if none specified, resolve store names to IDs\n  const storeIds: StoreId[] = validated.stores !== undefined\n    ? await Promise.all(validated.stores.map(async (s) => {\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        const store = await services.store.getByIdOrName(s as StoreId);\n        if (!store) {\n          throw new Error(`Store not found: ${s}`);\n        }\n        return store.id;\n      }))\n    : (await services.store.list()).map(s => s.id);\n\n  // Initialize stores with error handling\n  try {\n    for (const storeId of storeIds) {\n      await services.lance.initialize(storeId);\n    }\n  } catch (error) {\n    throw new Error(\n      `Failed to initialize vector stores: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n\n  // Perform search\n  const searchQuery: SearchQuery = {\n    query: validated.query,\n    stores: storeIds,\n    mode: 'hybrid',\n    limit: validated.limit,\n    detail: validated.detail\n  };\n\n  const results = await services.search.search(searchQuery);\n\n  // Cache results for get_full_context (with LRU eviction)\n  for (const result of results.results) {\n    resultCache.set(result.id, result);\n  }\n\n  // Calculate estimated tokens\n  const estimatedTokens = results.results.reduce((sum, r) => {\n    let tokens = 100; // Base for summary\n    if (r.context) tokens += 200;\n    if (r.full) tokens += 800;\n    return sum + tokens;\n  }, 0);\n\n  // Add repoRoot to results for cloned repos\n  const enhancedResults = await Promise.all(results.results.map(async (r) => {\n    const storeId = r.metadata.storeId;\n    const store = await services.store.getByIdOrName(storeId);\n\n    return {\n      id: r.id,\n      score: r.score,\n      summary: {\n        ...r.summary,\n        storeName: store?.name,\n        repoRoot: store !== undefined && store.type === 'repo' ? store.path : undefined\n      },\n      context: r.context,\n      full: r.full\n    };\n  }));\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          results: enhancedResults,\n          totalResults: results.totalResults,\n          estimatedTokens,\n          mode: results.mode,\n          timeMs: results.timeMs\n        }, null, 2)\n      }\n    ]\n  };\n};\n\n/**\n * Handle get_full_context requests\n *\n * Retrieves full context for a previously cached search result.\n * If the result isn't already full, re-queries with full detail level.\n */\nexport const handleGetFullContext: ToolHandler<GetFullContextArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = GetFullContextArgsSchema.parse(args);\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const resultId = validated.resultId as DocumentId;\n\n  // Check cache for result\n  const cachedResult = resultCache.get(resultId);\n\n  if (!cachedResult) {\n    throw new Error(\n      `Result not found in cache: ${resultId}. Run a search first to cache results.`\n    );\n  }\n\n  // If result already has full context, return it\n  if (cachedResult.full) {\n    return {\n      content: [\n        {\n          type: 'text',\n          text: JSON.stringify({\n            id: cachedResult.id,\n            score: cachedResult.score,\n            summary: cachedResult.summary,\n            context: cachedResult.context,\n            full: cachedResult.full\n          }, null, 2)\n        }\n      ]\n    };\n  }\n\n  // Otherwise, re-query with full detail\n  const { services } = context;\n  const store = await services.store.getByIdOrName(cachedResult.metadata.storeId);\n\n  if (!store) {\n    throw new Error(`Store not found: ${cachedResult.metadata.storeId}`);\n  }\n\n  await services.lance.initialize(store.id);\n\n  const searchQuery: SearchQuery = {\n    query: cachedResult.content.substring(0, 100), // Use snippet of content as query\n    stores: [store.id],\n    mode: 'hybrid',\n    limit: 1,\n    detail: 'full'\n  };\n\n  const results = await services.search.search(searchQuery);\n\n  // Find matching result by ID\n  const fullResult = results.results.find(r => r.id === resultId);\n\n  if (!fullResult) {\n    // Return cached result even if we couldn't get full detail\n    return {\n      content: [\n        {\n          type: 'text',\n          text: JSON.stringify({\n            id: cachedResult.id,\n            score: cachedResult.score,\n            summary: cachedResult.summary,\n            context: cachedResult.context,\n            warning: 'Could not retrieve full context, returning cached minimal result'\n          }, null, 2)\n        }\n      ]\n    };\n  }\n\n  // Update cache with full result\n  resultCache.set(resultId, fullResult);\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          id: fullResult.id,\n          score: fullResult.score,\n          summary: fullResult.summary,\n          context: fullResult.context,\n          full: fullResult.full\n        }, null, 2)\n      }\n    ]\n  };\n};\n","import { rm } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport type { ToolHandler, ToolResponse } from '../types.js';\nimport type {\n  ListStoresArgs,\n  GetStoreInfoArgs,\n  CreateStoreArgs,\n  IndexStoreArgs,\n  DeleteStoreArgs\n} from '../schemas/index.js';\nimport {\n  ListStoresArgsSchema,\n  GetStoreInfoArgsSchema,\n  CreateStoreArgsSchema,\n  IndexStoreArgsSchema,\n  DeleteStoreArgsSchema\n} from '../schemas/index.js';\nimport { JobService } from '../../services/job.service.js';\nimport { spawnBackgroundWorker } from '../../workers/spawn-worker.js';\nimport { createStoreId } from '../../types/brands.js';\n\n/**\n * Handle list_stores requests\n *\n * Lists all knowledge stores with optional type filtering.\n */\nexport const handleListStores: ToolHandler<ListStoresArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = ListStoresArgsSchema.parse(args);\n\n  const { services } = context;\n\n  const stores = await services.store.list();\n  const filtered = validated.type !== undefined\n    ? stores.filter(s => s.type === validated.type)\n    : stores;\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          stores: filtered.map(s => ({\n            id: s.id,\n            name: s.name,\n            type: s.type,\n            path: 'path' in s ? s.path : undefined,\n            url: 'url' in s && s.url !== undefined ? s.url : undefined,\n            description: s.description,\n            createdAt: s.createdAt.toISOString()\n          }))\n        }, null, 2)\n      }\n    ]\n  };\n};\n\n/**\n * Handle get_store_info requests\n *\n * Retrieves detailed information about a specific store.\n */\nexport const handleGetStoreInfo: ToolHandler<GetStoreInfoArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = GetStoreInfoArgsSchema.parse(args);\n\n  const { services } = context;\n\n  const store = await services.store.getByIdOrName(createStoreId(validated.store));\n\n  if (store === undefined) {\n    throw new Error(`Store not found: ${validated.store}`);\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          id: store.id,\n          name: store.name,\n          type: store.type,\n          path: 'path' in store ? store.path : undefined,\n          url: 'url' in store && store.url !== undefined ? store.url : undefined,\n          branch: 'branch' in store ? store.branch : undefined,\n          description: store.description,\n          status: store.status,\n          createdAt: store.createdAt.toISOString(),\n          updatedAt: store.updatedAt.toISOString()\n        }, null, 2)\n      }\n    ]\n  };\n};\n\n/**\n * Handle create_store requests\n *\n * Creates a new knowledge store and starts background indexing.\n * Returns store info and job ID for tracking progress.\n */\nexport const handleCreateStore: ToolHandler<CreateStoreArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = CreateStoreArgsSchema.parse(args);\n\n  const { services, options } = context;\n\n  // Determine if source is a URL or path\n  const isUrl = validated.source.startsWith('http://') ||\n                validated.source.startsWith('https://') ||\n                validated.source.startsWith('git@');\n\n  const result = await services.store.create({\n    name: validated.name,\n    type: validated.type,\n    ...(isUrl ? { url: validated.source } : { path: validated.source }),\n    ...(validated.branch !== undefined ? { branch: validated.branch } : {}),\n    ...(validated.description !== undefined ? { description: validated.description } : {})\n  });\n\n  if (!result.success) {\n    throw new Error(result.error.message);\n  }\n\n  // Create background job for indexing\n  const jobService = new JobService(options.dataDir);\n  const jobDetails: Record<string, unknown> = {\n    storeName: result.data.name,\n    storeId: result.data.id\n  };\n  if (isUrl) {\n    jobDetails['url'] = validated.source;\n  }\n  if ('path' in result.data && result.data.path) {\n    jobDetails['path'] = result.data.path;\n  }\n  const job = jobService.createJob({\n    type: validated.type === 'repo' && isUrl ? 'clone' : 'index',\n    details: jobDetails,\n    message: `Indexing ${result.data.name}...`\n  });\n\n  // Spawn background worker (dataDir defaults to project-local .bluera if undefined)\n  spawnBackgroundWorker(job.id, options.dataDir ?? '');\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          store: {\n            id: result.data.id,\n            name: result.data.name,\n            type: result.data.type,\n            path: 'path' in result.data ? result.data.path : undefined\n          },\n          job: {\n            id: job.id,\n            status: job.status,\n            message: job.message\n          },\n          message: `Store created. Indexing started in background (Job ID: ${job.id})`\n        }, null, 2)\n      }\n    ]\n  };\n};\n\n/**\n * Handle index_store requests\n *\n * Re-indexes an existing store in the background.\n * Returns job ID for tracking progress.\n */\nexport const handleIndexStore: ToolHandler<IndexStoreArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = IndexStoreArgsSchema.parse(args);\n\n  const { services, options } = context;\n\n  const store = await services.store.getByIdOrName(createStoreId(validated.store));\n\n  if (store === undefined) {\n    throw new Error(`Store not found: ${validated.store}`);\n  }\n\n  // Create background job for indexing\n  const jobService = new JobService(options.dataDir);\n  const jobDetails: Record<string, unknown> = {\n    storeName: store.name,\n    storeId: store.id\n  };\n  if ('path' in store && store.path) {\n    jobDetails['path'] = store.path;\n  }\n  const job = jobService.createJob({\n    type: 'index',\n    details: jobDetails,\n    message: `Re-indexing ${store.name}...`\n  });\n\n  // Spawn background worker (dataDir defaults to project-local .bluera if undefined)\n  spawnBackgroundWorker(job.id, options.dataDir ?? '');\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          store: {\n            id: store.id,\n            name: store.name\n          },\n          job: {\n            id: job.id,\n            status: job.status,\n            message: job.message\n          },\n          message: `Indexing started in background (Job ID: ${job.id})`\n        }, null, 2)\n      }\n    ]\n  };\n};\n\n/**\n * Handle delete_store requests\n *\n * Deletes a store and all associated data:\n * - Removes from store registry\n * - Drops LanceDB table\n * - For repo stores with URL, removes cloned files\n */\nexport const handleDeleteStore: ToolHandler<DeleteStoreArgs> = async (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = DeleteStoreArgsSchema.parse(args);\n\n  const { services, options } = context;\n\n  const store = await services.store.getByIdOrName(createStoreId(validated.store));\n\n  if (store === undefined) {\n    throw new Error(`Store not found: ${validated.store}`);\n  }\n\n  // Delete LanceDB table\n  await services.lance.deleteStore(store.id);\n\n  // For repo stores cloned from URL, remove the cloned directory\n  if (store.type === 'repo' && 'url' in store && store.url !== undefined) {\n    if (options.dataDir === undefined) {\n      throw new Error('dataDir is required to delete cloned repository files');\n    }\n    const repoPath = join(options.dataDir, 'repos', store.id);\n    await rm(repoPath, { recursive: true, force: true });\n  }\n\n  // Delete from registry\n  const result = await services.store.delete(store.id);\n  if (!result.success) {\n    throw new Error(result.error.message);\n  }\n\n  return {\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          deleted: true,\n          store: {\n            id: store.id,\n            name: store.name,\n            type: store.type\n          },\n          message: `Successfully deleted store: ${store.name}`\n        }, null, 2)\n      }\n    ]\n  };\n};\n","import { spawn } from 'child_process';\nimport { fileURLToPath } from 'url';\nimport path from 'path';\n\n/**\n * Spawn a background worker process to execute a job\n *\n * The worker runs detached from the parent process, allowing the\n * parent to exit while the worker continues running.\n *\n * @param jobId - The ID of the job to execute\n */\nexport function spawnBackgroundWorker(jobId: string, dataDir: string): void {\n  // Determine the worker script path\n  // In production, this will be the compiled dist file\n  // In development, we need to use tsx to run TypeScript\n  const __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n  // Check if we're running from dist (production) or src (development)\n  const isProduction = __dirname.includes('/dist/');\n\n  let command: string;\n  let args: string[];\n\n  if (isProduction) {\n    // Production: Use Node.js directly with compiled file\n    const workerScript = path.join(__dirname, 'background-worker-cli.js');\n    command = process.execPath; // Use the same Node.js binary\n    args = [workerScript, jobId];\n  } else {\n    // Development: Use tsx to run TypeScript directly\n    const workerScript = path.join(__dirname, 'background-worker-cli.ts');\n    command = 'npx';\n    args = ['tsx', workerScript, jobId];\n  }\n\n  // Spawn the worker process\n  const worker = spawn(command, args, {\n    detached: true,      // Detach from parent process\n    stdio: 'ignore',     // Don't pipe stdio (fully independent)\n    env: {\n      ...process.env,    // Inherit environment variables\n      BLUERA_DATA_DIR: dataDir  // Pass dataDir to worker\n    }\n  });\n\n  // Unref the worker so the parent can exit\n  worker.unref();\n}\n","import type { ToolHandler, ToolResponse } from '../types.js';\nimport type {\n  CheckJobStatusArgs,\n  ListJobsArgs,\n  CancelJobArgs\n} from '../schemas/index.js';\nimport {\n  CheckJobStatusArgsSchema,\n  ListJobsArgsSchema,\n  CancelJobArgsSchema\n} from '../schemas/index.js';\nimport { JobService } from '../../services/job.service.js';\n\n/**\n * Handle check_job_status requests\n *\n * Retrieves the current status of a background job.\n */\nexport const handleCheckJobStatus: ToolHandler<CheckJobStatusArgs> = (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = CheckJobStatusArgsSchema.parse(args);\n\n  const { options } = context;\n\n  const jobService = new JobService(options.dataDir);\n  const job = jobService.getJob(validated.jobId);\n\n  if (!job) {\n    throw new Error(`Job not found: ${validated.jobId}`);\n  }\n\n  return Promise.resolve({\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify(job, null, 2)\n      }\n    ]\n  });\n};\n\n/**\n * Handle list_jobs requests\n *\n * Lists all jobs with optional filtering by status or active status.\n */\nexport const handleListJobs: ToolHandler<ListJobsArgs> = (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = ListJobsArgsSchema.parse(args);\n\n  const { options } = context;\n\n  const jobService = new JobService(options.dataDir);\n\n  let jobs;\n  if (validated.activeOnly === true) {\n    jobs = jobService.listActiveJobs();\n  } else if (validated.status !== undefined) {\n    jobs = jobService.listJobs(validated.status);\n  } else {\n    jobs = jobService.listJobs();\n  }\n\n  return Promise.resolve({\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({ jobs }, null, 2)\n      }\n    ]\n  });\n};\n\n/**\n * Handle cancel_job requests\n *\n * Cancels a running or pending background job.\n * Kills the worker process if it exists.\n */\nexport const handleCancelJob: ToolHandler<CancelJobArgs> = (\n  args,\n  context\n): Promise<ToolResponse> => {\n  // Validate arguments with Zod\n  const validated = CancelJobArgsSchema.parse(args);\n\n  const { options } = context;\n\n  const jobService = new JobService(options.dataDir);\n  const result = jobService.cancelJob(validated.jobId);\n\n  if (!result.success) {\n    throw new Error(result.error.message);\n  }\n\n  const job = jobService.getJob(validated.jobId);\n\n  return Promise.resolve({\n    content: [\n      {\n        type: 'text',\n        text: JSON.stringify({\n          success: true,\n          job,\n          message: 'Job cancelled successfully'\n        }, null, 2)\n      }\n    ]\n  });\n};\n","import { z } from 'zod';\nimport type { ToolHandler } from '../types.js';\nimport {\n  SearchArgsSchema,\n  GetFullContextArgsSchema,\n  ListStoresArgsSchema,\n  GetStoreInfoArgsSchema,\n  CreateStoreArgsSchema,\n  IndexStoreArgsSchema,\n  DeleteStoreArgsSchema,\n  CheckJobStatusArgsSchema,\n  ListJobsArgsSchema,\n  CancelJobArgsSchema\n} from '../schemas/index.js';\nimport {\n  handleSearch,\n  handleGetFullContext\n} from './search.handler.js';\nimport {\n  handleListStores,\n  handleGetStoreInfo,\n  handleCreateStore,\n  handleIndexStore,\n  handleDeleteStore\n} from './store.handler.js';\nimport {\n  handleCheckJobStatus,\n  handleListJobs,\n  handleCancelJob\n} from './job.handler.js';\n\n/**\n * Tool definition with schema and handler\n */\nexport interface ToolDefinition {\n  name: string;\n  description: string;\n  schema: z.ZodType;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handler: ToolHandler<any>;\n}\n\n/**\n * Registry of all MCP tools\n *\n * Each tool has a name, description, Zod validation schema, and handler function.\n * This registry is used by the server to route requests to the appropriate handler.\n */\nexport const tools: ToolDefinition[] = [\n  // Search tools\n  {\n    name: 'search',\n    description: 'Search all indexed knowledge stores with pattern detection and AI-optimized results. Returns structured code units with progressive context layers.',\n    schema: SearchArgsSchema,\n    handler: handleSearch\n  },\n  {\n    name: 'get_full_context',\n    description: 'Get complete code and context for a specific search result by ID. Use this after search to get full implementation details.',\n    schema: GetFullContextArgsSchema,\n    handler: handleGetFullContext\n  },\n\n  // Store tools\n  {\n    name: 'list_stores',\n    description: 'List all indexed knowledge stores (library sources, reference material, documentation)',\n    schema: ListStoresArgsSchema,\n    handler: handleListStores\n  },\n  {\n    name: 'get_store_info',\n    description: 'Get detailed information about a specific store including its file path for direct access',\n    schema: GetStoreInfoArgsSchema,\n    handler: handleGetStoreInfo\n  },\n  {\n    name: 'create_store',\n    description: 'Create a new knowledge store from git URL or local path',\n    schema: CreateStoreArgsSchema,\n    handler: handleCreateStore\n  },\n  {\n    name: 'index_store',\n    description: 'Index or re-index a knowledge store to make it searchable',\n    schema: IndexStoreArgsSchema,\n    handler: handleIndexStore\n  },\n  {\n    name: 'delete_store',\n    description: 'Delete a knowledge store and all associated data (database, cloned files)',\n    schema: DeleteStoreArgsSchema,\n    handler: handleDeleteStore\n  },\n\n  // Job tools\n  {\n    name: 'check_job_status',\n    description: 'Check the status of a background job (clone, index, crawl operations)',\n    schema: CheckJobStatusArgsSchema,\n    handler: handleCheckJobStatus\n  },\n  {\n    name: 'list_jobs',\n    description: 'List all background jobs, optionally filtered by status',\n    schema: ListJobsArgsSchema,\n    handler: handleListJobs\n  },\n  {\n    name: 'cancel_job',\n    description: 'Cancel a running or pending background job',\n    schema: CancelJobArgsSchema,\n    handler: handleCancelJob\n  }\n];\n"],"mappings":"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","names":["__dirname"]}